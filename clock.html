<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Google tag (gtag.js) -->
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-WVTLP8XP3Z"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-WVTLP8XP3Z");
    </script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ClockTask Pro - Visual Scheduler</title>
    <!-- ADDED DSEG Font CDN -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/dseg@latest/dseg.css"
    />

    <style>
      /* --- GLOBAL STYLES & SETUP --- */
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap");
      @import url("https://fonts.cdnfonts.com/css/seven-segment");

      :root {
        --bg-color: #f4f7f9;
        --clock-bg: #ffffff;
        --text-color: #333;
        --primary-color: #007aff;
        --secondary-color: #8e8e93;
        --danger-color: #ff3b30;
        --shadow-color: rgba(0, 0, 0, 0.1);
        --border-color: #e5e5ea;
        --completed-color: #555555;
        --uncompleted-past-color: #d1d1d6;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        overflow: auto;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        padding: 1rem;
      }

      .app-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 2rem;
        width: 100%;
        /* Removed max-width constraint to allow full centering freely, 
           but you can keep it if you want to limit the vertical stack width. 
           For now, centering the clock is priority. */
        max-width: 100vw;
      }

      /* --- CALENDAR WIDGET --- */
      .calendar-widget {
        position: fixed;
        top: 1.5rem;
        left: 1.5rem;
        width: clamp(300px, 22vw, 360px);
        z-index: 500;
        background-color: var(--clock-bg);
        border-radius: 16px;
        padding: 1.5rem;
        box-shadow: 0 4px 15px var(--shadow-color);
        border: 1px solid var(--border-color);
        /* FIX #1: Added vendor prefix for Safari compatibility */
        -webkit-user-select: none;
        user-select: none;
      }
      .calendar-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
        color: var(--danger-color);
      }
      .month-year {
        font-weight: 700;
        cursor: pointer;
      }
      .month-year .month {
        font-size: 1.75rem;
      }
      .month-year .year {
        font-size: 1.25rem;
        font-weight: 500;
        opacity: 0.7;
      }
      .calendar-nav {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .calendar-arrows {
        display: flex;
        background-color: #f0f0f0;
        border-radius: 99px;
        padding: 4px;
        gap: 2px;
      }
      .calendar-nav button {
        background: transparent;
        border: none;
        cursor: pointer;
        padding: 0;
        border-radius: 50%;
        width: 28px;
        height: 28px;
        display: grid;
        place-items: center;
        transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
        color: var(--secondary-color);
      }
      .calendar-nav button:hover {
        background-color: white;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        color: #1d1d1f;
      }
      .calendar-nav svg {
        width: 18px;
        height: 18px;
        stroke: currentColor;
        stroke-width: 2.5px;
      }
      /* Calendar Collapse State */
      .calendar-widget.collapsed .calendar-grid#calendar-dates {
        /* Just rely on JS to render fewer items */
      }
      .calendar-expand-btn {
        transform: rotate(0deg);
        transition: transform 0.3s;
      }
      .calendar-expand-btn.collapsed {
        transform: rotate(180deg);
      }
      .calendar-grid {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 0.25rem;
        text-align: center;
      }
      .weekday {
        font-weight: 700;
        font-size: 0.8rem;
        color: var(--secondary-color);
        padding-bottom: 0.5rem;
      }
      .date-cell {
        font-weight: 500;
        padding: 0.4rem 0;
        border-radius: 50%;
        cursor: pointer;
        transition: all 0.2s ease;
        position: relative;
        aspect-ratio: 1/1;
        display: grid;
        place-items: center;
        font-size: 0.9rem;
      }
      .date-cell.other-month {
        color: var(--secondary-color);
        opacity: 0.5;
      }
      .date-cell:not(.other-month):hover {
        background-color: var(--bg-color);
      }
      .date-cell.selected {
        background-color: var(--primary-color);
        color: white;
        font-weight: 700;
        box-shadow: 0 2px 5px rgba(0, 122, 255, 0.3);
      }
      .date-cell.today {
        border: 2px solid var(--danger-color);
      }
      .date-cell.today.selected {
        border-color: transparent;
      }

      /* --- CONTROLS --- */
      .digital-clock-container {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding-right: 1.5rem;
        border-right: 1px solid var(--border-color);
        margin-right: -0.5rem; /* Adjust for the gap in parent */
      }
      .digital-clock-display {
        font-family: "Seven Segment", sans-serif;
        font-size: 2.2rem; /* Adjusted for Seven Segment */
        font-weight: 400; /* Usually doesn't need bold */
        color: var(--danger-color);
        letter-spacing: 0.05em;
        font-variant-numeric: tabular-nums;
        line-height: 1;
        transform: translateY(2px); /* visual adjustment */
      }
      .digital-format-toggle {
        background: none;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        cursor: pointer;
        padding: 2px 4px;
        color: var(--secondary-color);
        font-size: 0.7rem;
        font-weight: 700;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 32px;
      }
      .digital-format-toggle:hover {
        background-color: rgba(0, 0, 0, 0.05);
        color: var(--text-color);
        border-color: var(--secondary-color);
      }
      body.dark-mode .digital-format-toggle:hover {
        background-color: rgba(255, 255, 255, 0.1);
        color: #e5e5e7;
      }

      .controls {
        /* Removed grid positioning */
        background-color: var(--clock-bg);
        padding: 0.75rem 1.5rem;
        border-radius: 99px;
        box-shadow: 0 4px 15px var(--shadow-color);
        border: 1px solid var(--border-color);
      }
      .controls,
      .toggle-group {
        display: flex;
        gap: 1.5rem;
        align-items: center;
      }
      .toggle-group {
        gap: 0;
      }
      .toggle-group label {
        padding: 0.5rem 1rem;
        cursor: pointer;
        border-radius: 99px;
        transition: all 0.3s ease;
        font-weight: 500;
        font-size: 0.9rem;
        white-space: nowrap;
      }
      .toggle-group input[type="radio"] {
        display: none;
      }
      .toggle-group input[type="radio"]:checked + label {
        background-color: var(--primary-color);
        color: white;
        box-shadow: 0 2px 5px rgba(0, 122, 255, 0.3);
      }
      #ampm-controls {
        transition: opacity 0.3s ease, transform 0.3s ease;
      }
      #ampm-controls.hidden {
        opacity: 0;
        transform: scale(0.9);
        pointer-events: none;
      }

      /* Placeholder for editable lists */
      .list-content[placeholder]:empty:before,
      .list-content[placeholder]:focus:empty:before {
        content: attr(placeholder);
        color: #9ca3af;
        font-style: italic;
        cursor: text;
        pointer-events: none;
        display: block;
      }
      .list-content[placeholder] br {
        display: none;
      }
      .list-content[placeholder]:focus br {
        display: initial;
      }

      /* --- CLOCK --- */
      .clock-container {
        /* Removed grid positioning */
        position: relative;
        width: clamp(300px, 90vw, 600px);
        aspect-ratio: 1 / 1;
        background-color: var(--clock-bg);
        border-radius: 50%;
        box-shadow: 0 10px 30px var(--shadow-color), 0 0 0 10px var(--clock-bg);
        border: 1px solid var(--border-color);
        /* FIX #1: Added vendor prefix for Safari compatibility */
        -webkit-user-select: none;
        user-select: none;
      }
      #clock-svg {
        width: 100%;
        height: 100%;
        overflow: visible; /* FIX #7: Allow text to overflow outside rim */
      }
      #click-target {
        cursor: crosshair;
      }
      .clock-tick,
      .clock-tick-small {
        stroke: var(--secondary-color);
      }
      .clock-tick {
        stroke-width: 1.5;
      }
      .clock-tick-small {
        stroke-width: 0.75;
        opacity: 0.7;
      }
      .clock-number {
        fill: var(--text-color);
        font-size: clamp(14px, 3.5vw, 18px);
        font-weight: 500;
        text-anchor: middle;
        dominant-baseline: middle;
        pointer-events: none;
      }
      .clock-tick.past,
      .clock-tick-small.past {
        stroke: #9ca3af; /* Darker gray than before */
        opacity: 0.8;
      }
      .clock-number.past {
        fill: #9ca3af;
        opacity: 0.8;
      }
      .clock-number.current-hour {
        fill: #4b5563; /* Dark gray, distinct from past (#9ca3af) and future (#333) */
        font-weight: 700;
        opacity: 1;
      }
      .clock-number.pm-number {
        fill: #ff5252; /* Subtle Light Red for PM */
        font-weight: 700;
        font-weight: 700;
        opacity: 1;
      }

      /* --- DARK MODE --- */
      body.dark-mode {
        --bg-color: #121212;
        --clock-bg: #1c1c1e;
        --text-color: #e5e5e7;
        --secondary-color: #8e8e93; /* IOS gray */
        --primary-color: #0a84ff; /* Dark mode blue */
        --danger-color: #ff453a; /* Dark mode red */
        --shadow-color: rgba(0, 0, 0, 0.5);
        --border-color: #38383a;
        --completed-color: #3a3a3c;
        --uncompleted-past-color: #2c2c2e; /* Darkened from #48484a per user request */
      }

      body.dark-mode .day-block {
        background-color: #2c2c2e;
        border-color: #38383a;
      }
      body.dark-mode .day-block-grid {
        background-image: repeating-linear-gradient(
          to right,
          #38383a,
          #38383a 1px,
          transparent 1px,
          transparent calc(100% / 24)
        );
      }
      body.dark-mode .clock-tick.past,
      body.dark-mode .clock-tick-small.past {
        stroke: #636366;
      }
      body.dark-mode .clock-number.past {
        fill: #636366;
      }
      body.dark-mode .clock-number.current-hour {
        fill: #e5e5e7;
      }
      body.dark-mode .subtask-card {
        background-color: #2c2c2e;
      }
      body.dark-mode .subtask-card.completed {
        background-color: #1c1c1e;
        opacity: 0.6;
      }
      body.dark-mode .subtask-timer-display {
        background-color: #3a3a3c;
        color: #e5e5e7;
      }

      /* Refine Clock Rim in Dark Mode */
      /* Refine Clock Rim in Dark Mode - Restore depth without the "gray ugly" look */
      body.dark-mode .clock-container {
        border-radius: 50%;
        /* 
           Simulate the light mode structure but with dark colors:
           1. Drop shadow: black (for depth against background)
           2. Solid ring spread: slightly lighter/different dark gray (to define the rim like light mode)
           Light mode uses: 0 10px 30px var(--shadow-color), 0 0 0 10px var(--clock-bg)
           Dark mode fix: 
           - Shadow: black/dark opacity
           - Ring: matches the clock background or slightly distinct to create the "outline"
        */
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.6),
          /* Deeper black drop shadow */ 0 0 0 10px #252527; /* A solid ring slightly lighter than #1c1c1e for subtle outline */

        border: 1px solid #3a3a3c; /* crisper border than before */
        background-color: #1c1c1e; /* Ensure implicit bg is set */
      }

      /* Refine 12h mode colored outer segments: Restore them as subtle outlines */
      body.dark-mode .time-of-day-arc {
        display: block; /* Restore display */
        fill: transparent !important; /* Remove the "ugly" solid fill */
        stroke: #3a3a3c; /* subtle dark gray outline */
        stroke-width: 1px;
      }

      body.dark-mode .notes-tab:hover {
        background-color: rgba(255, 255, 255, 0.1);
      }
      body.dark-mode .notes-tab.active {
        background-color: #2c2c2e;
        color: var(--primary-color);
      }

      /* DARK MODE REFINEMENTS */

      /* Modals */
      body.dark-mode .modal,
      body.dark-mode .modal-overlay {
        background-color: rgba(0, 0, 0, 0.75); /* Darker overlay */
      }
      body.dark-mode .modal {
        background-color: #1c1c1e;
        border: 1px solid #38383a;
      }
      body.dark-mode .modal input[type="text"],
      body.dark-mode .modal input[type="time"] {
        background-color: #2c2c2e;
        border-color: #38383a;
        color: #e5e5e7;
      }
      body.dark-mode .modal input[type="text"]:focus,
      body.dark-mode .modal input[type="time"]:focus {
        background-color: #3a3a3c;
        border-color: var(--primary-color);
      }
      body.dark-mode .form-group label {
        color: #a0a0a0;
      }
      body.dark-mode #cancel-task-btn {
        background-color: #2c2c2e !important;
        color: #e5e5e7 !important;
        border: 1px solid #38383a;
      }
      body.dark-mode #cancel-task-btn:hover {
        background-color: #3a3a3c !important;
      }

      /* Widgets Generic */
      body.dark-mode .calendar-widget,
      body.dark-mode .progress-widget,
      body.dark-mode .notes-widget,
      body.dark-mode .habit-widget,
      body.dark-mode .pomodoro-widget,
      body.dark-mode .events-widget {
        background-color: #1c1c1e; /* Card background */
        border-color: #38383a;
        color: #e5e5e7;
      }
      body.dark-mode .notes-widget-header,
      body.dark-mode .habit-widget-header,
      body.dark-mode .pomodoro-widget-header,
      body.dark-mode .events-widget-header {
        background-color: rgba(
          28,
          28,
          30,
          0.8
        ); /* Match card bg with transparency */
        border-bottom-color: #38383a;
      }
      body.dark-mode .notes-widget-tabs {
        background-color: rgba(255, 255, 255, 0.1);
      }

      /* Notes Widget Specifics */
      body.dark-mode .note-editor {
        color: #e5e5e7;
      }
      body.dark-mode .note-editor p:empty::before,
      body.dark-mode .list-content[placeholder]:empty:before {
        color: rgba(255, 255, 255, 0.25);
      }
      body.dark-mode .note-editor .todo-item.checked .list-content {
        color: rgba(255, 255, 255, 0.5);
      }
      body.dark-mode .note-section.is-today {
        background-color: rgba(10, 132, 255, 0.1); /* Subtle blue in dark */
      }
      body.dark-mode .notes-widget-title,
      body.dark-mode .habit-widget-title,
      body.dark-mode .pomodoro-widget-title,
      body.dark-mode .events-widget-title {
        color: #e5e5e7;
      }
      body.dark-mode .notes-content-container::-webkit-scrollbar-thumb {
        background-color: #38383a;
      }
      body.dark-mode .notes-content-container::-webkit-scrollbar-thumb:hover {
        background-color: #555;
      }
      body.dark-mode .brain-dump-input {
        color: #e5e5e7;
      }
      body.dark-mode .brain-dump-checkbox {
        background-color: #2c2c2e;
        border-color: #555;
      }
      body.dark-mode .brain-dump-checkbox:hover {
        border-color: var(--primary-color);
      }

      /* Icons & Buttons */
      body.dark-mode .add-element-btn,
      body.dark-mode .task-list-close-btn,
      body.dark-mode .habit-btn-mini,
      body.dark-mode .delete-event-btn,
      body.dark-mode .edit-event-btn {
        color: #8e8e93;
      }
      body.dark-mode .add-element-btn:hover,
      body.dark-mode .task-list-close-btn:hover,
      body.dark-mode .habit-btn-mini:hover,
      body.dark-mode .delete-event-btn:hover,
      body.dark-mode .edit-event-btn:hover {
        background-color: rgba(255, 255, 255, 0.1);
        color: #e5e5e7;
      }

      /* Habits */
      body.dark-mode .habit-day {
        background-color: rgba(255, 255, 255, 0.08);
        color: #aaa;
      }
      body.dark-mode .habit-day.future {
        background-color: transparent;
        border-color: #38383a;
        color: #555;
      }
      body.dark-mode .habit-day.today {
        background-color: rgba(10, 132, 255, 0.15);
      }
      body.dark-mode .habit-day.active {
        color: #121212 !important; /* contrast text for green/colored bg */
      }

      /* Pomodoro & Events */
      body.dark-mode .custom-time-input input {
        background-color: #2c2c2e;
        border-color: #38383a;
        color: #e5e5e7;
      }
      body.dark-mode .custom-time-input input:focus {
        background-color: #3a3a3c;
      }
      body.dark-mode .preset-chip {
        background-color: #2c2c2e;
        border-color: #38383a;
        color: #aaa;
      }
      body.dark-mode .preset-chip:hover {
        background-color: #3a3a3c;
        color: #fff;
      }
      body.dark-mode .timer-display {
        color: #e5e5e7;
      }
      body.dark-mode .timer-btn-secondary {
        background-color: #2c2c2e;
        color: #e5e5e7;
      }
      body.dark-mode .timer-btn-secondary:hover {
        background-color: #3a3a3c;
      }
      body.dark-mode .event-item {
        background-color: #2c2c2e;
        border-color: #38383a;
      }
      body.dark-mode .event-date-badge {
        background-color: rgba(255, 255, 255, 0.05);
      }
      body.dark-mode .event-date-day,
      body.dark-mode .event-title {
        color: #e5e5e7;
      }
      body.dark-mode .add-event-section,
      body.dark-mode .subtasks-section,
      body.dark-mode .task-list-header {
        background-color: rgba(0, 0, 0, 0.2) !important; /* Subtle contrast */
        border-color: #38383a;
      }
      body.dark-mode .add-event-input {
        background-color: #2c2c2e;
        border-color: #38383a;
        color: #e5e5e7;
      }
      body.dark-mode .add-event-input:focus {
        background-color: #3a3a3c;
      }

      /* Calendar override */
      body.dark-mode .calendar-arrows {
        background-color: #2c2c2e;
      }
      body.dark-mode .calendar-nav button:hover {
        background-color: #3a3a3c;
        color: white;
      }
      body.dark-mode .date-cell:not(.other-month):hover {
        background-color: #3a3a3c;
      }
      body.dark-mode .date-cell.other-month {
        opacity: 0.3;
      }
      body.dark-mode .calendar-header {
        color: #ff453a; /* Ensure danger color is readable, updated variable usually handles it but explicit check good */
      }

      /* Progress */
      body.dark-mode .progress-widget-task-name {
        color: #e5e5e7;
      }
      body.dark-mode .progress-widget-task-time {
        color: #8e8e93;
      }
      body.dark-mode .progress-widget-counter {
        background-color: #2c2c2e;
        color: #aaa;
      }
      body.dark-mode .task-list-card:hover {
        background-color: #2c2c2e;
      }
      body.dark-mode .task-list-card-name {
        color: #e5e5e7;
      }
      body.dark-mode .task-list-card-time {
        color: #8e8e93;
      }
      body.dark-mode .task-list-empty {
        color: #555;
      }
      body.dark-mode .task-list-card-status {
        border-color: #555;
      }

      body.dark-mode .habit-name {
        color: #e5e5e7;
      }
      body.dark-mode .progress-widget-header h3 {
        /* Assuming h3 or class within structure */
        color: #e5e5e7;
      }
      /* Specific targeting for "Today's Schedule" often in h2/h3 or class */
      body.dark-mode .progress-widget-header {
        color: #e5e5e7;
      }

      /* Habit Item Name specific override just in case */
      body.dark-mode .habit-item-name {
        color: #e5e5e7;
      }

      body.dark-mode .habit-item-name {
        color: #e5e5e7;
      }

      /* User Requested: Lighten specific elements */
      body.dark-mode .subtask-name {
        color: #e5e5e7;
        font-weight: 500;
      }
      body.dark-mode .task-list-header {
        color: #e5e5e7;
        /* Ensure the text specifically is white, overriding any gray inheritances */
      }
      body.dark-mode .task-list-header h3 {
        color: #e5e5e7;
      }

      body.dark-mode .task-list-header h3 {
        color: #e5e5e7;
      }

      /* Fix for Subtask Edit Input Visibility */
      /* The subtask name is a contenteditable span, not a standard input. */
      body.dark-mode .subtask-name {
        color: #e5e5e7 !important;
        caret-color: #e5e5e7; /* Cursor color */
      }
      body.dark-mode .subtask-name:focus {
        background-color: rgba(
          255,
          255,
          255,
          0.05
        ) !important; /* Subtle highlight */
        color: #e5e5e7 !important;
        outline: none;
        box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.5); /* Focus ring */
        border-radius: 4px;
      }

      /* Also fix the time input next to it */
      body.dark-mode .subtask-time-input {
        background-color: #2c2c2e !important;
        color: #e5e5e7 !important;
        border: 1px solid #38383a;
      }
      body.dark-mode .subtask-time-input:focus {
        border-color: var(--primary-color);
      }

      body.dark-mode .subtask-time-input:focus {
        border-color: var(--primary-color);
      }

      /* Fix for Pomodoro Collapsed Text */
      body.dark-mode .pomodoro-collapsed-time-text {
        color: #e5e5e7;
      }

      /* Fix for Progress Bar Percentage Text */
      body.dark-mode .progress-bar-percentage {
        color: #ffffff;
        font-weight: 600;
        text-shadow: 0 0 2px #000000; /* Subtle black stroke effect */
      }

      /* Hover states for main toggles */
      #dark-mode-toggle:hover {
        background-color: rgba(0, 0, 0, 0.05);
        color: var(--text-color) !important;
      }
      body.dark-mode #dark-mode-toggle:hover {
        background-color: rgba(255, 255, 255, 0.1);
      }

      /* Controls bg override */
      body.dark-mode .controls {
        background-color: #1c1c1e;
        border-color: #38383a;
      }
      body.dark-mode .toggle-group label:hover {
        background-color: rgba(255, 255, 255, 0.05);
      }

      #format-toggle-group {
        cursor: pointer;
        transition: opacity 0.2s;
      }
      #format-toggle-group:hover {
        opacity: 0.8;
      }
      .format-toggle-bg {
        fill: transparent;
      }
      .format-toggle-text {
        font-size: 10px;
        font-weight: 700;
        fill: var(--secondary-color);
        text-anchor: middle;
        dominant-baseline: middle;
        opacity: 0.5;
        transition: opacity 0.2s, fill 0.2s;
      }
      #format-toggle-group:hover .format-toggle-text {
        opacity: 1;
        fill: var(--primary-color);
      }
      .task-pie-slice {
        stroke: rgba(0, 0, 0, 0.1);
        stroke-width: 1px;
        cursor: pointer;
        transition: filter 0.2s, fill 0.2s;
      }
      .task-pie-slice:hover {
        filter: brightness(1.1);
      }
      .task-label-group {
        cursor: pointer;
      }
      .task-label {
        font-size: clamp(10px, 2.2vw, 13px);
        font-weight: 700;
        dominant-baseline: middle;
        paint-order: stroke;
      }
      .task-checkbox rect {
        fill: rgba(255, 255, 255, 0.7);
        stroke: var(--secondary-color);
        stroke-width: 1.5;
        transition: opacity 0.2s;
        /* FIX #3: Removed rx and ry; they are set as attributes by JS for better compatibility */
      }
      .task-checkbox path {
        stroke: var(--primary-color);
        stroke-width: 3;
        fill: none;
        stroke-linecap: round;
        stroke-linejoin: round;
      }
      .task-label-group .task-checkbox {
        opacity: 0;
      }
      .task-label-group:hover .task-checkbox {
        opacity: 1;
      }
      .preview-arc {
        fill: var(--primary-color);
        fill-opacity: 0.25;
        pointer-events: none;
      }
      .clock-center {
        fill: var(--text-color);
      }
      #hands-container {
        pointer-events: none;
      }
      #hands-container.faded line {
        stroke: var(--uncompleted-past-color) !important;
      }
      #hands-container.faded #second-hand {
        stroke: #ff9a96 !important;
      }
      #hands-container line {
        stroke-linecap: round;
        transform-origin: 200px 200px;
        transition: transform 0.5s cubic-bezier(0.4, 2.3, 0.6, 1);
      }
      #second-hand.no-transition {
        transition: none !important;
      }
      #hour-hand {
        stroke: var(--text-color);
        stroke-width: 6;
      }
      #minute-hand {
        stroke: var(--text-color);
        stroke-width: 4;
      }
      #second-hand {
        stroke: var(--danger-color);
        stroke-width: 2;
      }

      /* --- MODAL --- */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.4);
        display: grid;
        place-items: center;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
        z-index: 1000;
      }
      .modal-overlay.visible {
        opacity: 1;
        visibility: visible;
      }
      .modal {
        background-color: var(--clock-bg);
        padding: 2rem;
        border-radius: 16px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        width: clamp(280px, 80vw, 400px);
        transform: scale(0.9);
        transition: transform 0.3s ease;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }
      .modal-overlay.visible .modal {
        transform: scale(1);
      }
      .modal h2 {
        font-size: 1.5rem;
        text-align: center;
      }
      .modal-time {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        font-size: 1.1rem;
        font-weight: 500;
      }
      .modal-time input[type="time"] {
        background-color: var(--bg-color);
        border: 1px solid var(--border-color);
        padding: 0.5rem;
        border-radius: 8px;
        font-family: "Inter", sans-serif;
        font-size: 1rem;
      }
      .form-group {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .form-group label {
        font-weight: 500;
        color: var(--secondary-color);
      }
      .form-group input[type="text"] {
        padding: 0.75rem;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        font-size: 1rem;
      }
      .form-group input[type="text"]:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.2);
      }
      .form-group.checkbox-group {
        flex-direction: row;
        align-items: center;
        gap: 0.75rem;
        /* FIX #1: Added vendor prefix for Safari compatibility */
        -webkit-user-select: none;
        user-select: none;
      }
      .form-group.checkbox-group input {
        width: 18px;
        height: 18px;
      }
      .color-selector {
        display: flex;
        justify-content: space-between;
        gap: 0.5rem;
      }
      .color-option {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        border: 3px solid transparent;
      }
      .color-option:hover {
        transform: scale(1.1);
      }
      .color-option.selected {
        border-color: var(--clock-bg);
        box-shadow: 0 0 0 2px var(--primary-color);
      }
      .modal-actions {
        display: flex;
        gap: 1rem;
        margin-top: 1rem;
      }
      .modal-actions button {
        flex-grow: 1;
        padding: 0.75rem;
        border: none;
        border-radius: 8px;
        font-size: 1rem;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      #save-task-btn {
        background-color: var(--primary-color);
        color: white;
      }
      #save-task-btn:hover {
        background-color: #0056b3;
      }
      #cancel-task-btn {
        background-color: var(--border-color);
        color: var(--text-color);
      }
      #cancel-task-btn:hover {
        background-color: #d1d1d6;
      }
      #delete-task-btn {
        background-color: var(--danger-color);
        color: white;
        flex-grow: 0;
        padding: 0.75rem 1rem;
      }
      #delete-task-btn.hidden {
        display: none;
      }

      /* --- Time of Day & Drag Styles --- */
      .time-of-day-arc {
        fill-opacity: 0.25;
        stroke: var(--border-color);
        stroke-width: 0.5px;
        transition: opacity 0.3s ease-in-out;
      }
      #time-of-day-container.hidden .time-of-day-arc {
        opacity: 0;
      }
      #time-of-day-container {
        pointer-events: none;
      }
      .time-of-day-icon-group .feather {
        stroke: var(--text-color);
        stroke-width: 1.5;
        opacity: 0.6;
        transition: opacity 0.3s ease-in-out;
      }
      #time-of-day-container.hidden .time-of-day-icon-group {
        opacity: 0;
      }

      /* FIX #4: Moved inline styles to stylesheet */
      #drag-labels-container {
        visibility: hidden;
        font-size: 16px;
        font-weight: 500;
        pointer-events: none;
      }
      #drag-time-label {
        paint-order: stroke;
        stroke: #fff;
        stroke-width: 4px;
        stroke-linejoin: round;
      }

      /* --- BLOCKS VIEW --- */
      .hidden {
        display: none !important;
      }
      .blocks-view-container {
        display: flex;
        flex-direction: column;
        gap: 20px;
        width: 90%;
        max-width: 800px;
        margin: 20px auto;
        position: relative;
        padding-top: 20px;
        padding-bottom: 10px;
      }
      .day-block-wrapper {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .day-block-label {
        font-size: 14px;
        font-weight: 500;
        color: #555;
        padding-left: 5px;
      }
      .day-block {
        position: relative;
        height: 80px;
        background-color: #f0f0f0;
        border-radius: 8px;
        overflow: hidden;
        border: 1px solid #ddd;
      }
      #today-block {
        cursor: crosshair;
        border-color: #bbb;
      }
      #yesterday-block-wrapper,
      #tomorrow-block-wrapper {
        opacity: 0.7;
      }
      .day-block-grid {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-image: repeating-linear-gradient(
          to right,
          #ddd,
          #ddd 1px,
          transparent 1px,
          transparent calc(100% / 24)
        );
        pointer-events: none;
      }
      .day-block-hours {
        position: absolute;
        top: 2px;
        left: 0;
        right: 0;
        pointer-events: none;
      }
      .day-block-hours span {
        position: absolute;
        font-size: 10px;
        color: #888;
        font-family: monospace;
        transform: translateX(3px);
      }
      /* FIX #4: Position hardcoded hour labels via CSS */
      .day-block-hours span:nth-child(1) {
        left: 0%;
      }
      .day-block-hours span:nth-child(2) {
        left: 25%;
      }
      .day-block-hours span:nth-child(3) {
        left: 50%;
      }
      .day-block-hours span:nth-child(4) {
        left: 75%;
      }

      .day-block-tasks {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }
      .task-block {
        position: absolute;
        top: 25%;
        height: 50%;
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        padding: 0 8px;
        color: white;
        font-size: 12px;
        font-weight: 500;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        transition: transform 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
      }
      .task-block:hover {
        transform: translateY(-2px);
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
      }
      .current-time-line {
        position: absolute;
        top: -10px;
        bottom: -10px;
        width: 2px;
        background-color: #ff3b30;
        pointer-events: none;
        z-index: 10;
        display: none;
        box-shadow: 0 0 5px #ff3b30;
      }
      .current-time-line::before {
        content: "";
        position: absolute;
        top: 50%;
        left: -4px;
        width: 10px;
        height: 10px;
        background: #ff3b30;
        border-radius: 50%;
        transform: translateY(-50%);
      }
      .task-preview-block {
        position: absolute;
        top: 0;
        height: 100%;
        background: rgba(0, 122, 255, 0.4);
        border: 1px dashed rgba(0, 122, 255, 0.8);
        pointer-events: none;
        z-index: 5;
        display: none;
      }
      .day-block-hours span.subtle {
        opacity: 0.6;
      }

      /* --- CODE TO ADD: Place this at the end of the <style> tag --- */

      /* --- PROGRESS WIDGET --- */
      .progress-widget {
        position: fixed;
        bottom: 1.5rem;
        left: 1.5rem;
        width: clamp(400px, 20vw, 420px);
        background-color: var(--clock-bg);
        border-radius: 12px;
        padding: 1rem;
        box-shadow: 0 4px 20px var(--shadow-color);
        border: 1px solid var(--border-color);
        z-index: 500;
        /* Initial state for transition */
        opacity: 0;
        transform: translateY(20px);
        transition: opacity 0.4s ease, transform 0.4s ease, visibility 0.4s;
        visibility: hidden;
        user-select: none;
        -webkit-user-select: none;

        transition: max-height 0.4s cubic-bezier(0.25, 0.8, 0.25, 1),
          box-shadow 0.3s ease;

        max-height: 40vh;
        overflow-y: scroll;
        scrollbar-width: none;
        scroll-behavior: smooth;
      }

      .progress-widget:not(.hidden) {
        opacity: 1;
        transform: translateY(0);
        visibility: visible;
      }
      .progress-widget-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5rem;
      }
      .progress-widget-counter {
        font-size: 0.8rem;
        font-weight: 700;
        color: var(--secondary-color);
        background-color: var(--bg-color);
        padding: 0.2rem 0.5rem;
        border-radius: 6px;
      }
      .progress-widget-complete {
        background: none;
        border: none;
        cursor: pointer;
        padding: 0.25rem;
        border-radius: 50%;
        width: 28px;
        height: 28px;
        display: grid;
        place-items: center;
        transition: background-color 0.2s;
      }
      .progress-widget-complete:hover {
        background-color: var(--bg-color);
      }
      .progress-widget-complete svg {
        width: 18px;
        height: 18px;
        stroke: var(--secondary-color);
        transition: stroke 0.2s;
      }
      .progress-widget-complete:hover svg {
        stroke: var(--primary-color);
      }
      .progress-widget-task-name {
        font-weight: 500;
        font-size: 1rem;
        margin-bottom: 0.75rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .progress-bar-container {
        height: 18px;
        width: 100%;
        border-radius: 99px;
        overflow: hidden;
        position: relative;
        display: flex;
        align-items: center;
        /* The background color will be set by JS to the task's color */
        transition: background-color 0.5s ease;
        border: 1px solid var(--border-color);
      }
      .progress-bar-elapsed {
        height: 100%;
        background-color: var(--uncompleted-past-color);
        /* Ensures the left radius is visible even at low percentages */
        min-width: 12px;
        border-radius: 99px;
        /* Use a linear transition for smooth progress updates */
        transition: width 1s linear;
      }
      .progress-bar-percentage {
        position: absolute;
        left: 10px;
        color: black;
        font-size: 0.79rem;
        font-weight: 800;
        pointer-events: none;
      }

      /* --- Add this to your CSS --- */

      .progress-widget-task-time {
        font-size: 0.8rem; /* Make it smaller than the main task name */
        color: #6c757d; /* A muted, secondary text color */
        margin: 2px 0 10px; /* Fine-tune the spacing: less on top, more on bottom */
        font-weight: 500; /* Medium weight for readability at a small size */
        text-align: left; /* Ensure it's centered like the other elements */
        opacity: 0.9; /* A touch of subtlety */
        transition: opacity 0.3s ease; /* A smooth transition when it appears */
      }

      /* Optional but recommended: A slightly tighter margin for the task name above it */
      .progress-widget-task-name {
        margin-bottom: 2px;
      }

      /* ======================================================== */
      /* ==  REFINED Task List View Feature Styles (Integrated) == */
      /* ======================================================== */

      /* --- Main Widget Container Styling --- */

      /* --- Expanded State Styling --- */
      .progress-widget.expanded-view {
        /* As requested: fixed height for the expanded list, allowing scrolling */
        max-height: 300px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
        overflow-y: scroll;
        overflow-x: hidden;
        scrollbar-width: none;
        scroll-behavior: smooth;
      }

      /* --- Child View Containers --- */
      .progress-widget-main-view,
      .task-list-view {
        /* Smoothly fade content in and out during transformation */
        transition: opacity 0.3s ease;
      }

      .progress-widget.expanded-view .progress-widget-main-view {
        opacity: 0;
        pointer-events: none;
        height: 0; /* Collapse the element so it takes no space */
      }

      .task-list-view {
        opacity: 0;
        pointer-events: none;
        height: 0;
        display: flex;
        flex-direction: column;
      }

      .progress-widget.expanded-view .task-list-view {
        opacity: 1;
        pointer-events: auto;
        height: 100%;
        max-height: 400px; /* Must match the container's max-height */
      }

      /* --- Task List Header & Close Button --- */
      .task-list-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 14px;
        font-weight: 600;
        color: #333;
        padding: 12px 16px;
        border-bottom: 1px solid #e5e5e5;
        flex-shrink: 0;
      }
      .task-list-close-btn {
        background: none;
        border: none;
        padding: 4px;
        cursor: pointer;
        color: #8e8e93;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: background-color 0.2s, color 0.2s;
      }
      .task-list-close-btn:hover {
        background-color: #f0f0f0;
        color: #333;
      }
      .task-list-close-btn svg {
        width: 18px;
        height: 18px;
      }

      /* --- Cards Container (Identical to before, but scoped within widget) --- */
      .task-list-cards {
        padding: 8px;
        overflow-y: auto;
        flex-grow: 1;
      }
      .task-list-cards::-webkit-scrollbar {
        width: 6px;
      }

      /* --- TOPIC NOTES FILTER CHIPS --- */
      .topic-filter-container {
        display: flex;
        gap: 0.5rem;
        overflow-x: auto;
        padding: 0 1rem 0.5rem 1rem; /* Match horizontal padding of topic-list-view */
        margin-bottom: 0px; /* tighten up space between filter and list */
        margin-top: 0.5rem; /* Add some top spacing from tabs */
        -webkit-overflow-scrolling: touch;
      }
      .topic-filter-container::-webkit-scrollbar {
        height: 0; /* Hide scrollbar for cleaner look */
        width: 0;
      }
      .filter-chip {
        flex: 0 0 auto;
        padding: 0.35rem 0.85rem;
        border-radius: 99px;
        font-size: 0.8rem;
        font-weight: 500;
        cursor: pointer;
        background-color: var(--card-bg); /* Use card bg for unselected */
        color: var(--secondary-color);
        border: 1px solid var(--border-color);
        transition: all 0.2s;
        user-select: none;
      }
      .filter-chip:hover {
        background-color: var(--border-color);
        color: var(--text-color);
      }
      .filter-chip.active {
        background-color: var(--primary-color);
        color: white;
        border-color: var(--primary-color);
      }
      body.dark-mode .filter-chip {
        background-color: #2c2c2e;
        color: #a0a0a0;
        border-color: #3a3a3c;
      }
      body.dark-mode .filter-chip:hover {
        background-color: #3a3a3c;
        color: #e5e5e7;
      }
      body.dark-mode .filter-chip.active {
        background-color: var(--primary-color);
        color: #ffffff;
        border-color: var(--primary-color);
      }

      .task-list-cards::-webkit-scrollbar-track {
        background: transparent;
      }
      .task-list-cards::-webkit-scrollbar-thumb {
        background-color: #ccc;
        border-radius: 10px;
      }

      /* --- Individual Task Card Styling (Identical to before) --- */
      .task-list-card {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 8px;
        border-radius: 8px;
        transition: background-color 0.2s ease;
        cursor: pointer;
      }
      .task-list-card:hover {
        background-color: #f5f5f7;
      }
      .task-list-card-info {
        display: flex;
        flex-direction: column;
        gap: 2px;
        flex-grow: 1;
        min-width: 0;
      }
      .task-list-card-name {
        font-size: 15px;
        font-weight: 500;
        color: #1d1d1f;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        display: flex;
        align-items: center;
      }
      .task-list-card-name::before {
        content: "";
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background-color: var(--task-color, #8e8e93);
        margin-right: 10px;
        flex-shrink: 0;
      }
      .task-list-card-time {
        font-size: 12px;
        color: #8e8e93;
        padding-left: 18px;
      }
      .task-list-card-status {
        width: 20px;
        height: 20px;
        flex-shrink: 0;
        margin-left: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid #e0e0e0;
        border-radius: 50%;
        transition: all 0.2s ease;
      }
      .task-list-card-status.completed {
        background-color: #34c759;
        border-color: #34c759;
      }
      .task-list-card-status.completed svg {
        stroke: #ffffff;
        stroke-width: 3;
      }
      .task-list-card-status svg {
        width: 12px;
        height: 12px;
        fill: none;
      }
      .task-list-empty {
        text-align: center;
        padding: 40px 20px;
        color: #8e8e93;
        font-size: 14px;
      }

      /* --- Subtask Feature Styling --- */
      .subtasks-section {
        padding: 8px 16px 12px;
        border-top: 1px solid #e5e5e5;
        margin-top: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .subtask-card {
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 10px;
        margin: 7px auto;
        background-color: #f5f5f7;
        border-radius: 8px;
        transition: all 0.3s ease;
      }

      .subtask-card.completed {
        background-color: #e9f9ec;
        opacity: 0.7;
      }

      .subtask-card.completed .subtask-name {
        text-decoration: line-through;
        color: #8e8e93;
      }

      .subtask-main {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .subtask-checkbox {
        flex-shrink: 0;
        width: 20px;
        height: 20px;
        border: 2px solid #c7c7cc;
        border-radius: 50%;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .subtask-card.completed .subtask-checkbox {
        background-color: #34c759;
        border-color: #34c759;
      }

      .subtask-checkbox svg {
        width: 12px;
        height: 12px;
        stroke: #ffffff;
        stroke-width: 3;
        opacity: 0;
        transform: scale(0.5);
        transition: all 0.2s ease;
      }

      .subtask-card.completed .subtask-checkbox svg {
        opacity: 1;
        transform: scale(1);
      }

      .subtask-name {
        flex-grow: 1;
        font-size: 15px;
        font-weight: 500;
        color: #1d1d1f;
        outline: none;
        border: 1px solid transparent;
        padding: 2px 4px;
        border-radius: 4px;
        transition: border-color 0.2s;
      }
      .subtask-name:focus {
        border-color: #007aff;
        background-color: #fff;
        box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2);
      }

      .subtask-time-controls {
        display: flex;
        align-items: center;
        gap: 6px;
        flex-shrink: 0;
      }

      .subtask-time-input {
        width: 45px;
        padding: 4px 6px;
        border-radius: 5px;
        border: 1px solid #e0e0e0;
        text-align: center;
        font-size: 14px;
        -moz-appearance: textfield; /* Firefox */
      }
      .subtask-time-input::-webkit-outer-spin-button,
      .subtask-time-input::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }

      .subtask-time-btn {
        background: none;
        border: none;
        padding: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #8e8e93;
        transition: color 0.2s ease, transform 0.2s ease;
      }
      .subtask-time-btn:hover {
        color: #007aff;
        transform: scale(1.1);
      }
      .subtask-time-btn svg {
        width: 20px;
        height: 20px;
      }

      .subtask-timer-display {
        font-size: 13px;
        font-weight: 500;
        color: #333;
        background-color: #e9e9eb;
        padding: 4px 8px;
        border-radius: 5px;
        white-space: nowrap;
      }
      .subtask-timer-display.overtime {
        color: #ff3b30;
        background-color: #ffebee;
      }

      .subtask-progress-container {
        height: 6px;
        background-color: rgba(120, 120, 128, 0.16);
        border-radius: 3px;
        overflow: hidden;
        position: relative;
      }

      .subtask-progress-bar {
        height: 100%;
        width: 0%;
        border-radius: 3px;
        transition: width 0.5s linear;
      }
      .subtask-progress-bar.overtime {
        background-color: #ff3b30 !important;
      }

      .add-subtask-btn {
        width: 100%;
        padding: 10px;
        background-color: rgba(0, 122, 255, 0.08);
        border: 1px dashed #007aff;
        color: #007aff;
        font-weight: 600;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        font-size: 14px;
      }
      .add-subtask-btn:hover {
        background-color: rgba(0, 122, 255, 0.15);
        border-style: solid;
      }
      .add-subtask-btn svg {
        width: 18px;
        height: 18px;
      }

      .subtask-limit-notice {
        text-align: center;
        padding: 10px;
        font-size: 13px;
        color: #8e8e93;
        background-color: #f5f5f7;
        border-radius: 8px;
      }
      .subtask-delete-btn {
        background: none;
        border: none;
        padding: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #c7c7cc; /* A muted default color */
        transition: color 0.2s ease, transform 0.2s ease;
        margin-left: 4px;
      }
      .subtask-delete-btn:hover {
        color: #ff3b30; /* Danger color on hover */
        transform: scale(1.1);
      }
      .subtask-delete-btn svg {
        width: 18px;
        height: 18px;
      }
      /* Add a pointer cursor to the timer display to indicate it's clickable */
      .subtask-timer-display {
        cursor: pointer;
      }

      /* CODE TO REPLACE: Replace your entire "NOTES WIDGET STYLES" section with this block */

      /* ================================== */
      /* ==      NOTES WIDGET STYLES     == */
      /* ================================== */

      .notes-widget {
        position: fixed;
        bottom: 1.5rem;
        right: 1.5rem;
        width: clamp(340px, 25vw, 480px);
        height: 60vh;
        min-height: 400px;
        background-color: var(--clock-bg);
        border-radius: 12px; /* Slightly tighter radius */
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.12);
        border: 1px solid var(--border-color);
        z-index: 500;
        display: flex;
        flex-direction: column;
        opacity: 0;
        transform: translateY(20px);
        animation: fadeInWidget 0.4s 0.2s cubic-bezier(0.25, 1, 0.5, 1) forwards;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica,
          "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji",
          "Segoe UI Symbol"; /* Notion-like font stack */
      }

      @keyframes fadeInWidget {
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .notes-widget-header {
        padding: 0.75rem 1rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-bottom: 1px solid rgba(0, 0, 0, 0.05); /* Subtle divider */
        flex-shrink: 0;
        height: 50px;
      }

      /* Category Dropdown Styles */
      .category-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        width: 100%;
        max-height: 200px;
        overflow-y: auto;
        background-color: var(--clock-bg); /* Use theme bg */
        border: 1px solid var(--border-color);
        border-radius: 8px;
        box-shadow: 0 4px 12px var(--shadow-color);
        z-index: 1000;
        display: none; /* Hidden by default */
        flex-direction: column;
        margin-top: 4px;
      }
      .category-dropdown.visible {
        display: flex;
      }
      .category-dropdown-item {
        padding: 8px 12px;
        cursor: pointer;
        font-size: 0.9rem;
        color: var(--text-color);
        transition: background-color 0.2s;
        border-bottom: 1px solid var(--border-color); /* Separator */
      }
      .category-dropdown-item:last-child {
        border-bottom: none;
      }
      .category-dropdown-item:hover,
      .category-dropdown-item.selected-nav {
        background-color: var(--hover-color);
      }
      .category-dropdown-item .match-highlight {
        font-weight: 700;
        color: var(--primary-color);
      }

      /* Global Styles End */
      /* Tabs Styling */
      .notes-widget-tabs {
        display: flex;
        gap: 0.25rem;
        background-color: rgba(0, 0, 0, 0.04);
        padding: 3px;
        border-radius: 8px;
        margin-right: auto; /* Push utilities to right (fails if parent justify-between is set, so we might need to adjust parent or force margin) */
      }
      /* Since parent .notes-widget-header has justify-content: space-between, 
         we need to remove the .notes-widget-title style or ensure tabs replace it effectively. 
         With my HTML change, I replaced .notes-widget-title with .notes-widget-tabs? 
         Wait, my HTML change replaced the entire .notes-widget-title block with .notes-widget-tabs 
         BUT I also kept the Notes title in the HTML if I look closely?
         Checking HTML replacement... 
         Original had .notes-widget-title.
         My replacement changed it to .notes-widget-header containing .notes-widget-tabs AND the buttons div.
         So flex space-between works: Tabs on left, Buttons on right.
      */

      .notes-tab {
        padding: 4px 10px;
        border-radius: 6px;
        font-size: 0.85rem;
        font-weight: 600;
        color: var(--secondary-color);
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 6px;
        opacity: 0.7;
        user-select: none;
      }
      .notes-tab:hover {
        background-color: rgba(0, 0, 0, 0.05);
        opacity: 1;
      }
      .notes-tab.active {
        background-color: white;
        color: var(--primary-color);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
        opacity: 1;
      }
      .notes-tab svg {
        width: 14px;
        height: 14px;
        stroke-width: 2.5;
      }

      /* Topic Notes Styles */
      /* Topic Notes Styles */
      #topic-list-view {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        align-content: start; /* Pack items at start */
        gap: 12px; /* Increased gap for grid */
        padding: 1rem;
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: rgba(0, 0, 0, 0.2) transparent;
      }

      #topic-detail-view {
        flex-direction: column;
        padding: 1rem 1.5rem; /* Added horizontal padding for "beautiful margins" */
        overflow-y: auto;
        height: 100%;
        gap: 1rem;
        scrollbar-width: thin;
        scrollbar-color: rgba(0, 0, 0, 0.2) transparent;
      }

      /* Custom Scrollbar for Topics */
      #topic-list-view::-webkit-scrollbar,
      #topic-detail-view::-webkit-scrollbar {
        width: 6px;
      }
      #topic-list-view::-webkit-scrollbar-track,
      #topic-detail-view::-webkit-scrollbar-track {
        background: transparent;
      }
      #topic-list-view::-webkit-scrollbar-thumb,
      #topic-detail-view::-webkit-scrollbar-thumb {
        background-color: rgba(0, 0, 0, 0.2);
        border-radius: 3px;
      }
      #topic-list-view::-webkit-scrollbar-thumb:hover,
      #topic-detail-view::-webkit-scrollbar-thumb:hover {
        background-color: rgba(0, 0, 0, 0.3);
      }

      /* Dark Mode Scrollbar Overrides (matched from Lines 522) */
      body.dark-mode #topic-list-view,
      body.dark-mode #topic-detail-view {
        scrollbar-color: #38383a transparent;
      }
      body.dark-mode #topic-list-view::-webkit-scrollbar-thumb,
      body.dark-mode #topic-detail-view::-webkit-scrollbar-thumb {
        background-color: #38383a;
      }
      body.dark-mode #topic-list-view::-webkit-scrollbar-thumb:hover,
      body.dark-mode #topic-detail-view::-webkit-scrollbar-thumb:hover {
        background-color: #555;
      }

      .topic-card {
        background: rgba(255, 255, 255, 0.6);
        border-radius: 8px;
        padding: 12px;
        cursor: pointer;
        transition: all 0.2s ease;
        border: 1px solid rgba(0, 0, 0, 0.05);
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .topic-card:hover {
        background: white;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
      }

      .topic-card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .topic-card-title {
        font-weight: 600;
        font-size: 0.95rem;
        color: var(--text-color);
        display: -webkit-box;
        -webkit-line-clamp: 3;
        -webkit-box-orient: vertical;
        overflow: hidden;
        word-break: break-word;
      }

      .topic-card-category {
        font-size: 0.7rem;
        padding: 2px 8px;
        border-radius: 12px;
        background-color: rgba(0, 0, 0, 0.05);
        color: var(--secondary-color);
        font-weight: 500;
      }

      .topic-card-preview {
        font-size: 0.8rem;
        color: var(--secondary-color);
        opacity: 0.8;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      /* Dark Mode Overrides for Topics */
      body.dark-mode .topic-card {
        background: rgba(255, 255, 255, 0.05);
        border-color: rgba(255, 255, 255, 0.05);
      }
      body.dark-mode .topic-card:hover {
        background: rgba(255, 255, 255, 0.1);
      }

      /* Brain Dump Tasks Styling */
      /* --- TASK TABS --- */
      .task-tabs-row {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 0 4px;
        margin-bottom: 8px; /* Separator from list */
        border-bottom: 1px solid var(--border-color);
        background-color: transparent;
      }

      .task-tabs-list {
        display: flex;
        gap: 4px;
        overflow-x: auto;
        flex: 1;
        /* Hide scrollbar */
        scrollbar-width: none;
        -ms-overflow-style: none;
        padding-bottom: 4px;
      }
      .task-tabs-list::-webkit-scrollbar {
        display: none;
      }

      .task-tab {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 4px 10px;
        background-color: rgba(0, 0, 0, 0.05);
        border-radius: 6px 6px 0 0;
        font-size: 0.85rem;
        color: var(--secondary-color);
        cursor: pointer;
        white-space: nowrap;
        border: 1px solid transparent;
        border-bottom: none;
        transition: all 0.2s;
        max-width: 150px;
      }
      .task-tab:hover {
        background-color: rgba(0, 0, 0, 0.1);
        color: var(--text-color);
      }
      .task-tab.active {
        background-color: var(--clock-bg); /* Match container bg */
        color: var(--primary-color);
        font-weight: 500;
        border-color: var(--border-color);
        box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.02);
        margin-bottom: -1px; /* Blend with border-bottom of row */
        padding-bottom: 5px;
        z-index: 1;
      }

      .task-tab-name {
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .task-tab-close-btn {
        font-size: 1rem;
        line-height: 1;
        border-radius: 50%;
        width: 16px;
        height: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.2s, background-color 0.2s;
      }
      .task-tab:hover .task-tab-close-btn {
        opacity: 0.6;
      }
      .task-tab-close-btn:hover {
        opacity: 1;
        background-color: rgba(255, 59, 48, 0.1);
        color: var(--danger-color);
      }

      .add-task-tab-btn {
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
        border: none;
        background: transparent;
        color: var(--secondary-color);
        cursor: pointer;
        font-size: 1.2rem;
        line-height: 1;
        transition: background-color 0.2s;
        margin-left: 4px;
      }
      .add-task-tab-btn:hover {
        background-color: rgba(0, 0, 0, 0.05);
        color: var(--primary-color);
      }

      .task-tab-input {
        background: transparent;
        border: 1px solid var(--primary-color);
        border-radius: 4px;
        font-size: 0.85rem;
        font-family: inherit;
        color: inherit;
        width: 80px;
        padding: 0 4px;
        outline: none;
      }

      /* Dark Mode Overrides */
      body.dark-mode .task-tabs-row {
        border-bottom-color: #38383a;
      }
      body.dark-mode .task-tab {
        background-color: rgba(255, 255, 255, 0.05);
        color: #8e8e93;
      }
      body.dark-mode .task-tab:hover {
        background-color: rgba(255, 255, 255, 0.1);
        color: #e5e5e7;
      }
      body.dark-mode .task-tab.active {
        background-color: #1c1c1e; /* Match card bg */
        color: var(--primary-color);
        border-color: #38383a;
      }
      body.dark-mode .add-task-tab-btn:hover {
        background-color: rgba(255, 255, 255, 0.1);
        color: #e5e5e7;
      }

      #brain-dump-list {
        padding: 1rem 1.5rem; /* Match notes padding roughly */
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .brain-dump-item {
        display: flex;
        align-items: flex-start;
        padding: 2px 0;
        border-radius: 4px;
        transition: background-color 0.1s;
        /* Min height for easy clicking */
        min-height: 28px;
      }
      .brain-dump-item:hover {
        /* Optional hover effect? Maybe too noisy. Keeping cleaner. */
      }
      .brain-dump-checkbox {
        width: 16px;
        height: 16px;
        border: 2px solid #c7c7cc;
        border-radius: 4px;
        margin-top: 4px; /* Align with text */
        margin-right: 12px;
        flex-shrink: 0;
        cursor: pointer;
        display: grid;
        place-items: center;
        transition: all 0.2s;
        background: white;
      }
      .brain-dump-item.spacer .brain-dump-checkbox {
        visibility: hidden; /* Or display: none */
        pointer-events: none;
      }
      .brain-dump-checkbox:hover {
        border-color: var(--primary-color);
      }
      .brain-dump-checkbox.checked {
        background-color: var(--primary-color);
        border-color: var(--primary-color);
      }
      .brain-dump-checkbox svg {
        width: 10px;
        height: 10px;
        color: white;
        display: none;
        stroke-width: 3;
      }
      .brain-dump-checkbox.checked svg {
        display: block;
      }
      .brain-dump-input {
        flex-grow: 1;
        border: none;
        background: transparent;
        font-family: inherit;
        font-size: 0.95rem;
        color: var(--text-color);
        outline: none;
        line-height: 1.5;
        min-height: 1.5em; /* Ensure height even if empty */
        word-break: break-word; /* Wrap long words */
      }
      /* Placeholder for empty new lines */
      .brain-dump-input:empty::before {
        content: attr(placeholder);
        color: rgba(0, 0, 0, 0.3);
        pointer-events: none;
      }
      .brain-dump-input.completed {
        text-decoration: line-through;
        color: var(--secondary-color);
        opacity: 0.8;
      }

      .notes-widget-title {
        font-size: 1rem;
        font-weight: 600;
        color: var(--text-color);
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .notes-widget-title svg {
        width: 18px;
        height: 18px;
        color: var(--secondary-color);
      }

      .add-element-btn {
        background: none;
        border: none;
        cursor: pointer;
        padding: 0.4rem;
        border-radius: 4px;
        color: var(--secondary-color);
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .add-element-btn:hover {
        background-color: rgba(0, 0, 0, 0.05);
        color: var(--text-color);
      }
      .add-element-btn svg {
        width: 20px;
        height: 20px;
        stroke-width: 2px;
      }

      .notes-content-container {
        padding: 0 4px; /* Scrollbar offset */
        flex-grow: 1;
        overflow-y: auto;
        overflow-x: hidden;
        scroll-behavior: smooth;
        display: flex;
        flex-direction: column;
      }

      .notes-content-container::-webkit-scrollbar {
        width: 6px;
      }
      .notes-content-container::-webkit-scrollbar-track {
        background: transparent;
      }
      .notes-content-container::-webkit-scrollbar-thumb {
        background-color: rgba(0, 0, 0, 0.1);
        border-radius: 10px;
      }

      /* Removed min-height: 100% to allow natural scrolling flow, 
         and removed .note-section:not(.focused) { display: none; } to show all notes */
      .note-section {
        padding: 1.5rem 2rem 3rem; /* Increased bottom padding for separation */
        min-height: auto; /* Allow natural height */
        box-sizing: border-box;
      }

      /* Previously hidden sections are now visible for scrolling */
      /* .note-section:not(.focused) {
        display: none;
      } */

      .note-section-header {
        font-size: 0.85rem;
        font-weight: 600;
        color: var(--secondary-color);
        margin-bottom: 1.5rem;
        opacity: 0.6;
      }

      /* HIGHLIGHT CURRENT DATE */
      .note-section.is-today {
        background-color: rgba(0, 122, 255, 0.03); /* Subtle blue tint */
        position: relative;
        border-radius: 8px; /* Slight radius for the block */
      }

      .note-section.is-today::before {
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 3px;
        background-color: var(--primary-color);
        border-top-right-radius: 4px;
        border-bottom-right-radius: 4px;
        opacity: 0.8;
      }

      .note-section.is-today .note-section-header {
        color: var(--primary-color);
        font-weight: 700;
        opacity: 1;
      }

      .note-editor {
        outline: none;
        font-size: 16px;
        line-height: 1.5;
        color: #37352f; /* Notion text color */
      }

      /* Specific padding for Brain Dump (Tasks) editor */
      #brain-dump-editor.note-editor {
        padding: 12px 22px;
      }

      /* --- Element Styles (Notion-like) --- */

      /* Placeholder for empty blocks */
      .note-editor p:empty::before,
      .note-editor h1:empty::before,
      .note-editor h2:empty::before,
      .note-editor h3:empty::before {
        content: attr(placeholder);
        color: rgba(55, 53, 47, 0.4); /* Notion placeholder color */
        pointer-events: none;
        float: left; /* Fix for cursor position */
        height: 0;
      }

      /* Paragraphs */
      .note-editor p {
        min-height: 1.5em; /* Ensure empty lines are clickable */
        margin: 2px 0; /* Tight spacing between text blocks */
        padding: 3px 2px;
        border-radius: 3px;
      }
      .note-editor .indent-1 {
        margin-left: 20px !important;
      }
      .note-editor .indent-2 {
        margin-left: 40px !important;
      }

      /* Headings */
      .note-editor h1 {
        font-size: 1.875rem;
        font-weight: 700;
        margin: 1.2em 0 0.25em; /* Spacing above */
        line-height: 1.3;
      }
      .note-editor h2 {
        font-size: 1.5rem;
        font-weight: 600;
        margin: 1em 0 0.2em;
        line-height: 1.3;
      }
      .note-editor h3 {
        font-size: 1.25rem;
        font-weight: 600;
        margin: 0.8em 0 0.2em;
        line-height: 1.3;
      }

      /* Lists */
      /* We use a flat structure for list items to avoid nesting hell in contenteditable */
      .note-editor .list-item-bullet {
        display: flex;
        align-items: flex-start;
        line-height: 1.5;
        margin-top: 4px;
        margin-bottom: 4px;
      }
      /* Unified class: JS uses .bullet, so we style .bullet. 
         Also keeping .list-marker just in case, but ensuring .bullet is the primary. */
      .note-editor .bullet,
      .note-editor .list-marker {
        flex-shrink: 0;
        width: 24px;
        display: flex;
        justify-content: center;
        margin-right: 5px; /* Reduced from 12px to 8px */
        color: #37352f;
        font-weight: bold;
        line-height: 1.5;
        user-select: none;
        font-size: 1.2rem; /* Slightly larger bullet */
      }

      /* Dark Mode Bullet Override */
      body.dark-mode .note-editor .bullet,
      body.dark-mode .note-editor .list-marker {
        color: #ffffff;
      }

      span.bullet {
        transform: translateY(-2.5px);
      }

      .note-editor .list-content {
        flex-grow: 1;
        outline: none;
        min-height: 1.5em; /* Ensure clickable area */
      }

      /* Quotes */
      /* Quotes */
      .note-editor blockquote {
        margin: 16px 0;
        padding: 8px 20px;
        border-left: 4px solid var(--primary-color);
        background-color: rgba(0, 0, 0, 0.03);
        border-radius: 0 8px 8px 0;
        font-family: "Georgia", "Times New Roman", serif;
        font-style: italic;
        font-size: 1.15em;
        color: inherit;
        line-height: 1.6;
      }

      /* Dark Mode Quote Override */
      body.dark-mode .note-editor blockquote {
        background-color: rgba(255, 255, 255, 0.05);
        border-left-color: var(--primary-color);
        color: #e5e5e7;
      }

      /* To-do List */
      .note-editor .todo-item {
        display: flex;
        align-items: flex-start;
        line-height: 1.5;
        margin-top: 6px;
        margin-bottom: 6px;
      }
      .note-editor .todo-checkbox {
        /* This IS the input element */
        width: 15px; /* Standard visible size */
        height: 15px;
        margin: 0;
        margin-right: 8px;
        cursor: pointer;
        accent-color: var(--primary-color);
        transform: scale(
          1.2
        ); /* Scale up to match text better (approx 21.6px visual) */
        /* Remove flex/padding properties that were meant for a wrapper */
        align-self: flex-start; /* Ensure it stays at top multiline */
        margin-top: 5px; /* Visual alignment with text top */
      }
      /* Remove invalid nested selector block */

      .note-editor .todo-item.checked .list-content {
        text-decoration: line-through;
        color: rgba(55, 53, 47, 0.5);
      }

      /* Code Block */
      .note-editor pre {
        background: #f7f6f3;
        padding: 1rem; /* More generous specific padding */
        border-radius: 4px;
        font-family: monospace;
        font-size: 0.9em;
        color: #eb5757;
        margin: 4px 0;
        white-space: pre-wrap;
      }

      /* --- Slash Menu / Popover --- */
      .slash-menu {
        position: fixed;
        background: white;
        width: 260px;
        max-height: 300px;
        overflow-y: auto;
        box-shadow: 0 4px 20px rgba(15, 15, 15, 0.1),
          0 0 0 1px rgba(15, 15, 15, 0.05);
        border-radius: 6px;
        padding: 6px 0;
        z-index: 10000;
        display: none;
        font-size: 14px;
        /* Position is set dynamically by JavaScript */
      }
      .slash-menu.visible {
        display: block !important;
      }

      .slash-menu-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 6px 12px;
        cursor: pointer;
        color: #37352f;
        transition: background 0.1s;
      }
      .slash-menu-item:hover,
      .slash-menu-item.selected {
        background: rgba(55, 53, 47, 0.08); /* Notion hovering color */
      }

      .slash-item-icon {
        width: 46px; /* Larger icon area */
        height: 46px;
        border-radius: 4px;
        border: 1px solid rgba(55, 53, 47, 0.1);
        display: grid;
        place-items: center;
        background: white;
      }
      .slash-item-icon img,
      .slash-item-icon svg {
        width: 24px;
        height: 24px;
        opacity: 0.8;
      }

      .slash-item-text {
        display: flex;
        flex-direction: column;
      }
      .slash-item-title {
        font-weight: 500;
        font-size: 14px;
      }
      .slash-item-desc {
        font-size: 12px;
        color: rgba(55, 53, 47, 0.6);
      }

      /* --- Jump to Today (Floating) --- */
      .jump-to-today-btn {
        position: absolute;
        bottom: 1rem;
        left: 50%;
        transform: translateX(-50%) translateY(10px);
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: 99px;
        padding: 0.5rem 1rem;
        font-size: 0.75rem;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(0, 122, 255, 0.4);
        display: flex;
        align-items: center;
        gap: 0.5rem;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, transform 0.3s ease, visibility 0.3s ease;
        z-index: 10;
      }
      .jump-to-today-btn.visible {
        opacity: 1;
        visibility: visible;
        transform: translateX(-50%) translateY(0);
      }
      .jump-to-today-btn svg {
        width: 16px;
        height: 16px;
        stroke: currentColor;
        stroke-width: 2.5;
      }
      /* Notes Widget Collapsed State */
      .notes-widget.collapsed {
        width: 50px !important;
        height: 50px !important;
        min-height: 0 !important;
        border-radius: 50%;
        padding: 0;
        overflow: hidden;
        cursor: pointer;
        display: grid;
        place-items: center;
        background-color: var(--clock-bg);
      }
      .notes-widget.collapsed .notes-widget-header,
      .notes-widget.collapsed .notes-content-container,
      .notes-widget.collapsed .jump-to-today-btn {
        display: none !important;
      }
      /* Icon shown when collapsed */
      .notes-widget-collapsed-icon {
        display: none;
        color: var(--secondary-color);
      }
      .notes-widget.collapsed .notes-widget-collapsed-icon {
        display: block;
      }

      /* Only allow expanding by clicking the body if collapsed, 
         to prevent interfering with content interaction when expanded.
         (Handled via JS logic, but pointer-events here can help if needed) */

      /* ================================== */
      /* ==      HABIT WIDGET STYLES     == */
      /* ================================== */
      .habit-widget {
        position: fixed;
        top: 1.5rem;
        right: 1.5rem;
        width: clamp(300px, 22vw, 360px);
        background-color: var(--clock-bg);
        border-radius: 12px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.12);
        border: 1px solid var(--border-color);
        z-index: 600; /* High z-index (beats collapsed items) */
        display: flex;
        flex-direction: column;
        max-height: 50vh;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica,
          Arial, sans-serif;
        opacity: 0;
        transform: translateY(-20px);
        animation: fadeInDownWidget 0.6s cubic-bezier(0.22, 1, 0.36, 1) forwards;
      }

      @keyframes fadeInDownWidget {
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .habit-widget-header {
        padding: 1rem 1.25rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        background-color: rgba(255, 255, 255, 0.5);
        backdrop-filter: blur(8px);
      }

      .habit-widget-title {
        font-size: 1rem;
        font-weight: 700;
        color: var(--text-color);
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .habit-widget-title svg {
        width: 18px;
        height: 18px;
        color: var(--primary-color);
      }

      .habit-list {
        padding: 0;
        overflow-y: auto;
        flex-grow: 1;
        scroll-behavior: smooth;
      }
      .habit-list::-webkit-scrollbar {
        width: 5px;
      }
      .habit-list::-webkit-scrollbar-thumb {
        background-color: rgba(0, 0, 0, 0.1);
        border-radius: 10px;
      }

      .habit-item {
        padding: 1rem 1.25rem;
        border-bottom: 1px solid rgba(0, 0, 0, 0.03);
        transition: background-color 0.2s;
        position: relative;
      }
      .habit-item:last-child {
        border-bottom: none;
      }
      .habit-item:hover {
        background-color: rgba(0, 0, 0, 0.01);
      }

      .habit-item-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.75rem;
      }

      .habit-name {
        font-weight: 600;
        font-size: 0.95rem;
        color: #1d1d1f;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .habit-streak {
        font-size: 0.75rem;
        color: var(--secondary-color);
        font-weight: 500;
        background-color: rgba(0, 0, 0, 0.04);
        padding: 2px 8px;
        border-radius: 99px;
      }
      .habit-streak.fire {
        color: #ff9500;
        background-color: rgba(255, 149, 0, 0.1);
      }

      .habit-grid {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 4px;
        margin-top: 0.5rem;
      }

      .habit-day {
        aspect-ratio: 1/1;
        border-radius: 4px;
        background-color: rgba(0, 0, 0, 0.05);
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
        position: relative;
      }
      .habit-day:hover {
        transform: scale(1.15);
        z-index: 2;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      /* FIX: Force GREEN color for active habits as requested */
      .habit-day.active {
        background-color: #34c759 !important;
      }

      /* Collapsed state logic */
      .habit-grid.collapsed .habit-day {
        display: none;
      }
      .habit-grid.collapsed .habit-day.current-week {
        display: block;
      }

      .habit-day.today {
        border: 2px solid var(--text-color);
        transform: scale(0.9);
      }
      .habit-day.today.active {
        border-color: transparent;
        transform: scale(1);
      }
      /* Individual habit colors will be set via inline styles or specific classes if needed, 
         but for now we depend on the JS injecting the color */

      .habit-day.today {
        border: 2px solid var(--text-color);
        transform: scale(0.9);
      }
      .habit-day.today.active {
        border-color: transparent;
        transform: scale(1);
      }

      .habit-controls {
        display: flex;
        align-items: center;
        gap: 4px;
        opacity: 0.6;
        transition: opacity 0.2s;
      }
      .habit-item:hover .habit-controls {
        opacity: 1;
      }
      .habit-btn-mini {
        width: 24px;
        height: 24px;
        border: none;
        background: transparent;
        color: #8e8e93;
        cursor: pointer;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
      }
      .habit-btn-mini:hover {
        background-color: rgba(0, 0, 0, 0.05);
        color: #333;
      }
      .habit-btn-mini.delete:hover {
        color: #ff3b30;
        background-color: rgba(255, 59, 48, 0.1);
      }

      .habit-expand-btn {
        transform: rotate(0deg);
        transition: transform 0.3s;
      }
      .habit-expand-btn.expanded {
        transform: rotate(180deg);
      }

      .habit-btn-mini {
        width: 24px;
        height: 24px;
        border: none;
        background: transparent;
        color: #8e8e93;
        cursor: pointer;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .habit-btn-mini:hover {
        background-color: rgba(0, 0, 0, 0.05);
        color: #333;
      }
      .habit-btn-mini.delete:hover {
        color: #ff3b30;
        background-color: rgba(255, 59, 48, 0.1);
      }

      /* Habit Widget Collapsed State */
      .habit-widget.collapsed {
        width: 50px !important;
        height: 50px !important;
        min-height: 0 !important;
        border-radius: 50%;
        padding: 0;
        overflow: hidden;
        cursor: pointer;
        display: grid;
        place-items: center;
        background-color: var(--clock-bg);
        z-index: 500 !important; /* Base collapsed level */
      }
      .habit-widget.collapsed .habit-widget-header,
      .habit-widget.collapsed .habit-list,
      .habit-widget.collapsed .habit-grid {
        display: none !important;
      }

      /* NEW: Habit Stats Styles */
      .habit-stats {
        display: flex;
        gap: 0.5rem;
        align-items: center;
        font-size: 0.75rem;
      }

      .habit-stat-item {
        background-color: var(--bg-secondary);
        padding: 2px 6px;
        border-radius: 4px;
        color: var(--text-secondary);
        display: flex;
        align-items: center;
        gap: 4px;
        white-space: nowrap;
      }

      .habit-stat-item.highlight {
        color: var(--primary-color);
        font-weight: 500;
        background-color: rgba(0, 122, 255, 0.1);
      }
      /* Icon shown when collapsed */
      .habit-widget-collapsed-icon {
        display: none;
        color: var(--primary-color);
      }
      .habit-widget.collapsed .habit-widget-collapsed-icon {
        display: block;
      }

      /* Modal overrides for Habit */
      #habit-modal .color-option {
        width: 24px;
        height: 24px;
      }

      /* Enhanced Habit Day Styling */
      .habit-day {
        aspect-ratio: 1/1;
        border-radius: 6px; /* Slightly softer */
        background-color: rgba(0, 0, 0, 0.05);
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 0.75rem;
        font-weight: 500;
        color: var(--secondary-color);
        user-select: none;
      }
      .habit-day.past {
        opacity: 0.6;
      }
      .habit-day.future {
        background-color: transparent;
        border: 1px solid rgba(0, 0, 0, 0.05);
        color: #ccc;
      }
      /* Active (Completed) overrides everything */
      .habit-day.active {
        background-color: #34c759 !important;
        color: white !important;
        opacity: 1 !important;
        border: none !important;
      }
      .habit-day.today {
        border: 2px solid var(--primary-color) !important;
        background-color: rgba(0, 122, 255, 0.05);
        color: var(--primary-color);
        font-weight: 700;
      }
      .habit-day.today.active {
        border-color: #34c759 !important;
        background-color: #34c759 !important;
        color: white !important;
      }

      /* ================================== */
      /* ==     POMODORO WIDGET STYLES   == */
      /* ================================== */
      .pomodoro-widget {
        position: fixed;
        /* Expanded State: Same position as Habit Widget (Top Right) */
        top: 1.5rem;
        right: 1.5rem;
        width: clamp(300px, 22vw, 360px);
        background-color: var(--clock-bg);
        border-radius: 12px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.12);
        border: 1px solid var(--border-color);
        z-index: 600; /* Active/Expanded beats collapsed */
        display: flex;
        flex-direction: column;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica,
          Arial, sans-serif;
        /* Animation properties */
        opacity: 0;
        transform: translateY(-20px);
        animation: fadeInDownWidget 0.6s cubic-bezier(0.22, 1, 0.36, 1) forwards;
        transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
      }

      .pomodoro-widget-header {
        padding: 1rem 1.25rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        background-color: rgba(255, 255, 255, 0.5);
        backdrop-filter: blur(8px);
      }

      .pomodoro-widget-title {
        font-size: 1rem;
        font-weight: 700;
        color: var(--text-color);
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .pomodoro-widget-title svg {
        width: 18px;
        height: 18px;
        color: #ff3b30; /* Red for Pomodoro */
      }

      .pomodoro-content {
        padding: 1.5rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1.25rem;
        transition: opacity 0.2s ease;
      }

      .timer-display {
        font-size: 3.5rem;
        font-weight: 800;
        font-variant-numeric: tabular-nums;
        color: #1d1d1f;
        letter-spacing: -2px;
        line-height: 1;
      }

      .timer-controls {
        display: flex;
        gap: 1rem;
        width: 100%;
        justify-content: center;
      }

      /* Reuse existing button styles but refine sizing */
      .timer-btn {
        padding: 0.75rem 2rem;
        border-radius: 99px;
        border: none;
        font-weight: 600;
        font-size: 1rem;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        transition: all 0.2s ease;
      }
      .timer-btn-primary {
        background-color: #ff3b30;
        color: white;
        box-shadow: 0 4px 12px rgba(255, 59, 48, 0.3);
      }
      .timer-btn-primary:hover {
        background-color: #d63026;
        transform: translateY(-1px);
      }
      .timer-btn-secondary {
        background-color: #f2f2f7;
        color: var(--text-color);
        width: 48px;
        height: 48px;
        padding: 0;
        justify-content: center;
        border-radius: 50%;
      }
      .timer-btn-secondary:hover {
        background-color: #e5e5ea;
      }

      .preset-times {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        justify-content: center;
        width: 100%;
      }

      .preset-chip {
        padding: 0.4rem 0.8rem;
        background-color: white;
        border: 1px solid #e5e5ea;
        border-radius: 8px;
        font-size: 0.9rem;
        font-weight: 500;
        color: var(--secondary-color);
        cursor: pointer;
        transition: all 0.2s;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        position: relative;
      }
      .preset-chip:hover {
        background-color: #f9f9f9;
        color: var(--text-color);
        transform: translateY(-1px);
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.08);
      }
      .preset-chip.active {
        background-color: #ff3b30;
        color: white;
        border-color: #ff3b30;
        box-shadow: 0 2px 6px rgba(255, 59, 48, 0.25);
      }

      /* Delete badge for edit mode */
      .preset-chip .delete-badge {
        position: absolute;
        top: -6px;
        right: -6px;
        width: 16px;
        height: 16px;
        background-color: red;
        color: white;
        border-radius: 50%;
        font-size: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        display: none;
      }
      .preset-times.edit-mode .preset-chip .delete-badge {
        display: flex;
      }
      .preset-times.edit-mode .preset-chip {
        animation: shake 0.3s infinite;
      }

      @keyframes shake {
        0% {
          transform: rotate(0deg);
        }
        25% {
          transform: rotate(1deg);
        }
        75% {
          transform: rotate(-1deg);
        }
        100% {
          transform: rotate(0deg);
        }
      }

      @keyframes calmBlink {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.3;
        }
        100% {
          opacity: 1;
        }
      }

      .paused-blink {
        animation: calmBlink 2s ease-in-out infinite;
      }

      .add-preset-btn,
      .edit-preset-btn {
        width: 32px;
        height: 32px;
        border-radius: 8px;
        border: 1px dashed #c7c7cc;
        background: transparent;
        color: #8e8e93;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s;
      }
      .add-preset-btn:hover {
        border-color: #ff3b30;
        color: #ff3b30;
        background-color: rgba(255, 59, 48, 0.05);
      }
      .edit-preset-btn.active {
        background-color: #e5e5ea;
        color: #333;
        border-style: solid;
      }

      .custom-time-input {
        display: flex;
        gap: 0.5rem;
        align-items: center;
        width: 100%;
        margin-top: 0.5rem;
      }

      .custom-time-input input {
        flex-grow: 1;
        padding: 0.75rem;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        font-family: inherit;
        text-align: center;
        background-color: #f9f9f9;
        font-size: 1rem;
      }
      .custom-time-input input:focus {
        background-color: white;
        border-color: #ff3b30;
        outline: none;
      }

      .custom-time-input button {
        padding: 0.75rem 1.25rem;
        background-color: #1c1c1e;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.2s;
      }
      .custom-time-input button:hover {
        background-color: #3a3a3c;
      }
      .custom-time-input button.btn-add-mode {
        background-color: #34c759;
      }
      .custom-time-input button.btn-add-mode:hover {
        background-color: #2da84e;
      }

      /* Collapsed State */
      .pomodoro-widget.collapsed {
        width: 50px !important;
        height: 50px !important;
        min-height: 0 !important;
        border-radius: 50%;
        padding: 0;
        overflow: hidden;
        cursor: pointer;
        display: grid;
        place-items: center;
        place-items: center;
        background-color: var(--clock-bg);
        z-index: 501 !important; /* Stacked above Habit collapsed */

        /* Position Shift when Collapsed */
        /* Assuming Habit widget is top: 1.5rem. 
           Habit height ~50px. 
           Gap ~10px. 
           So Top = 1.5rem (24px) + 50px + 10px = ~84px */
        top: calc(1.5rem + 50px + 12px) !important;
        right: 1.5rem !important;
        /* Disable shadow in collapsed state to match others */
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }
      .pomodoro-widget.collapsed .pomodoro-widget-header,
      .pomodoro-widget.collapsed .pomodoro-content {
        display: none !important;
      }

      .pomodoro-widget-collapsed-icon {
        display: none;
        color: #ff3b30;
      }
      .pomodoro-widget.collapsed .pomodoro-widget-collapsed-icon {
        display: block;
      }

      .pomodoro-collapsed-time-text {
        font-size: 13px;
        font-weight: 600;
        color: var(--text-color); /* Use variable for auto dark mode */
        margin-top: 2px;
        text-align: center;
        width: 100%;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 2;
      }
      /* ================================== */
      /* ==      EVENTS WIDGET STYLES    == */
      /* ================================== */
      .events-widget {
        position: fixed;
        /* Expanded Position: Same as others (stacking context handled via visibility/z-index or user interaction) */
        /* Actually, user wants it to "sit with the notes widget in the top right".
           We will use the same "Top Right Stack" slot. */
        top: 1.5rem;
        right: 1.5rem;
        width: clamp(300px, 22vw, 360px);
        background-color: var(--clock-bg);
        border-radius: 12px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.12);
        border: 1px solid var(--border-color);
        z-index: 600; /* High z-index (beats collapsed items) */
        display: flex;
        flex-direction: column;
        max-height: 60vh;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica,
          Arial, sans-serif;

        opacity: 0;
        transform: translateY(-20px);
        animation: fadeInDownWidget 0.6s cubic-bezier(0.22, 1, 0.36, 1) forwards;
        transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
      }

      .events-widget-header {
        padding: 1rem 1.25rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        background-color: rgba(255, 255, 255, 0.5);
        backdrop-filter: blur(8px);
        flex-shrink: 0;
      }

      /* Toggle Switch */
      .toggle-switch {
        position: relative;
        display: inline-block;
        width: 50px;
        height: 28px;
        flex-shrink: 0;
      }
      .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #e9e9eb; /* Light Gray for OFF state */
        transition: 0.4s;
        border: 1px solid #d1d1d6;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
      }
      .slider:before {
        position: absolute;
        content: "";
        height: 24px;
        width: 24px;
        left: 1px;
        bottom: 1px;
        background-color: white;
        transition: 0.4s;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), 0 0 1px rgba(0, 0, 0, 0.1); /* Drop shadow for knob */
      }
      /* Checked State */
      input:checked + .slider {
        background-color: #34c759;
        border-color: #34c759;
      }
      input:checked + .slider:before {
        transform: translateX(22px);
      }
      /* Rounded Sliders */
      .slider.round {
        border-radius: 34px;
      }
      .slider.round:before {
        border-radius: 50%;
      }
      /* Dark Mode Adjustments */
      @media (prefers-color-scheme: dark) {
        .slider {
          background-color: #3a3a3c;
          border-color: #636366;
        }
        input:checked + .slider {
          background-color: #30d158;
          border-color: #30d158;
        }
        /* Fix Input Time Icon Visibility */
        input[type="time"]::-webkit-calendar-picker-indicator {
          filter: invert(1);
        }
      }

      .events-widget-title {
        font-size: 1rem;
        font-weight: 700;
        color: var(--text-color);
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .events-widget-title svg {
        width: 18px;
        height: 18px;
        color: #ff9f0a; /* Orange for Events */
      }

      .events-content {
        display: flex;
        flex-direction: column;
        flex-grow: 1;
        overflow-y: auto;
        padding: 0;
      }
      .events-content::-webkit-scrollbar {
        width: 6px;
      }
      .events-content::-webkit-scrollbar-track {
        background: transparent;
      }
      .events-content::-webkit-scrollbar-thumb {
        background-color: var(--border-color);
        border-radius: 99px;
      }
      .events-content::-webkit-scrollbar-thumb:hover {
        background-color: var(--secondary-color);
      }
      /* Add Event Section */
      .add-event-section {
        padding: 1rem 1.25rem;
        background-color: rgba(0, 0, 0, 0.02);
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
      }
      .add-event-date-display {
        font-size: 0.85rem;
        font-weight: 600;
        color: var(--secondary-color);
        margin-bottom: 0.5rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .add-event-input-group {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 0.5rem;
      }
      .add-event-input {
        flex-grow: 1;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 0.5rem;
        font-family: inherit;
        font-size: 0.9rem;
      }
      .add-event-input:focus {
        outline: none;
        border-color: #ff9f0a;
      }

      .event-color-picker {
        display: flex;
        gap: 0.5rem;
        padding: 0.25rem 0;
      }
      .event-color-option {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid transparent;
        transition: transform 0.2s;
      }
      .event-color-option.selected {
        border-color: var(--text-color);
        transform: scale(1.1);
      }

      .btn-add-event {
        width: 100%;
        margin-top: 0.5rem;
        background-color: #ff9f0a;
        color: white;
        border: none;
        padding: 0.5rem;
        border-radius: 6px;
        font-weight: 600;
        cursor: pointer;
        font-size: 0.9rem;
        transition: background-color 0.2s;
      }
      .btn-add-event:hover {
        background-color: #e68d00;
      }

      /* Events List */
      .events-list-container {
        padding: 1rem 1.25rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .events-group-header {
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: var(--secondary-color);
        font-weight: 700;
        margin-bottom: 0.5rem;
      }
      .event-item {
        display: flex;
        align-items: center;
        background: white;
        padding: 0.75rem;
        border-radius: 8px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        border: 1px solid rgba(0, 0, 0, 0.05);
        margin-bottom: 0.5rem;
        gap: 0.75rem;
        transition: transform 0.1s;
      }
      .event-item:hover {
        transform: translateY(-1px);
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.08);
      }
      .event-date-badge {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background-color: rgba(0, 0, 0, 0.03);
        border-radius: 6px;
        padding: 0.25rem 0.5rem;
        min-width: 40px;
      }
      .event-date-day {
        font-size: 1.1rem;
        font-weight: 700;
        color: var(--text-color);
        line-height: 1;
      }
      .event-date-month {
        font-size: 0.6rem;
        text-transform: uppercase;
        color: var(--secondary-color);
        font-weight: 600;
      }
      .event-info {
        flex-grow: 1;
        overflow: hidden;
      }
      .event-title {
        font-size: 0.95rem;
        font-weight: 600;
        color: var(--text-color);
        white-space: normal;
        word-break: break-word;
        line-height: 1.3;
      }
      .event-time-tag {
        font-size: 0.75rem;
        color: var(--secondary-color);
      }
      .event-color-indicator {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        flex-shrink: 0;
      }
      .delete-event-btn {
        background: none;
        border: none;
        color: #c7c7cc;
        cursor: pointer;
        padding: 4px;
        border-radius: 4px;
        display: flex;
      }
      .delete-event-btn:hover {
        color: #ff3b30;
        background-color: rgba(255, 59, 48, 0.1);
      }

      /* Event Completion & Editing Styles */
      .event-checkbox {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        border: 2px solid var(--border-color);
        background: transparent;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        transition: all 0.2s;
        flex-shrink: 0;
      }
      .event-checkbox:hover {
        border-color: #34c759;
      }
      .event-checkbox.checked {
        background-color: #34c759;
        border-color: #34c759;
      }
      .event-checkbox svg {
        width: 12px;
        height: 12px;
        display: none;
      }
      .event-checkbox.checked svg {
        display: block;
      }

      .event-item.completed {
        opacity: 0.6;
        filter: grayscale(0.5);
      }
      .event-item.completed .event-title {
        text-decoration: line-through;
        color: var(--secondary-color);
      }

      .event-actions {
        display: flex;
        gap: 4px;
      }
      .edit-event-btn,
      .save-event-btn {
        background: none;
        border: none;
        color: var(--secondary-color);
        cursor: pointer;
        padding: 4px;
        border-radius: 4px;
        display: flex;
        transition: color 0.2s;
      }
      .edit-event-btn:hover {
        color: var(--text-color);
        background-color: rgba(0, 0, 0, 0.05);
      }
      .save-event-btn {
        color: #34c759;
      }
      .save-event-btn:hover {
        background-color: rgba(52, 199, 89, 0.1);
      }

      .event-title-edit-input {
        font-family: inherit;
        font-size: 0.95rem;
        font-weight: 600;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 2px 4px;
        width: 100%;
        color: var(--text-color);
      }
      .event-title-edit-input:focus {
        outline: none;
        border-color: #ff9f0a;
      }

      /* Collapsed State */
      .events-widget.collapsed {
        width: 50px !important;
        height: 50px !important;
        min-height: 0 !important;
        border-radius: 50%;
        padding: 0;
        overflow: hidden;
        cursor: pointer;
        display: grid;
        place-items: center;
        background-color: var(--clock-bg);
        z-index: 502 !important; /* Stacked above Pomodoro collapsed */

        /* Position Stack:
           Habit: top: 1.5rem + 0 (1st)
           Pomodoro: top: calc(1.5rem + 50px + 12px) (2nd) ~84px gap from top of Habit? 
                     Actually pomodoro collapsed rule says: top: calc(1.5rem + 50px + 12px)
           Events: top: calc(1.5rem + (50px + 12px) * 2) (3rd)
        */
        top: calc(1.5rem + 100px + 24px) !important;
        right: 1.5rem !important;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }
      .events-widget.collapsed .events-widget-header,
      .events-widget.collapsed .events-content {
        display: none !important;
      }

      .events-widget-collapsed-icon {
        display: none;
        color: #ff9f0a;
        position: relative;
        width: 100%;
        height: 100%;
        /* Correct Flex centering */
        justify-content: center;
        align-items: center;
      }

      /* New Count Display Style */
      .event-count-remaining {
        font-size: 18px;
        font-weight: 700;
        color: #ff9f0a;
        display: none;
      }
      .event-collapsed-svg {
        display: block;
      }
      /* Hide old badge */
      .event-count-badge {
        display: none !important;
      }
      .events-widget.collapsed .events-widget-collapsed-icon {
        display: flex; /* Flex to center svg */
      }

      /* Event Count Badge */
      .event-count-badge {
        position: absolute;
        top: 0px;
        right: 0px;
        background-color: #ff3b30;
        color: white;
        font-size: 10px;
        font-weight: 700;
        min-width: 18px;
        height: 18px;
        border-radius: 9px;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid var(--clock-bg);
        transform: scale(0);
        transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      }
      .event-count-badge.visible {
        transform: scale(1);
      }

      /* Calendar Indicators */
      .date-event-indicators {
        position: absolute;
        bottom: 6px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 2px;
        width: 70%;
        justify-content: center;
        height: 3px;
      }
      /* --- Search Bar Styles --- */
      #notes-search-bar {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 50px; /* Match header height */
        background-color: var(--clock-bg);
        z-index: 10;
        display: flex;
        align-items: center;
        padding: 0 1rem;
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        gap: 0.5rem;
        animation: slideDownSearch 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
      }

      @keyframes slideDownSearch {
        from {
          transform: translateY(-10px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      .search-input-wrapper {
        flex-grow: 1;
        display: flex;
        align-items: center;
        background-color: rgba(0, 0, 0, 0.04);
        padding: 4px 8px;
        border-radius: 6px;
        gap: 6px;
      }

      .search-icon-small {
        width: 14px;
        height: 14px;
        color: var(--secondary-color);
        flex-shrink: 0;
      }

      #notes-search-input {
        background: transparent;
        border: none;
        outline: none;
        font-family: inherit;
        font-size: 0.9rem;
        color: var(--text-color);
        width: 100%;
      }

      .search-count {
        font-size: 0.75rem;
        color: var(--secondary-color);
        white-space: nowrap;
        font-variant-numeric: tabular-nums;
        margin-left: 4px;
      }

      .search-nav-controls {
        display: flex;
        gap: 2px;
        flex-shrink: 0;
      }

      .search-nav-controls button {
        background: none;
        border: none;
        cursor: pointer;
        padding: 6px;
        border-radius: 4px;
        color: var(--secondary-color);
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
      }

      .search-nav-controls button:hover {
        background-color: rgba(0, 0, 0, 0.05);
        color: var(--text-color);
      }

      .search-nav-controls button svg {
        width: 16px;
        height: 16px;
      }

      /* Close button specific */
      #search-close-btn {
        margin-left: 4px;
      }

      /* --- Search Highlights --- */
      .search-highlight {
        background-color: rgba(255, 214, 10, 0.4); /* Yellow highlight */
        color: black;
        border-radius: 2px;
        padding: 0 1px;
      }

      .search-highlight.current {
        background-color: rgba(255, 149, 0, 0.6); /* Darker orange for active */
        box-shadow: 0 0 0 2px rgba(255, 149, 0, 0.3);
      }

      /* --- Existing Styles --- */
      .event-indicator-bar {
        height: 100%;
        border-radius: 2px;
        flex-grow: 1;
        max-width: 12px;
      }
      /* Tooltip for truncated task names */
      .task-tooltip {
        position: fixed;
        background-color: var(--bg-color);
        color: var(--text-color);
        padding: 8px 12px;
        border-radius: 8px;
        box-shadow: 0 4px 15px var(--shadow-color);
        border: 1px solid var(--border-color);
        z-index: 10000;
        font-size: 14px;
        font-weight: 500;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s ease;
        max-width: 250px;
        word-wrap: break-word;
      }
      .task-tooltip.visible {
        opacity: 1;
      }
      /* ======================================================== */
      /* ==           PROFESSIONAL CONFIRMATION MODAL        == */
      /* ======================================================== */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
        z-index: 2000;
        display: flex;
        justify-content: center;
        align-items: center;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
      }
      .modal-overlay.visible {
        opacity: 1;
        visibility: visible;
      }

      .modal {
        background-color: var(--clock-bg);
        padding: 24px;
        border-radius: 16px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        max-width: 320px;
        width: 90%;
        transform: scale(0.95);
        transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
        border: 1px solid var(--border-color);
        /* Ensure text is centered by default for generic modals */
        text-align: center;
      }
      .modal-overlay.visible .modal {
        transform: scale(1);
      }

      /* Specific adjustments for Confirmation Modal content */
      .confirmation-modal-content h2 {
        margin: 0 0 8px 0;
        font-size: 1.25rem;
        font-weight: 600;
        color: var(--text-color);
      }
      .confirmation-modal-content p {
        margin: 0 0 24px 0;
        font-size: 0.95rem;
        color: var(--secondary-color);
        line-height: 1.4;
      }

      .modal-actions {
        display: flex;
        gap: 12px;
        justify-content: stretch;
      }
      .modal-btn {
        flex: 1;
        padding: 10px 16px;
        border: none;
        border-radius: 8px;
        font-size: 0.95rem;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s, transform 0.1s;
      }
      .modal-btn:active {
        transform: scale(0.96);
      }
      .modal-btn.cancel {
        background-color: rgba(120, 120, 128, 0.12); /* Apple-like gray */
        color: var(--text-color);
      }
      .modal-btn.cancel:hover {
        background-color: rgba(120, 120, 128, 0.2);
      }
      .modal-btn.destructive {
        background-color: var(--danger-color);
        color: white;
      }
      .modal-btn.destructive:hover {
        background-color: #d70015; /* Slightly darker red */
      }

      /* Dark Mode Overrides for Modals */
      body.dark-mode .modal {
        background-color: #1c1c1e;
        border-color: #38383a;
      }
      body.dark-mode .modal-btn.cancel {
        background-color: rgba(255, 255, 255, 0.1);
        color: white;
      }
      body.dark-mode .modal-btn.cancel:hover {
        background-color: rgba(255, 255, 255, 0.15);
      }
    </style>
  </head>
  <body>
    <div class="app-container">
      <div class="calendar-widget">
        <div class="calendar-header">
          <div class="month-year" id="month-year-header">
            <span class="month" id="calendar-month"></span>
            <span class="year" id="calendar-year"></span>
          </div>
          <div class="calendar-nav">
            <div class="calendar-arrows">
              <button id="prev-month-btn" aria-label="Previous Month">
                <svg
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M15 18l-6-6 6-6" />
                </svg>
              </button>
              <button id="next-month-btn" aria-label="Next Month">
                <svg
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M9 18l6-6-6-6" />
                </svg>
              </button>
            </div>
            <button
              id="toggle-calendar-btn"
              class="calendar-expand-btn"
              aria-label="Toggle View"
              title="Minimize/Maximize"
            >
              <svg
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <polyline points="4 14 10 14 10 20"></polyline>
                <polyline points="20 10 14 10 14 4"></polyline>
              </svg>
            </button>
          </div>
        </div>
        <div class="calendar-grid" id="calendar-weekdays"></div>
        <div class="calendar-grid" id="calendar-dates"></div>
      </div>

      <div class="controls">
        <!-- NEW: Digital Clock -->
        <div class="digital-clock-container">
          <div id="digital-clock-display" class="digital-clock-display">
            00:00
          </div>
          <button
            id="digital-format-toggle"
            class="digital-format-toggle"
            aria-label="Toggle Digital Clock Format"
            title="Switch 12h/24h"
          >
            24
          </button>
        </div>

        <div class="toggle-group">
          <input
            type="radio"
            id="mode-24h"
            name="clockMode"
            value="24h"
            checked
          />
          <label for="mode-24h">24 Hour</label>
          <input type="radio" id="mode-12h" name="clockMode" value="12h" />
          <label for="mode-12h">12 Hour</label>
        </div>
        <!-- This is for 12h mode -->
        <div class="toggle-group hidden" id="ampm-controls">
          <input type="radio" id="mode-am" name="ampm" value="am" checked />
          <label for="mode-am">AM</label>
          <input type="radio" id="mode-pm" name="ampm" value="pm" />
          <label for="mode-pm">PM</label>
        </div>
        <!-- ADD THIS NEW TOGGLE for 24h mode -->
        <div class="toggle-group" id="view-mode-controls">
          <input
            type="radio"
            id="view-mode-clock"
            name="viewMode"
            value="clock"
            checked
          />
          <label for="view-mode-clock">Clock</label>
          <input
            type="radio"
            id="view-mode-blocks"
            name="viewMode"
            value="blocks"
          />
          <label for="view-mode-blocks">Blocks</label>
        </div>
        <!-- Dark Mode Toggle -->
        <button
          id="dark-mode-toggle"
          class="icon-btn"
          aria-label="Toggle Dark Mode"
          style="
            background: none;
            border: none;
            cursor: pointer;
            color: var(--secondary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
            border-radius: 50%;
            transition: color 0.2s, background-color 0.2s;
          "
        >
          <svg
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
          </svg>
        </button>
        <button
          id="toggle-analytics-btn"
          class="icon-btn"
          aria-label="Analytics"
          title="Analytics & Insights"
          style="
            background: none;
            border: none;
            cursor: pointer;
            color: var(--secondary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
            border-radius: 50%;
            transition: color 0.2s, background-color 0.2s;
          "
        >
          <svg
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <path d="M3 3v18h18" />
            <path d="M18.7 8l-5.1 5.2-2.8-2.7L7 14.3" />
          </svg>
        </button>
      </div>

      <!-- EVENTS WIDGET -->
      <div class="events-widget" id="events-widget">
        <div class="events-widget-header">
          <div class="events-widget-title">
            <svg
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
              <line x1="16" y1="2" x2="16" y2="6"></line>
              <line x1="8" y1="2" x2="8" y2="6"></line>
              <line x1="3" y1="10" x2="21" y2="10"></line>
            </svg>
            Events
          </div>
          <button class="task-list-close-btn" id="toggle-events-widget-btn">
            <svg
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <polyline points="4 14 10 14 10 20"></polyline>
              <polyline points="20 10 14 10 14 4"></polyline>
            </svg>
          </button>
        </div>

        <div class="events-content" id="events-content">
          <div class="add-event-section" id="add-event-section">
            <div class="add-event-date-display" id="add-event-date-display">
              <svg
                width="14"
                height="14"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                <line x1="16" y1="2" x2="16" y2="6"></line>
                <line x1="8" y1="2" x2="8" y2="6"></line>
                <line x1="3" y1="10" x2="21" y2="10"></line>
              </svg>
              <span id="selected-event-date-text">Select a date</span>
            </div>
            <div class="add-event-input-group">
              <input
                type="text"
                class="add-event-input"
                id="event-title-input"
                placeholder="Event title..."
              />
            </div>
            <div class="event-color-picker" id="event-color-picker">
              <!-- Populated by JS -->
            </div>
            <button class="btn-add-event" id="btn-add-event">Add Event</button>
          </div>
          <div class="events-list-container" id="events-list-container">
            <!-- Populated by JS -->
          </div>
        </div>

        <!-- Collapsed Icon -->
        <div class="events-widget-collapsed-icon">
          <svg
            class="event-collapsed-svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="16" y1="2" x2="16" y2="6"></line>
            <line x1="8" y1="2" x2="8" y2="6"></line>
            <line x1="3" y1="10" x2="21" y2="10"></line>
          </svg>
          <span class="event-count-remaining" id="event-collapsed-count"
            >0</span
          >
        </div>
      </div>

      <!-- Existing Clock Container -->
      <div class="clock-container">
        <svg id="clock-svg" viewBox="0 0 400 400">
          <!-- FIX #4: Removed inline style -->
          <g id="time-of-day-container"></g>
          <path id="preview-arc" class="preview-arc"></path>
          <g id="tasks-container"></g>
          <g id="ticks-container"></g>
          <g id="numbers-container"></g>
          <circle
            id="click-target"
            cx="200"
            cy="200"
            r="198"
            fill="transparent"
          />
          <g id="labels-container"></g>
          <!-- FIX #4: Removed inline styles -->
          <g id="drag-labels-container">
            <text id="drag-time-label" fill="#333" text-anchor="middle"></text>
          </g>
          <g id="hands-container">
            <line id="hour-hand" x1="200" y1="200" x2="200" y2="120"></line>
            <line id="minute-hand" x1="200" y1="200" x2="200" y2="70"></line>
            <line id="second-hand" x1="200" y1="200" x2="200" y2="60"></line>
          </g>
          <g id="format-toggle-group" transform="translate(200, 392)">
            <!-- Invisible rectifier for easier clicking -->
            <rect
              class="format-toggle-bg"
              x="-20"
              y="-10"
              width="40"
              height="20"
              rx="4"
            />
            <text class="format-toggle-text">24H</text>
          </g>
          <circle class="clock-center" cx="200" cy="200" r="5"></circle>
        </svg>
      </div>

      <!-- REPLACE THE EXISTING "blocks-view-container" DIV WITH THIS ENTIRE SNIPPET -->
      <div class="blocks-view-container hidden" id="blocks-view-container">
        <div class="day-block-wrapper" id="yesterday-block-wrapper">
          <div class="day-block-label" id="yesterday-label"></div>
          <div class="day-block" id="yesterday-block">
            <div class="day-block-tasks" id="yesterday-tasks-container"></div>
            <div class="day-block-grid"></div>
            <div class="day-block-hours">
              <span>00</span>
              <span>06</span>
              <span>12</span>
              <span>18</span>
            </div>
            <!-- FIX: Added the missing preview block -->
            <div class="task-preview-block"></div>
          </div>
        </div>

        <div class="day-block-wrapper" id="today-block-wrapper">
          <div class="day-block-label" id="today-label"></div>
          <div class="day-block" id="today-block">
            <div class="day-block-tasks" id="today-tasks-container"></div>
            <div class="day-block-grid"></div>
            <div class="day-block-hours">
              <span>00</span>
              <span>06</span>
              <span>12</span>
              <span>18</span>
            </div>
            <!-- Note: This block was already here, but its ID is removed for consistency -->
            <div class="task-preview-block"></div>
            <div class="current-time-line" id="current-time-line"></div>
          </div>
        </div>

        <div class="day-block-wrapper" id="tomorrow-block-wrapper">
          <div class="day-block-label" id="tomorrow-label"></div>
          <div class="day-block" id="tomorrow-block">
            <div class="day-block-tasks" id="tomorrow-tasks-container"></div>
            <div class="day-block-grid"></div>
            <div class="day-block-hours">
              <span>00</span>
              <span>06</span>
              <span>12</span>
              <span>18</span>
            </div>
            <!-- FIX: Added the missing preview block -->
            <div class="task-preview-block"></div>
          </div>
        </div>
      </div>

      <!-- CODE TO ADD: Place this inside .app-container, after the blocks-view-container -->

      <!-- CODE TO REPLACE: Remove your old .progress-widget and replace it with this entire block. -->
      <div class="progress-widget hidden" id="progress-widget">
        <!-- View 1: The Default Progress View -->
        <!-- REPLACE this div -->
        <div class="progress-widget-main-view" id="progress-widget-main-view">
          <div class="progress-widget-header">
            <span
              class="progress-widget-counter"
              id="progress-widget-counter"
              title="View Today's Schedule"
            ></span>
            <button
              class="progress-widget-complete"
              id="progress-widget-complete"
              aria-label="Mark task as complete"
            >
              <svg
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2.5"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <polyline points="20 6 9 17 4 12"></polyline>
              </svg>
            </button>
          </div>
          <p
            class="progress-widget-task-name"
            id="progress-widget-task-name"
          ></p>
          <p
            class="progress-widget-task-time"
            id="progress-widget-task-time"
          ></p>
          <div class="progress-bar-container">
            <div class="progress-bar-elapsed" id="progress-bar-elapsed"></div>
            <span
              class="progress-bar-percentage"
              id="progress-bar-percentage"
            ></span>
          </div>

          <!-- ADD THIS ENTIRE SECTION for the new feature -->
          <div class="subtasks-section hidden" id="subtasks-section">
            <div class="subtasks-container" id="subtasks-container">
              <!-- Subtask cards will be dynamically inserted here -->
            </div>
            <div id="subtask-controls-container">
              <!-- "Add Subtask" button or limit notice will be here -->
            </div>
          </div>
        </div>

        <!-- View 2: The Expanded Task List View (hidden by default) -->
        <div class="task-list-view" id="task-list-view">
          <div class="task-list-header">
            <span>Today's Schedule</span>
            <button
              class="task-list-close-btn"
              id="task-list-close-btn"
              aria-label="Close task list"
            >
              <svg
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2.5"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          </div>
          <div class="task-list-cards" id="task-list-cards">
            <!-- Task cards will be dynamically inserted here -->
          </div>
        </div>
      </div>
    </div>

    <!-- Modal remains the same -->
    <div class="modal-overlay" id="task-modal">
      <div class="modal">
        <h2 id="modal-title">New Task</h2>
        <div class="modal-time">
          <input type="time" id="task-start-time" step="300" />
          <span>&ndash;</span>
          <input type="time" id="task-end-time" step="300" />
        </div>
        <input type="hidden" id="task-id" />
        <div class="form-group">
          <label for="task-name">Task Name</label>
          <input type="text" id="task-name" placeholder="e.g., Team Meeting" />
        </div>
        <div
          class="form-group"
          style="
            display: flex;
            flex-direction: row;
            justify-content: flex-start;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            width: 100%;
          "
        >
          <label class="toggle-switch">
            <input type="checkbox" id="task-recursion-toggle" />
            <span class="slider round"></span>
          </label>
          <label
            for="task-recursion-toggle"
            style="margin-bottom: 0; flex-grow: 0"
            >Daily Recurring Task</label
          >
        </div>
        <div class="form-group">
          <label>Color</label>
          <div class="color-selector" id="color-selector"></div>
        </div>
        <div class="form-group checkbox-group">
          <input type="checkbox" id="task-completed-checkbox" />
          <label for="task-completed-checkbox">Mark as Completed</label>
        </div>
        <div class="modal-actions">
          <button id="delete-task-btn" class="hidden">Delete</button>
          <button id="cancel-task-btn">Cancel</button>
          <button id="save-task-btn">Save</button>
        </div>
      </div>
    </div>

    <!-- CODE TO ADD: Place this after the modal-overlay div -->

    <!-- CODE TO REPLACE: notes-widget (adds toolbar container) -->
    <div class="notes-widget" id="notes-widget">
      <!-- Search Bar Overlay -->
      <div id="notes-search-bar" class="hidden">
        <div class="search-input-wrapper">
          <svg
            class="search-icon-small"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <circle cx="11" cy="11" r="8"></circle>
            <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
          </svg>
          <input
            type="text"
            id="notes-search-input"
            placeholder="Search notes..."
          />
          <span id="search-count" class="search-count hidden">0/0</span>
        </div>

        <div class="search-nav-controls">
          <button id="search-prev-btn" title="Previous match">
            <svg
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <polyline points="18 15 12 9 6 15"></polyline>
            </svg>
          </button>
          <button id="search-next-btn" title="Next match">
            <svg
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
          </button>
          <button id="search-close-btn" title="Close search">
            <svg
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        </div>
      </div>

      <div class="notes-widget-header">
        <div class="notes-widget-tabs">
          <div class="notes-tab active" id="tab-notes">
            <svg
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path
                d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"
              ></path>
              <path
                d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"
              ></path>
            </svg>
            Notes
          </div>
          <div class="notes-tab" id="tab-tasks">
            <svg
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M9 11l3 3L22 4"></path>
              <path
                d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"
              ></path>
            </svg>
            Tasks
          </div>
          <div class="notes-tab" id="tab-topics">
            <!-- Icon: Book/Folder -->
            <svg
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
              <path
                d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"
              ></path>
            </svg>
            Topics
          </div>
        </div>
        <div style="display: flex; gap: 4px; align-items: center">
          <!-- Clear All Button (Only visible in Tasks Tab via JS/CSS) -->
          <button
            class="add-element-btn"
            id="clear-tasks-btn"
            title="Clear All"
            style="display: none"
          >
            <svg
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <polyline points="3 6 5 6 21 6"></polyline>
              <path
                d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"
              ></path>
            </svg>
          </button>
          <button
            class="add-element-btn"
            id="search-notes-btn"
            title="Search Notes"
          >
            <svg
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <circle cx="11" cy="11" r="8"></circle>
              <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
            </svg>
          </button>
          <button
            class="add-element-btn"
            id="toggle-notes-widget-btn"
            title="Minimize"
          >
            <svg
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <polyline points="4 14 10 14 10 20"></polyline>
              <polyline points="20 10 14 10 14 4"></polyline>
            </svg>
          </button>
          <button
            class="add-element-btn"
            id="add-element-btn"
            title="Add Element"
          >
            <svg
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <line x1="12" y1="5" x2="12" y2="19"></line>
              <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg>
          </button>
        </div>
      </div>

      <!-- Icon shown when collapsed -->
      <div class="notes-widget-collapsed-icon">
        <svg
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <path
            d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"
          ></path>
          <path
            d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"
          ></path>
        </svg>
      </div>

      <!-- Slash Menu Moved to Body Root (Logic Removed Here) -->

      <div class="notes-content-container" id="notes-content-container">
        <!-- Note sections will be dynamically inserted here by JavaScript -->
      </div>

      <!-- NEW: Brain Dump Tasks Container -->
      <div class="notes-content-container hidden" id="tasks-content-container">
        <!-- Task Tabs Extension -->
        <div class="task-tabs-row" id="task-tabs-row">
          <div class="task-tabs-list" id="task-tabs-list">
            <!-- Tabs generated here -->
          </div>
          <button
            class="add-task-tab-btn"
            id="add-task-tab-btn"
            title="Add Tab"
          >
            +
          </button>
        </div>
        <div id="brain-dump-list">
          <!-- Tasks inserted here -->
        </div>
      </div>

      <!-- NEW: Topic Notes Containers -->
      <!-- Views -->
      <div
        id="topic-filter-container"
        class="topic-filter-container hidden"
      ></div>
      <div class="notes-content-container hidden" id="topic-list-view">
        <!-- List of topic cards will be rendered here -->
        <div
          class="empty-state-message"
          style="
            padding: 2rem;
            text-align: center;
            color: var(--secondary-color);
            opacity: 0.6;
          "
        >
          No topics yet. Click "+" to create one.
        </div>
      </div>

      <div
        class="notes-content-container hidden"
        id="topic-detail-view"
        style="display: none; flex-direction: column; height: 100%"
      >
        <div
          class="topic-detail-header"
          style="
            margin-bottom: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
          "
        >
          <div style="display: flex; gap: 0.5rem; align-items: center">
            <button
              class="topic-back-btn"
              id="topic-back-btn"
              title="Back to List"
              style="
                background: none;
                border: none;
                cursor: pointer;
                padding: 4px;
                color: var(--text-color);
              "
            >
              <svg
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path d="M19 12H5M12 19l-7-7 7-7" />
              </svg>
            </button>
            <input
              type="text"
              id="topic-title-input"
              placeholder="Topic Title"
              style="
                font-size: 1.2rem;
                font-weight: 700;
                border: none;
                background: transparent;
                color: var(--text-color);
                width: 100%;
                outline: none;
              "
            />
          </div>
          <div
            style="
              display: flex;
              gap: 0.5rem;
              align-items: center;
              padding-left: 2rem;
            "
          >
            <span
              style="
                font-size: 0.8rem;
                opacity: 0.6;
                display: flex;
                align-items: center;
                gap: 4px;
              "
            >
              <svg
                width="12"
                height="12"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path
                  d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"
                />
                <line x1="7" y1="7" x2="7.01" y2="7" />
              </svg>
            </span>
            <div
              id="topic-category-wrapper"
              style="
                flex-grow: 1;
                display: flex;
                flex-wrap: wrap;
                align-items: center;
                gap: 6px;
                padding: 4px;
                min-height: 28px;
                position: relative;
              "
            >
              <div
                id="topic-tags-container"
                style="display: flex; flex-wrap: wrap; gap: 4px"
              ></div>
              <input
                type="text"
                id="topic-category-input"
                placeholder="Add category..."
                autocomplete="off"
                style="
                  font-size: 0.9rem;
                  border: none;
                  background: transparent;
                  color: var(--text-color);
                  opacity: 0.8;
                  outline: none;
                  flex-grow: 1;
                  min-width: 80px;
                "
              />
              <!-- Dropdown Container -->
              <div id="category-predictions" class="category-dropdown"></div>
            </div>
          </div>
        </div>
        <div
          class="note-editor"
          id="topic-note-editor"
          contenteditable="true"
          style="flex: 1; overflow-y: auto; outline: none"
          placeholder="Start writing..."
        ></div>
      </div>

      <button class="jump-to-today-btn" id="jump-to-today-btn">
        <svg
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <line x1="12" y1="19" x2="12" y2="5"></line>
          <polyline points="5 12 12 5 19 12"></polyline>
        </svg>
        Jump to Today
      </button>
    </div>

    <!-- Slash Menu Moved to End of Body for Stacking Context Safety -->
    <div class="slash-menu" id="slash-menu"></div>

    <!-- HABIT TRACKER WIDGET -->
    <div class="habit-widget" id="habit-widget">
      <div class="habit-widget-header">
        <div class="habit-widget-title">
          <svg
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2.5"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <path
              d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"
            />
            <polyline points="14 2 14 8 20 8" />
            <path d="M9 13l2 2 4-4" />
          </svg>
          Habits
        </div>
        <div style="display: flex; gap: 4px">
          <button
            class="add-element-btn"
            id="toggle-habit-widget-btn"
            title="Minimize"
          >
            <svg
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <polyline points="4 14 10 14 10 20"></polyline>
              <polyline points="20 10 14 10 14 4"></polyline>
            </svg>
          </button>
          <button class="add-element-btn" id="add-habit-btn" title="Add Habit">
            <svg
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <line x1="12" y1="5" x2="12" y2="19"></line>
              <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg>
          </button>
        </div>
      </div>
      <div class="habit-widget-collapsed-icon">
        <!-- Simple Circular Icon representing the collapsed state -->
        <svg
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <path
            d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"
          />
          <polyline points="14 2 14 8 20 8" />
          <path d="M9 13l2 2 4-4" />
        </svg>
      </div>
      <div class="habit-list" id="habit-list">
        <!-- Habits injected here -->
      </div>
    </div>

    <!-- POMODORO TIMER WIDGET -->
    <div class="pomodoro-widget" id="pomodoro-widget">
      <div class="pomodoro-widget-header">
        <div class="pomodoro-widget-title">
          <svg
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2.5"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <circle cx="12" cy="12" r="10"></circle>
            <polyline points="12 6 12 12 16 14"></polyline>
          </svg>
          Focus
        </div>
        <div style="display: flex; gap: 4px">
          <button
            class="add-element-btn"
            id="toggle-pomodoro-widget-btn"
            title="Minimize"
          >
            <svg
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <polyline points="4 14 10 14 10 20"></polyline>
              <polyline points="20 10 14 10 14 4"></polyline>
            </svg>
          </button>
        </div>
      </div>

      <div class="pomodoro-widget-collapsed-icon">
        <!-- Default Icon -->
        <svg
          id="pomodoro-collapsed-default-icon"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2.5"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>

        <!-- Dynamic Timer Progress (Hidden by default) -->
        <div
          id="pomodoro-collapsed-progress-container"
          style="
            display: none;
            position: relative;
            width: 44px;
            height: 44px;
            align-items: center;
            justify-content: center;
          "
        >
          <svg
            width="44"
            height="44"
            viewBox="0 0 44 44"
            style="transform: rotate(-90deg)"
          >
            <circle
              cx="22"
              cy="22"
              r="18"
              fill="none"
              stroke="#e5e5ea"
              stroke-width="3"
            ></circle>
            <circle
              id="pomodoro-progress-circle"
              cx="22"
              cy="22"
              r="18"
              fill="none"
              stroke="#ff3b30"
              stroke-width="3"
              stroke-dasharray="113.1"
              stroke-dashoffset="0"
              stroke-linecap="round"
            ></circle>
          </svg>
          <span
            id="pomodoro-collapsed-time-text"
            style="
              position: absolute;
              font-size: 14px;
              font-weight: 700;
              color: #1c1c1e;
            "
            >25</span
          >
        </div>
      </div>

      <div class="pomodoro-content">
        <div class="timer-display" id="pomodoro-timer-display">25:00</div>
        <div class="timer-controls">
          <button class="timer-btn timer-btn-primary" id="pomodoro-start-btn">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
              <path d="M8 5v14l11-7z"></path>
            </svg>
            Start
          </button>
          <button
            class="timer-btn timer-btn-secondary hidden"
            id="pomodoro-pause-btn"
            title="Pause"
          >
            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
              <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path>
            </svg>
          </button>
          <button
            class="timer-btn timer-btn-secondary"
            id="pomodoro-reset-btn"
            title="Reset"
          >
            <svg
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path
                d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"
              ></path>
              <path d="M3 3v5h5"></path>
            </svg>
          </button>
          <button
            class="timer-btn timer-btn-secondary"
            id="pomodoro-pip-btn"
            title="Detach Timer (PiP)"
          >
            <svg
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <rect x="2" y="4" width="20" height="16" rx="2" ry="2"></rect>
              <path d="M12 12h7v5h-7z"></path>
            </svg>
          </button>
        </div>

        <!-- Hidden Elements for PiP -->
        <div class="hidden-pip-elements" style="display: none">
          <canvas id="pomodoro-pip-canvas" width="320" height="180"></canvas>
          <video id="pomodoro-pip-video" muted autoplay playsinline></video>
          <!-- NEW: Subtask PiP Elements -->
          <canvas id="subtask-pip-canvas" width="320" height="180"></canvas>
          <video id="subtask-pip-video" muted autoplay playsinline></video>
        </div>

        <div
          style="
            width: 100%;
            display: flex;
            justify-content: flex-end;
            margin-bottom: -10px;
          "
        >
          <button
            class="edit-preset-btn"
            id="pomodoro-edit-presets-btn"
            title="Edit Presets"
          >
            <svg
              width="14"
              height="14"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path
                d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"
              ></path>
              <path
                d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"
              ></path>
            </svg>
          </button>
        </div>

        <div class="preset-times" id="pomodoro-presets">
          <!-- Presets will be rendered by JS -->
        </div>

        <div class="custom-time-input">
          <input
            type="number"
            id="pomodoro-custom-input"
            placeholder="Min"
            min="1"
            max="180"
          />
          <button id="pomodoro-set-custom-btn">Set</button>
        </div>
      </div>
    </div>
    <div class="modal-overlay" id="habit-modal-overlay">
      <div class="modal" id="habit-modal">
        <h2 id="habit-modal-title">New Habit</h2>
        <input type="hidden" id="habit-id" />
        <div class="form-group">
          <label for="habit-name">Habit Name</label>
          <input type="text" id="habit-name" placeholder="e.g., Read for 30m" />
        </div>
        <div class="form-group">
          <label>Color</label>
          <div class="color-selector" id="habit-color-selector"></div>
        </div>
        <div class="modal-actions">
          <button
            id="delete-habit-btn"
            class="hidden"
            style="background-color: var(--danger-color); color: white"
          >
            Delete
          </button>
          <button id="cancel-habit-btn">Cancel</button>
          <button
            id="save-habit-btn"
            style="background-color: var(--primary-color); color: white"
          >
            Save
          </button>
        </div>
      </div>
    </div>

    <!-- Recurrence Confirmation Modal -->
    <div class="modal-overlay" id="recurrence-options-modal">
      <div class="modal">
        <h2 id="recurrence-options-title">Edit Recurring Task</h2>
        <p
          id="recurrence-options-desc"
          style="color: var(--text-secondary); margin-bottom: 20px"
        >
          This is a recurring task. How would you like to apply your changes?
        </p>
        <div class="modal-actions" style="flex-direction: column; gap: 10px">
          <button id="recurrence-option-this" style="width: 100%">
            This Event Only
          </button>
          <button id="recurrence-option-future" style="width: 100%">
            All Future Events
          </button>
          <button
            id="recurrence-option-cancel"
            style="width: 100%; background-color: var(--bg-hover)"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>

    <!-- Confirmation Modal -->
    <div class="modal-overlay" id="confirmation-modal">
      <div class="modal confirmation-modal-content">
        <h2 id="confirmation-title">Confirm Action</h2>
        <p id="confirmation-desc">Are you sure?</p>
        <div class="modal-actions">
          <button id="confirmation-btn-cancel" class="modal-btn cancel">
            Cancel
          </button>
          <button id="confirmation-btn-confirm" class="modal-btn destructive">
            Delete
          </button>
        </div>
      </div>
    </div>

    <!-- Analytics Widget -->
    <div id="analytics-widget" class="analytics-widget hidden">
      <div class="analytics-header">
        <div class="analytics-title">
          <svg
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <path d="M3 3v18h18" />
            <path d="M18.7 8l-5.1 5.2-2.8-2.7L7 14.3" />
          </svg>
          Analytics & Insights
        </div>
        <div class="analytics-controls">
          <select id="analytics-range-selector">
            <option value="7">Last 7 Days</option>
            <option value="30">Last 30 Days</option>
            <option value="thisMonth">This Month</option>
          </select>
          <button id="close-analytics-btn" class="icon-btn" aria-label="Close">
            <svg
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        </div>
      </div>

      <div class="analytics-content">
        <!-- Overview Cards -->
        <div class="analytics-grid">
          <div class="analytics-card" id="card-productivity">
            <h3>Productivity Score</h3>
            <div class="big-metric" id="metric-productivity">0%</div>
            <div class="sub-metric">Based on task completion</div>
          </div>
          <div class="analytics-card" id="card-focus">
            <h3>Focus Time</h3>
            <div class="big-metric" id="metric-focus">0h</div>
            <div class="sub-metric" id="metric-focus-count">0 sessions</div>
          </div>
          <div class="analytics-card" id="card-habits">
            <h3>Habit Consistency</h3>
            <div class="big-metric" id="metric-habits">0%</div>
            <div class="sub-metric">Overall stickiness</div>
          </div>
        </div>

        <!-- Charts Row -->
        <div class="analytics-charts-row">
          <div class="analytics-chart-container full-width">
            <h3>Daily Activity (Minutes)</h3>
            <div id="activity-chart" class="chart-box activity-chart"></div>
          </div>
        </div>

        <div class="analytics-charts-row">
          <div class="analytics-chart-container">
            <h3>Time Distribution</h3>
            <div id="category-chart" class="chart-box donut-chart"></div>
            <div id="category-legend" class="chart-legend"></div>
          </div>
          <div class="analytics-chart-container">
            <h3>Top Habits</h3>
            <ul id="top-habits-list" class="analytics-list"></ul>
          </div>
        </div>
      </div>
    </div>

    <style>
      /* --- ANALYTICS WIDGET --- */
      .analytics-widget {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(1);
        width: 90%;
        max-width: 1200px;
        height: 85vh;
        background-color: var(--bg-color);
        border: 1px solid var(--border-color);
        border-radius: 24px;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        z-index: 2000;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out,
          visibility 0.2s;
        backdrop-filter: blur(20px);
        visibility: visible;
      }

      .analytics-widget.hidden {
        visibility: hidden;
        opacity: 0;
        pointer-events: none;
        transform: translate(-50%, -48%) scale(0.95);
      }

      .analytics-header {
        padding: 1.5rem 2rem;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: rgba(255, 255, 255, 0.03);
      }

      .analytics-title {
        font-size: 1.5rem;
        font-weight: 700;
        display: flex;
        align-items: center;
        gap: 0.75rem;
        color: var(--text-color);
      }

      .analytics-controls {
        display: flex;
        gap: 1rem;
        align-items: center;
      }

      #analytics-range-selector {
        padding: 0.5rem 1rem;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        background: var(--bg-secondary);
        color: var(--text-color);
        font-size: 0.9rem;
        cursor: pointer;
      }

      .analytics-content {
        padding: 2rem;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 2rem;
        flex: 1;
      }

      .analytics-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 1.5rem;
      }

      .analytics-card {
        background: var(--bg-hover);
        padding: 1.5rem;
        border-radius: 16px;
        border: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        transition: transform 0.2s;
      }
      .analytics-card:hover {
        transform: translateY(-2px);
      }

      .analytics-card h3 {
        font-size: 1rem;
        font-weight: 600;
        color: var(--text-secondary);
        margin: 0;
      }

      .big-metric {
        font-size: 3rem;
        font-weight: 800;
        color: var(--text-color);
        line-height: 1.1;
      }

      .sub-metric {
        font-size: 0.9rem;
        color: var(--secondary-color);
      }

      .analytics-charts-row {
        display: flex;
        gap: 1.5rem;
        flex-wrap: wrap;
      }

      .analytics-chart-container {
        flex: 1;
        min-width: 300px;
        background: var(--bg-hover);
        padding: 1.5rem;
        border-radius: 16px;
        border: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .analytics-chart-container.full-width {
        flex-basis: 100%;
      }

      .chart-box {
        flex: 1;
        min-height: 250px;
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      /* SVG Chart Styles */
      .bar-chart-svg {
        width: 100%;
        height: 100%;
        overflow: visible;
      }
      .bar-rect {
        transition: height 0.3s, y 0.3s;
        rx: 4;
      }
      .bar-rect:hover {
        fill-opacity: 0.8 !important;
      }
      .bar-label {
        font-size: 12px;
        fill: var(--text-secondary);
        text-anchor: middle;
      }

      .donut-chart {
        display: flex;
        gap: 2rem;
        align-items: center;
        justify-content: center;
      }
      .donut-svg {
        max-width: 200px;
        max-height: 200px;
      }
      .chart-legend {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        font-size: 0.9rem;
        color: var(--text-secondary);
      }
      .legend-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .legend-color {
        width: 12px;
        height: 12px;
        border-radius: 3px;
      }

      .analytics-list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      .analytics-list li {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem;
        background: rgba(0, 0, 0, 0.03);
        border-radius: 8px;
        font-weight: 500;
        color: var(--text-color);
      }
      body.dark-mode .analytics-list li {
        background: rgba(255, 255, 255, 0.05);
      }

      /* --- TOPIC NOTES TAGS --- */
      .topic-category-wrapper {
        border-bottom: 1px solid var(--border-color); /* Optional visual cue */
        transition: all 0.2s;
      }
      .topic-category-wrapper:focus-within {
        background-color: rgba(0, 0, 0, 0.02);
      }
      .topic-tag {
        display: inline-flex;
        align-items: center;
        padding: 2px 8px;
        background-color: rgba(0, 0, 0, 0.05);
        border-radius: 4px;
        font-size: 0.85rem;
        color: var(--text-color);
        gap: 4px;
        user-select: none;
        transition: background-color 0.2s;
      }
      .topic-tag:hover {
        background-color: rgba(0, 0, 0, 0.1);
      }
      .topic-tag-remove {
        cursor: pointer;
        opacity: 0.4;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 14px;
        height: 14px;
        border-radius: 50%;
      }
      .topic-tag-remove:hover {
        opacity: 1;
        background-color: rgba(0, 0, 0, 0.1);
        color: var(--danger-color);
      }
      /* Dark Mode overrides if needed */
      body.dark-mode .topic-tag {
        background-color: rgba(255, 255, 255, 0.1);
      }
      body.dark-mode .topic-tag:hover {
        background-color: rgba(255, 255, 255, 0.15);
      }
    </style>
    <script>
      // ... (Rest of the script)
      document.addEventListener("DOMContentLoaded", () => {
        // --- DOM Elements ---
        const svg = document.getElementById("clock-svg");
        const clockContainer = document.querySelector(".clock-container");
        const tasksContainer = document.getElementById("tasks-container");
        const labelsContainer = document.getElementById("labels-container");
        const previewArc = document.getElementById("preview-arc");
        const handsContainer = document.getElementById("hands-container");
        const hourHand = document.getElementById("hour-hand");
        const minuteHand = document.getElementById("minute-hand");
        const secondHand = document.getElementById("second-hand");
        const ampmControls = document.getElementById("ampm-controls");
        const viewModeControls = document.getElementById("view-mode-controls");
        const blocksViewContainer = document.getElementById(
          "blocks-view-container"
        );
        const yesterdayBlock = document.getElementById("yesterday-block");
        const todayBlock = document.getElementById("today-block");
        const tomorrowBlock = document.getElementById("tomorrow-block");
        const currentTimeLine = document.getElementById("current-time-line");
        const modal = document.getElementById("task-modal");
        const modalTitle = document.getElementById("modal-title");
        const taskIdInput = document.getElementById("task-id");
        const taskNameInput = document.getElementById("task-name");
        const colorSelector = document.getElementById("color-selector");
        const saveTaskBtn = document.getElementById("save-task-btn");
        const cancelTaskBtn = document.getElementById("cancel-task-btn");
        const deleteTaskBtn = document.getElementById("delete-task-btn");
        const taskStartTimeInput = document.getElementById("task-start-time");
        const taskEndTimeInput = document.getElementById("task-end-time");
        const taskCompletedCheckbox = document.getElementById(
          "task-completed-checkbox"
        );
        const taskRecursiveToggle = document.getElementById(
          "task-recursion-toggle"
        );
        const calendarMonthEl = document.getElementById("calendar-month");
        const calendarYearEl = document.getElementById("calendar-year");
        const prevMonthBtn = document.getElementById("prev-month-btn");
        const nextMonthBtn = document.getElementById("next-month-btn");
        const calendarDatesEl = document.getElementById("calendar-dates");
        const calendarWeekdaysEl = document.getElementById("calendar-weekdays");
        const dragLabelsContainer = document.getElementById(
          "drag-labels-container"
        );
        const dragTimeLabel = document.getElementById("drag-time-label");

        // Progress Widget and Bar Elements
        const progressWidget = document.getElementById("progress-widget");
        const progressWidgetCounter = document.getElementById(
          "progress-widget-counter"
        );
        const progressWidgetCompleteBtn = document.getElementById(
          "progress-widget-complete"
        );
        const progressWidgetTaskName = document.getElementById(
          "progress-widget-task-name"
        );
        const progressBarContainer = document.querySelector(
          ".progress-bar-container"
        );
        const progressBarElapsed = document.getElementById(
          "progress-bar-elapsed"
        );
        const progressBarPercentage = document.getElementById(
          "progress-bar-percentage"
        );

        // ADD THIS LINE
        const progressWidgetTaskTime = document.getElementById(
          "progress-widget-task-time"
        );

        // ADD these new constants for the integrated feature
        const taskListCards = document.getElementById("task-list-cards");
        const taskListCloseBtn = document.getElementById("task-list-close-btn");

        // NEW: Format Toggle
        const formatToggleGroup = document.getElementById(
          "format-toggle-group"
        );
        const formatToggleText = formatToggleGroup.querySelector(
          ".format-toggle-text"
        );

        // NEW: Digital Clock Elements
        const digitalClockDisplay = document.getElementById(
          "digital-clock-display"
        );
        const digitalFormatToggle = document.getElementById(
          "digital-format-toggle"
        );

        // Recurrence Confirmation Modal
        const recurrenceModal = document.getElementById(
          "recurrence-options-modal"
        );
        const recurrenceTitle = document.getElementById(
          "recurrence-options-title"
        );
        const recurrenceDesc = document.getElementById(
          "recurrence-options-desc"
        );
        const recurrenceBtnThis = document.getElementById(
          "recurrence-option-this"
        );
        const recurrenceBtnFuture = document.getElementById(
          "recurrence-option-future"
        );
        const recurrenceBtnCancel = document.getElementById(
          "recurrence-option-cancel"
        );

        // --- CODE TO ADD to the 'DOM Elements' section ---
        const notesWidget = document.getElementById("notes-widget");
        const notesContainer = document.getElementById(
          "notes-content-container"
        );
        const jumpToTodayBtn = document.getElementById("jump-to-today-btn");

        const notesToolbar = document.getElementById("notes-toolbar");

        // --- State ---
        let clockMode = localStorage.getItem("clockMode") || "24h",
          ampm = "am",
          viewMode = "clock",
          use12HourLabels = false; // NEW: Toggle state for 24h view labels
        let digitalClockFormat =
          localStorage.getItem("digitalClockFormat") || "24h"; // NEW state
        let tasksByDate =
          JSON.parse(localStorage.getItem("clockTasksPro")) || {};
        let selectedDate = new Date();
        let displayedDate = new Date();
        let isCalendarCollapsed =
          localStorage.getItem("calendarWidgetCollapsed") === "true";
        let isDragging = false;
        let dragStartHour = null;
        let dragEndHour = null;
        var lastDragHour = null; // NEW: Track previous hour to detect cyclic drags
        var dragLoops = 0; // NEW: Count full circles
        let hoveredTaskId = null; // Hover state

        // --- RECURRING TASKS LOGIC ---
        let recurringTasks = JSON.parse(
          localStorage.getItem("clockRecurringTasks") || "[]"
        );
        let isBlockDragging = false,
          blockDragStartHour = null;
        // NEW State for generalized block dragging
        let activeDragBlock = null;
        let activeDragDate = null;

        // State for progress widget
        let currentWidgetTaskId = null;

        // --- CODE TO ADD to the 'State' section ---
        let notesByDate = {};
        let currentNotesDate = new Date(); // The date the notes widget is focused on
        let hasInitialNotesScrollHappened = false; // Flag for one-time scroll
        let todayObserver = null; // To track if today's note is visible
        let activeNoteEditor = null; // To track the currently focused editor
        let forcedFocusTaskId = null; // NEW: Track manually focused task for widget
        let activePiPSubtaskId = null; // NEW: Track subtask in PiP

        // --- Habit Tracker State ---
        let habits = JSON.parse(localStorage.getItem("clockHabits")) || [];
        /* Data Structure:
           {
             id: "habit-123...",
             name: "Read",
             color: "#FF9500",
             history: { "2023-12-01": true, "2023-12-05": true } // Date keys standard YYYY-MM-DD
           }
        */

        // --- Constants ---
        const CENTER_X = 200,
          CENTER_Y = 200,
          RADIUS = 180,
          TASK_PIE_RADIUS = 180;
        const COLORS = [
          "#FF9500",
          "#FF2D55",
          "#AF52DE",
          "#5856D6",
          "#34C759",
          "#00C7BE",
        ];
        const TIME_OF_DAY_SEGMENTS_AM = [
          { start: 0, end: 3, image: "https://i.postimg.cc/L8PSs5c3/1.webp" },
          {
            start: 3,
            end: 6,
            image: "https://i.postimg.cc/fTrHrvrM/Clock-Periphery.webp",
          },
          { start: 6, end: 9, image: "https://i.postimg.cc/YCF7S058/3.webp" },
          { start: 9, end: 12, image: "https://i.postimg.cc/zGhNfvsj/4.webp" },
        ].map((s) => ({ ...s, color: "#fff" }));
        const TIME_OF_DAY_SEGMENTS_PM = [
          { start: 0, end: 3, image: "https://i.postimg.cc/zGhNfvsj/4.webp" },
          { start: 3, end: 6, image: "https://i.postimg.cc/YCF7S058/3.webp" },
          { start: 6, end: 9, image: "https://i.postimg.cc/zX655Kct/7.webp" },
          { start: 9, end: 12, image: "https://i.postimg.cc/RZtm0hk1/8.webp" },
        ].map((s) => ({ ...s, color: "#fff" }));
        const SVG_NS = "http://www.w3.org/2000/svg";
        const COMPLETED_COLOR =
          getComputedStyle(document.documentElement)
            .getPropertyValue("--completed-color")
            .trim() || "#D1D1D6";
        const UNCOMPLETED_PAST_COLOR =
          getComputedStyle(document.documentElement)
            .getPropertyValue("--uncompleted-past-color")
            .trim() || "#A1A1A6";

        // --- Date & Time Helpers ---
        const getDateKey = (date) =>
          `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(
            2,
            "0"
          )}-${String(date.getDate()).padStart(2, "0")}`;
        const isToday = (date) => getDateKey(date) === getDateKey(new Date());
        const isPast = (date) => getDateKey(date) < getDateKey(new Date());
        const polarToCartesian = (cx, cy, r, angle) => ({
          x: cx + r * Math.cos(((angle - 90) * Math.PI) / 180),
          y: cy + r * Math.sin(((angle - 90) * Math.PI) / 180),
        });
        const describePieSlice = (x, y, r, startAngle, endAngle) => {
          if (Math.abs(startAngle - endAngle) < 1e-9) return "";
          if (Math.abs(endAngle - startAngle) >= 359.999)
            endAngle = startAngle + 359.999;
          const startPoint = polarToCartesian(x, y, r, startAngle);
          const endPoint = polarToCartesian(x, y, r, endAngle);
          let angleDiff = endAngle - startAngle;
          if (angleDiff < 0) angleDiff += 360;
          const largeArcFlag = angleDiff <= 180 ? "0" : "1";
          const d = [
            "M",
            x,
            y,
            "L",
            startPoint.x,
            startPoint.y,
            "A",
            r,
            r,
            0,
            largeArcFlag,
            "1",
            endPoint.x,
            endPoint.y,
            "Z",
          ].join(" ");
          return d;
        };
        const getHourFromMouseEvent = (e) => {
          const rect = svg.getBoundingClientRect();
          const x = e.clientX - rect.left,
            y = e.clientY - rect.top;
          const svgX = (x / rect.width) * 400,
            svgY = (y / rect.height) * 400;
          const angle =
            ((Math.atan2(svgY - CENTER_Y, svgX - CENTER_X) * 180) / Math.PI +
              90 +
              360) %
            360;
          const totalHours = clockMode === "24h" ? 24 : 12;
          const hour = (angle / 360) * totalHours;
          let roundedHour = Math.round(hour * 12) / 12;
          if (clockMode === "12h" && Math.abs(roundedHour - 12) < 0.001) {
            roundedHour = 0;
          }
          return roundedHour;
        };
        const formatHourToTimeInput = (hour) => {
          let h = Math.floor(hour),
            m = Math.round((hour % 1) * 60);
          if (m === 60) {
            h = (h + 1) % 24;
            m = 0;
          }
          return `${String(h).padStart(2, "0")}:${String(m).padStart(2, "0")}`;
        };
        const formatHourToAMPM = (hour24) => {
          if (hour24 == null) return "";
          let h = Math.floor(hour24),
            m = Math.round((hour24 % 1) * 60);
          if (m === 60) {
            h = h + 1;
            m = 0;
          }
          h = h % 24;
          const period = h >= 12 ? "PM" : "AM";
          const h12 = h % 12 === 0 ? 12 : h % 12;
          return `${h12}:${String(m).padStart(2, "0")} ${period}`;
        };
        // --- Tooltip Helpers (Global) ---
        function createTooltip() {
          const tooltip = document.createElement("div");
          tooltip.id = "task-tooltip";
          tooltip.className = "task-tooltip";
          document.body.appendChild(tooltip);
          return tooltip;
        }

        function updateTooltipPosition(e, tooltip) {
          const x = e.clientX + 15;
          const y = e.clientY + 15;

          // Prevent overflow off screen edges
          const rect = tooltip.getBoundingClientRect();
          let finalX = x;
          let finalY = y;

          if (finalX + rect.width > window.innerWidth) {
            finalX = e.clientX - rect.width - 10;
          }
          if (finalY + rect.height > window.innerHeight) {
            finalY = e.clientY - rect.height - 10;
          }

          tooltip.style.left = `${finalX}px`;
          tooltip.style.top = `${finalY}px`;
        }

        const parseTimeInputToHour = (timeString) => {
          const [h, m] = timeString.split(":").map(Number);
          return h + m / 60;
        };

        // --- Main View Controller ---
        function renderAppView() {
          const isBlocksVisible = clockMode === "24h" && viewMode === "blocks";
          clockContainer.classList.toggle("hidden", isBlocksVisible);
          blocksViewContainer.classList.toggle("hidden", !isBlocksVisible);
          if (isBlocksVisible) {
            renderBlocksView();
          } else {
            renderClockFace();
            renderTimeOfDayLabels();
            renderTasks();
            updateFormatToggleVisibility(); // Ensure toggle is shown/hidden appropriately
          }
          updateClockHands();
          updateProgressWidget(); // Ensure widget visibility is correct after state changes
        }

        // --- Clock Render Functions ---
        function updateFormatToggleVisibility() {
          // Only show in 24h clock mode
          if (clockMode === "24h" && viewMode === "clock") {
            formatToggleGroup.style.display = "block";
            formatToggleText.textContent = use12HourLabels ? "12H" : "24H";
          } else {
            formatToggleGroup.style.display = "none";
          }
        }

        /**
         * Returns all tasks for a specific date, merging one-off tasks and valid
         * recurring instances (applying exceptions).
         */
        function getTasksForDate(date) {
          const dateKey = getDateKey(date);
          const oneOffTasks = tasksByDate[dateKey] || [];
          const dateTs = new Date(dateKey + "T00:00:00").getTime();

          const recurringInstances = recurringTasks
            .filter((rt) => {
              // 1. Start Date Check
              const startTs = new Date(
                rt.recurrenceStart + "T00:00:00"
              ).getTime();
              if (dateTs < startTs) return false;

              // 2. End Date Check
              if (
                rt.recurrenceEnd &&
                dateTs > new Date(rt.recurrenceEnd + "T00:00:00").getTime()
              )
                return false;

              // 3. Exception Check (is this specific date excluded?)
              if (rt.exceptions && rt.exceptions[dateKey]) return false;

              return true;
            })
            .map((rt) => ({
              ...rt,
              id: rt.id + "_" + dateKey, // Virtual ID for the instance
              originalId: rt.id, // Reference to parent
              isRecurringInstance: true,
              dateKey: dateKey, // Helper for context
            }));

          return [...oneOffTasks, ...recurringInstances];
        }

        function renderClockFace() {
          const t = document.getElementById("ticks-container"),
            e = document.getElementById("numbers-container");
          (t.innerHTML = ""), (e.innerHTML = "");
          const n = "24h" === clockMode ? 24 : 12,
            o = "12h" === clockMode ? 6 : 12;

          const now = new Date();
          // Calculate current absolute hour (0-24)
          const currentHour = now.getHours() + now.getMinutes() / 60;

          // Determine relative date status
          const isTodayDate = isToday(selectedDate);
          const isPastDate = isPast(selectedDate);
          // Future date check: not today and not past
          const isFutureDate = !isTodayDate && !isPastDate;

          for (let r = 0; r < n * o; r++) {
            const s = r * (360 / (n * o)),
              a = r % o == 0,
              i = document.createElementNS(SVG_NS, "line"),
              l = polarToCartesian(CENTER_X, CENTER_Y, RADIUS, s),
              c = polarToCartesian(
                CENTER_X,
                CENTER_Y,
                RADIUS - (a ? 10 : 5),
                s
              );
            // --- Tick Logic ---
            // Calc logic hour for this tick (0..24 or 0..12)
            // n * o = total ticks (e.g., 72).
            // tickHour = (r / totalTicks) * n
            let tickHour = (r / (n * o)) * n;

            // Adjust for 12h mode absolute time
            if (clockMode === "12h") {
              if (ampm === "pm") {
                // PM: 0 is 12 (Noon), 1 is 1 (13), etc.
                // But mathematically 0..12 maps to 0..12 in the circle.
                // If PM, we offset by 12.
                tickHour += 12;
              }
            }

            let isPastTick = false;
            if (isPastDate) {
              isPastTick = true;
            } else if (isFutureDate) {
              isPastTick = false;
            } else {
              // Today
              // EDGE CASE: The "12" mark at the top (index 0).
              // In 12h AM mode, index 0 is 0.0h. Current is 11.9, so 0 < 11.9 (Past).
              // But visually it is "12 o'clock".
              // User wants it active if upcoming.
              // If r === 0 (Top tick):
              // In 12h AM: It is 0 (Midnight Start) AND 12 (Noon End).
              // If we are at 11:58 AM, we haven't reached Noon yet. So it should be active.
              // In 12h PM: It is 12 (Noon Start) AND 24 (Midnight End).
              // If we are at 11:58 PM, we haven't reached Midnight yet. Active.

              if (clockMode === "12h" && r === 0) {
                // Always treat top tick as "End of Cycle" (12 or 24) for comparison
                // So compared against currentHour, it is > current.
                // AM: Treat as 12. currentHour < 12? Active.
                // PM: Treat as 24. currentHour < 24? Active.
                isPastTick = false; // Always future until we pass it (but we never pass 12/24 in that period)
              } else {
                isPastTick = tickHour < currentHour;
              }
            }

            i.setAttribute(
              "class",
              (a ? "clock-tick" : "clock-tick-small") +
                (isPastTick ? " past" : "")
            ),
              i.setAttribute("x1", l.x),
              i.setAttribute("y1", l.y),
              i.setAttribute("x2", c.x),
              i.setAttribute("y2", c.y),
              t.appendChild(i);
          }

          for (let d = 0; d < n; d++) {
            const h = d * (360 / n),
              p = polarToCartesian(CENTER_X, CENTER_Y, RADIUS - 25, h),
              u = "12h" === clockMode ? (0 === d ? 12 : d) : d,
              m = document.createElementNS(SVG_NS, "text");

            // Logic for Numbers
            // d is 0..11 or 0..23
            let numHour = d;
            if (clockMode === "12h" && ampm === "pm") {
              numHour += 12;
            }

            let isPastNum = false;
            let isCurrentNum = false;

            if (isPastDate) {
              isPastNum = true;
            } else if (isFutureDate) {
              isPastNum = false;
            } else {
              // Today
              // Special 12 logic again?
              // Number 0 (displays "12").
              // If 11:58 AM, currentHour = 11.9.
              // numHour (0) < 11.9. So "12" would be past if treated as 0.
              // User wants "12" to be active if upcoming.
              if (clockMode === "12h" && d === 0) {
                // Treat top "12" as end of cycle (Future)
                isPastNum = false;
              } else {
                // Standard check
                // "11" should be current if we are in 11.x
                // numHour == floor(currentHour)
                // 11 == floor(11.96) -> True.
                if (Math.floor(currentHour) === numHour) {
                  isCurrentNum = true;
                } else {
                  isPastNum = numHour < currentHour;
                }
              }
            }

            let classes = "clock-number";

            // --- NEW: Toggle Logic ---
            let displayHour = u; // Default to standard u (0-23 or 0-11)
            let isPM = false;

            if (clockMode === "24h" && use12HourLabels) {
              // Convert 0-23 to 1-12 AM/PM style
              // 0 -> 12, 1 -> 1, 12 -> 12, 13 -> 1, 23 -> 11

              // Standard conversion
              let h12 = numHour % 12;
              if (h12 === 0) h12 = 12;
              displayHour = h12;

              // Determine if PM (>=12)
              if (numHour >= 12) {
                isPM = true;
                classes += " pm-number";
              }
            }

            if (isCurrentNum) classes += " current-hour";
            else if (isPastNum) classes += " past";

            m.setAttribute("class", classes),
              m.setAttribute("x", p.x),
              m.setAttribute("y", p.y),
              (m.textContent = displayHour),
              e.appendChild(m);
          }
        }
        function renderTimeOfDayLabels() {
          const t = document.getElementById("time-of-day-container");
          (t.innerHTML = ""), t.classList.toggle("hidden", "24h" === clockMode);
          if ("24h" === clockMode) return;
          const e =
            "am" === ampm ? TIME_OF_DAY_SEGMENTS_AM : TIME_OF_DAY_SEGMENTS_PM;
          e.forEach((n) => {
            const o = (n.start / 12) * 360,
              r = (n.end / 12) * 360,
              s = o + (r - o) / 2,
              a = RADIUS + 1,
              i = RADIUS + 18,
              l = polarToCartesian(CENTER_X, CENTER_Y, i, o),
              c = polarToCartesian(CENTER_X, CENTER_Y, i, r),
              d = polarToCartesian(CENTER_X, CENTER_Y, a, r),
              h = polarToCartesian(CENTER_X, CENTER_Y, a, o),
              p = [
                `M ${l.x} ${l.y}`,
                `A ${i} ${i} 0 ${n.end - n.start <= 6 ? "0" : "1"} 1 ${c.x} ${
                  c.y
                }`,
                `L ${d.x} ${d.y}`,
                `A ${a} ${a} 0 ${n.end - n.start <= 6 ? "0" : "1"} 0 ${h.x} ${
                  h.y
                }`,
                "Z",
              ].join(" "),
              u = document.createElementNS(SVG_NS, "path");
            u.setAttribute("d", p),
              u.setAttribute("class", "time-of-day-arc"),
              u.setAttribute("fill", n.color),
              t.appendChild(u);
            const m = RADIUS + 10,
              g = polarToCartesian(CENTER_X, CENTER_Y, m, s),
              k = 16,
              v = document.createElementNS(SVG_NS, "image");
            v.setAttributeNS("http://www.w3.org/1999/xlink", "href", n.image),
              v.setAttribute("width", k),
              v.setAttribute("height", k),
              v.setAttribute("x", g.x - k / 2),
              v.setAttribute("y", g.y - k / 2),
              v.setAttribute("preserveAspectRatio", "xMidYMid meet"),
              t.appendChild(v);
          });
        }

        function renderTasks() {
          // Clear previous renders
          tasksContainer.innerHTML = "";
          labelsContainer.innerHTML = "";

          const tasksForDay = getTasksForDate(selectedDate);
          const now = new Date();
          const currentHour24 =
            now.getHours() + now.getMinutes() / 60 + now.getSeconds() / 3600;

          // Filter tasks based on AM/PM mode if necessary
          const visibleTasks = tasksForDay.filter((task) => {
            if (clockMode === "24h") {
              return true;
            }
            // For 12h mode, check if the task overlaps with the current AM/PM period
            const periodStart = ampm === "am" ? 0 : 12;
            const periodEnd = ampm === "am" ? 12 : 24;
            return task.startHour < periodEnd && task.endHour > periodStart;
          });

          visibleTasks.forEach((task) => {
            const totalHours = clockMode === "24h" ? 24 : 12;
            let sliceStartHour = task.startHour;
            let sliceEndHour = task.endHour;

            // Adjust hours for 12h view
            if (clockMode === "12h") {
              const periodStart = ampm === "am" ? 0 : 12;
              const periodEnd = ampm === "am" ? 12 : 24;
              sliceStartHour = Math.max(task.startHour, periodStart);
              sliceEndHour = Math.min(task.endHour, periodEnd);
              if (ampm === "pm") {
                sliceStartHour -= 12;
                sliceEndHour -= 12;
              }
            }

            // Handle tasks that cross the midnight/noon boundary in 12h mode
            if (sliceEndHour <= 0 && task.endHour > 0) {
              sliceEndHour = totalHours;
            }

            const startAngle = (sliceStartHour / totalHours) * 360;
            const endAngle = (sliceEndHour / totalHours) * 360;

            // Determine the color based on task state
            let sliceFillColor;
            let sliceFillOpacity = "0.4"; // Default for active tasks

            const isTaskInPast =
              isPast(selectedDate) ||
              (isToday(selectedDate) && currentHour24 >= task.endHour);

            if (task.completed) {
              sliceFillColor = COMPLETED_COLOR;
              sliceFillOpacity = "0.6";
            } else if (isTaskInPast) {
              sliceFillColor = UNCOMPLETED_PAST_COLOR;
              sliceFillOpacity = "0.6";
            } else {
              sliceFillColor = task.color;
            }

            // --- Create the main task pie slice ---
            const taskSlicePath = document.createElementNS(SVG_NS, "path");
            taskSlicePath.setAttribute("class", "task-pie-slice");
            taskSlicePath.setAttribute(
              "d",
              describePieSlice(
                CENTER_X,
                CENTER_Y,
                TASK_PIE_RADIUS,
                startAngle,
                endAngle
              )
            );
            taskSlicePath.setAttribute("fill", sliceFillColor);
            taskSlicePath.setAttribute("fill-opacity", sliceFillOpacity);
            taskSlicePath.addEventListener("click", () =>
              showModal(task, selectedDate)
            );
            tasksContainer.appendChild(taskSlicePath);

            // --- Create a progress overlay for ongoing, uncompleted tasks ---
            const isTaskOngoing =
              isToday(selectedDate) &&
              currentHour24 > task.startHour &&
              currentHour24 < task.endHour;
            if (!task.completed && isTaskOngoing) {
              let currentHourInSlice = currentHour24;
              let showProgress = false;

              if (clockMode === "12h") {
                // Only show progress if it's the correct AM/PM period
                if (
                  !(
                    (ampm === "am" && currentHour24 >= 12) ||
                    (ampm === "pm" && currentHour24 < 12)
                  )
                ) {
                  if (ampm === "pm") {
                    currentHourInSlice -= 12;
                  }
                  if (currentHourInSlice > sliceStartHour) {
                    showProgress = true;
                  }
                }
              } else {
                // 24h mode
                showProgress = true;
              }

              if (showProgress) {
                const progressEndAngle =
                  (currentHourInSlice / totalHours) * 360;
                const progressPath = document.createElementNS(SVG_NS, "path");
                progressPath.setAttribute(
                  "d",
                  describePieSlice(
                    CENTER_X,
                    CENTER_Y,
                    TASK_PIE_RADIUS,
                    startAngle,
                    progressEndAngle
                  )
                );
                progressPath.setAttribute("fill", UNCOMPLETED_PAST_COLOR);
                progressPath.setAttribute("fill-opacity", "0.6");
                progressPath.setAttribute("pointer-events", "none");
                tasksContainer.appendChild(progressPath);
              }
            }

            // --- Create task labels and checkbox ---
            const labelAngle =
              startAngle +
              ((endAngle <= startAngle ? endAngle + 360 : endAngle) -
                startAngle) /
                2;

            // --- Hover & Layout Constants ---
            const SAFE_RADIUS = 60;
            const CHECKBOX_HOVER_RADIUS = SAFE_RADIUS - 20;
            const isFlipped = labelAngle > 90 && labelAngle < 270;

            // Defines the default position (0.55 radius)
            const labelPos = polarToCartesian(
              CENTER_X,
              CENTER_Y,
              TASK_PIE_RADIUS * 0.55,
              labelAngle
            );
            const safePos = polarToCartesian(
              CENTER_X,
              CENTER_Y,
              SAFE_RADIUS,
              labelAngle
            );
            const checkboxHoverPos = polarToCartesian(
              CENTER_X,
              CENTER_Y,
              CHECKBOX_HOVER_RADIUS,
              labelAngle
            );

            let textRotation = labelAngle - 90;
            if (labelAngle > 90 && labelAngle < 270) {
              textRotation += 180;
            }

            const labelGroup = document.createElementNS(SVG_NS, "g");
            labelGroup.setAttribute("class", "task-label-group");
            labelGroup.addEventListener("click", () =>
              showModal(task, selectedDate)
            );

            const taskLabelText = document.createElementNS(SVG_NS, "text");
            taskLabelText.setAttribute("class", "task-label");
            // Initial attributes will be set by the persistence logic block below
            taskLabelText.setAttribute("text-anchor", "middle");
            taskLabelText.setAttribute(
              "fill",
              task.completed ? COMPLETED_COLOR : task.color
            );

            // --- Truncation Logic ---
            const MAX_CHARS = 12;
            let displayName = task.name;

            if (task.name.length > MAX_CHARS) {
              displayName = task.name.substring(0, MAX_CHARS) + "...";
            }

            // Check persistence state
            const isHovered = task.id === hoveredTaskId;

            // Apply initial state (Default OR Hovered)
            if (isHovered) {
              taskLabelText.textContent = task.name;
              taskLabelText.setAttribute(
                "text-anchor",
                isFlipped ? "end" : "start"
              );
              taskLabelText.setAttribute("x", safePos.x);
              taskLabelText.setAttribute("y", safePos.y);
              taskLabelText.setAttribute(
                "transform",
                `rotate(${textRotation} ${safePos.x} ${safePos.y})`
              );
            } else {
              taskLabelText.textContent = displayName;
              taskLabelText.setAttribute("x", labelPos.x);
              taskLabelText.setAttribute("y", labelPos.y);
              taskLabelText.setAttribute(
                "transform",
                `rotate(${textRotation} ${labelPos.x} ${labelPos.y})`
              );
            }

            // --- Hover Listeners ---
            labelGroup.addEventListener("mouseenter", (e) => {
              hoveredTaskId = task.id; // UPDATE STATE
              taskLabelText.textContent = task.name;
              labelsContainer.appendChild(labelGroup); // Bring to front

              // 1. Move Text to Safe Radius
              taskLabelText.setAttribute(
                "text-anchor",
                isFlipped ? "end" : "start"
              );
              taskLabelText.setAttribute("x", safePos.x);
              taskLabelText.setAttribute("y", safePos.y);
              taskLabelText.setAttribute(
                "transform",
                `rotate(${textRotation} ${safePos.x} ${safePos.y})`
              );

              // 2. Move Checkbox to Margin (Before Text)
              checkboxGroup.setAttribute(
                "transform",
                `translate(${checkboxHoverPos.x - checkboxSize / 2}, ${
                  checkboxHoverPos.y - checkboxSize / 2
                }) rotate(${textRotation}, ${checkboxSize / 2}, ${
                  checkboxSize / 2
                })`
              );

              // 3. Add HIT AREA BRIDGE (Transparent Rect)
              let bridge = labelGroup.querySelector(".hover-bridge");
              if (!bridge) {
                bridge = document.createElementNS(SVG_NS, "rect");
                bridge.setAttribute("class", "hover-bridge");
                bridge.setAttribute("fill", "transparent");
                bridge.setAttribute("height", "20");
                labelGroup.prepend(bridge);
              }
              const bridgeWidth = SAFE_RADIUS - CHECKBOX_HOVER_RADIUS + 5;
              const bridgePos = polarToCartesian(
                CENTER_X,
                CENTER_Y,
                CHECKBOX_HOVER_RADIUS + bridgeWidth / 2,
                labelAngle
              );
              bridge.setAttribute("width", bridgeWidth);
              bridge.setAttribute("x", bridgePos.x - bridgeWidth / 2);
              bridge.setAttribute("y", bridgePos.y - 10);
              bridge.setAttribute(
                "transform",
                `rotate(${textRotation} ${bridgePos.x} ${bridgePos.y})`
              );

              // --- Restore Tooltip ---
              const tooltip =
                document.getElementById("task-tooltip") || createTooltip();
              tooltip.textContent = task.name;
              tooltip.classList.add("visible");
              updateTooltipPosition(e, tooltip);
            });

            labelGroup.addEventListener("mousemove", (e) => {
              const tooltip = document.getElementById("task-tooltip");
              if (tooltip && tooltip.classList.contains("visible")) {
                updateTooltipPosition(e, tooltip);
              }
            });

            labelGroup.addEventListener("mouseleave", () => {
              hoveredTaskId = null; // CLEAR STATE
              taskLabelText.textContent = displayName;

              // 1. Revert Text
              taskLabelText.setAttribute("text-anchor", "middle");
              taskLabelText.setAttribute("x", labelPos.x);
              taskLabelText.setAttribute("y", labelPos.y);
              taskLabelText.setAttribute(
                "transform",
                `rotate(${textRotation} ${labelPos.x} ${labelPos.y})`
              );

              // 2. Revert Checkbox
              checkboxGroup.setAttribute(
                "transform",
                `translate(${checkboxPos.x - checkboxSize / 2}, ${
                  checkboxPos.y - checkboxSize / 2
                }) rotate(${textRotation}, ${checkboxSize / 2}, ${
                  checkboxSize / 2
                })`
              );

              // 3. Remove Bridge
              const bridge = labelGroup.querySelector(".hover-bridge");
              if (bridge) {
                bridge.remove();
              }

              // --- Hide Tooltip ---
              const tooltip = document.getElementById("task-tooltip");
              if (tooltip) {
                tooltip.classList.remove("visible");
              }
            });

            // --- Checkbox logic ---
            const checkboxSize = 14;
            const checkboxGroup = document.createElementNS(SVG_NS, "g");
            checkboxGroup.setAttribute("class", "task-checkbox");

            const checkboxPos = polarToCartesian(
              CENTER_X,
              CENTER_Y,
              TASK_PIE_RADIUS - checkboxSize * 1.5,
              labelAngle
            );

            // Initial Checkbox Position (based on persistence)
            if (isHovered) {
              checkboxGroup.setAttribute(
                "transform",
                `translate(${checkboxHoverPos.x - checkboxSize / 2}, ${
                  checkboxHoverPos.y - checkboxSize / 2
                }) rotate(${textRotation}, ${checkboxSize / 2}, ${
                  checkboxSize / 2
                })`
              );
              // Ensure bridge exists immediately if hovered to maintain stability
              // We defer appending it to after checkboxGroup is appended to labelGroup
            } else {
              checkboxGroup.setAttribute(
                "transform",
                `translate(${checkboxPos.x - checkboxSize / 2}, ${
                  checkboxPos.y - checkboxSize / 2
                }) rotate(${textRotation}, ${checkboxSize / 2}, ${
                  checkboxSize / 2
                })`
              );
            }

            checkboxGroup.addEventListener("click", (evt) => {
              evt.stopPropagation();
              toggleTaskCompletion(task.id);
            });

            const checkboxRect = document.createElementNS(SVG_NS, "rect");
            checkboxRect.setAttribute("width", checkboxSize);
            checkboxRect.setAttribute("height", checkboxSize);
            // The 'rx' and 'ry' attributes are set here via JS for compatibility
            checkboxRect.setAttribute("rx", 2);
            checkboxRect.setAttribute("ry", 2);
            checkboxGroup.appendChild(checkboxRect);

            if (task.completed) {
              const checkmarkPath = document.createElementNS(SVG_NS, "path");
              checkmarkPath.setAttribute(
                "d",
                `M3 ${checkboxSize / 2} L${checkboxSize / 2.5} ${
                  checkboxSize - 4
                } L${checkboxSize - 3} 4`
              );
              checkboxGroup.appendChild(checkmarkPath);
            }

            // FIX #HoverStability: Append checkbox to labelGroup so hover persists
            labelGroup.appendChild(taskLabelText);
            labelGroup.appendChild(checkboxGroup);

            // Create and append bridge if hovered (for initial persistence)
            if (isHovered) {
              let bridge = document.createElementNS(SVG_NS, "rect");
              bridge.setAttribute("class", "hover-bridge");
              bridge.setAttribute("fill", "transparent");
              bridge.setAttribute("height", "20");
              const bridgeWidth = SAFE_RADIUS - CHECKBOX_HOVER_RADIUS + 5;
              const bridgePosBridge = polarToCartesian(
                CENTER_X,
                CENTER_Y,
                CHECKBOX_HOVER_RADIUS + bridgeWidth / 2,
                labelAngle
              );
              bridge.setAttribute("width", bridgeWidth);
              bridge.setAttribute("x", bridgePosBridge.x - bridgeWidth / 2);
              bridge.setAttribute("y", bridgePosBridge.y - 10);
              bridge.setAttribute(
                "transform",
                `rotate(${textRotation} ${bridgePosBridge.x} ${bridgePosBridge.y})`
              );
              labelGroup.prepend(bridge);
            }

            labelsContainer.appendChild(labelGroup);
          });
        }

        function updateClockHands() {
          const t = new Date(),
            e = t.getSeconds(),
            n = t.getMinutes(),
            o = t.getHours();
          0 === e
            ? secondHand.classList.add("no-transition")
            : secondHand.classList.contains("no-transition") &&
              secondHand.classList.remove("no-transition");
          const r = 6 * e,
            s = 6 * n + 0.1 * e,
            a = "24h" === clockMode ? 24 : 12,
            i = o % a,
            l = (i / a) * 360 + (n / 60) * (360 / a);
          (secondHand.style.transform = `rotate(${r}deg)`),
            (minuteHand.style.transform = `rotate(${s}deg)`),
            (hourHand.style.transform = `rotate(${l}deg)`);
          let c = !isToday(selectedDate);
          isToday(selectedDate) &&
            "12h" === clockMode &&
            (("am" === ampm && o >= 12) || ("pm" === ampm && o < 12)) &&
            (c = !0),
            handsContainer.classList.toggle("faded", c);
        }

        // --- Digital Clock Logic ---
        function updateDigitalClock() {
          if (!digitalClockDisplay) return;
          const now = new Date();
          let hours = now.getHours();
          const minutes = String(now.getMinutes()).padStart(2, "0");

          let displayTime = "";
          if (digitalClockFormat === "24h") {
            displayTime = `${String(hours).padStart(2, "0")}:${minutes}`;
          } else {
            const period = hours >= 12 ? "PM" : "AM";
            hours = hours % 12;
            hours = hours ? hours : 12;
            displayTime = `${hours}:${minutes}<span style="font-size: 0.6em; margin-left: 2px;">${period}</span>`;
          }

          digitalClockDisplay.innerHTML = displayTime;

          // Update toggle button text to indicate current state
          if (digitalFormatToggle) {
            digitalFormatToggle.textContent =
              digitalClockFormat === "24h" ? "24" : "12";
          }
        }

        // --- Blocks View Render Functions ---
        function renderBlocksView() {
          const today = selectedDate;
          const yesterday = new Date(today);
          yesterday.setDate(today.getDate() - 1);
          const tomorrow = new Date(today);
          tomorrow.setDate(today.getDate() + 1);
          const options = { weekday: "long", day: "numeric", month: "short" };
          document.getElementById(
            "yesterday-label"
          ).textContent = `Yesterday: ${yesterday.toLocaleDateString(
            undefined,
            options
          )}`;
          document.getElementById(
            "today-label"
          ).textContent = `Today: ${today.toLocaleDateString(
            undefined,
            options
          )}`;
          document.getElementById(
            "tomorrow-label"
          ).textContent = `Tomorrow: ${tomorrow.toLocaleDateString(
            undefined,
            options
          )}`;
          renderDayBlock(
            yesterday,
            document.getElementById("yesterday-tasks-container")
          );
          renderDayBlock(
            today,
            document.getElementById("today-tasks-container")
          );
          renderDayBlock(
            tomorrow,
            document.getElementById("tomorrow-tasks-container")
          );
          updateCurrentTimeLine();
        }
        function renderDayBlock(date, container) {
          container.innerHTML = "";
          const tasksForDay = getTasksForDate(date);
          const now = new Date();
          const currentHour24 = now.getHours() + now.getMinutes() / 60;
          const isPastDay = getDateKey(date) < getDateKey(new Date());
          const isToday_local = getDateKey(date) === getDateKey(new Date());
          tasksForDay.forEach((task) => {
            const taskEl = document.createElement("div");
            taskEl.className = "task-block";
            taskEl.textContent = task.name;
            taskEl.setAttribute("title", task.name);
            taskEl.style.left = `${(task.startHour / 24) * 100}%`;
            taskEl.style.width = `${
              ((task.endHour - task.startHour) / 24) * 100
            }%`;
            let background;
            if (task.completed) {
              background = COMPLETED_COLOR;
            } else if (
              isPastDay ||
              (isToday_local && currentHour24 >= task.endHour)
            ) {
              background = UNCOMPLETED_PAST_COLOR;
            } else if (
              isToday_local &&
              currentHour24 > task.startHour &&
              currentHour24 < task.endHour
            ) {
              const progressPercent =
                ((currentHour24 - task.startHour) /
                  (task.endHour - task.startHour)) *
                100;
              background = `linear-gradient(to right, ${UNCOMPLETED_PAST_COLOR} ${progressPercent}%, ${task.color} ${progressPercent}%)`;
            } else {
              background = task.color;
            }
            taskEl.style.background = background;
            taskEl.addEventListener("click", () => showModal(task, date));
            container.appendChild(taskEl);
          });
        }
        function updateCurrentTimeLine() {
          if (
            clockMode === "24h" &&
            viewMode === "blocks" &&
            isToday(selectedDate)
          ) {
            const now = new Date();
            const percentOfDay =
              ((now.getHours() * 60 + now.getMinutes()) / (24 * 60)) * 100;
            currentTimeLine.style.left = `${percentOfDay}%`;
            currentTimeLine.style.display = "block";
          } else {
            currentTimeLine.style.display = "none";
          }
        }

        // --- Clock Drag Handlers ---
        const handleDragStart = (t) => {
          t.preventDefault();
          isDragging = true;
          dragStartHour = getHourFromMouseEvent(t);
          dragEndHour = dragStartHour;
          lastDragHour = dragStartHour; // NEW: Init tracking
          dragLoops = 0; // NEW: Reset loops
          svg.style.cursor = "grabbing";
          updateDragLabels(t);
          dragLabelsContainer.style.visibility = "visible";
          window.addEventListener("mousemove", handleDragMove);
          window.addEventListener("mouseup", handleDragEnd);
        };
        const handleDragMove = (t) => {
          if (!isDragging) return;
          const currentHour = getHourFromMouseEvent(t);
          const totalHours = clockMode === "24h" ? 24 : 12;

          // Detect crossing the 12/0 or 24/0 boundary
          // If jump is large (e.g. 11 -> 0), it's a forward wrap
          // If jump is large negative (e.g. 0 -> 11), it's a backward wrap
          const diff = currentHour - lastDragHour;
          if (diff < -totalHours / 2) {
            dragLoops++;
          } else if (diff > totalHours / 2) {
            dragLoops--;
          }
          lastDragHour = currentHour;

          // continuous drag end hour includes the loops
          dragEndHour = currentHour + dragLoops * totalHours;

          updateDragLabels(t);

          // For drawing the pie slice, we need to normalize to current clock face but handle the full sweep
          // Actually, describePieSlice takes raw angles, so let's check how we pass it.
          // We want the visual arc to look correct.
          // If we drag 11a -> 2p (11 -> 14), we want arc from 11 to 2 passing 12.

          const startAngle = (dragStartHour / totalHours) * 360;
          const endAngle = (dragEndHour / totalHours) * 360;

          previewArc.setAttribute(
            "d",
            describePieSlice(
              CENTER_X,
              CENTER_Y,
              TASK_PIE_RADIUS,
              startAngle,
              endAngle
            )
          );
        };
        const handleDragEnd = () => {
          window.removeEventListener("mousemove", handleDragMove);
          window.removeEventListener("mouseup", handleDragEnd);
          if (!isDragging) return;
          isDragging = false;
          svg.style.cursor = "crosshair";
          previewArc.setAttribute("d", "");
          dragLabelsContainer.style.visibility = "hidden";

          if (
            dragEndHour == null ||
            Math.abs(dragEndHour - dragStartHour) < 0.01
          )
            return;

          // Calculate final times.
          // If we dragged backwards (dragEnd < dragStart), we assume user meant that.
          // But usually task creation is start->end.
          // If start > end, swapped? No, let's respect the drag direction.
          // But showModal expects start < end for logic checks usually, or we fix showModal/saveTask logic.

          let t = dragStartHour;
          let e = dragEndHour;

          if (t > e) {
            // Swap if dragged backwards, or maybe they want a task across midnight backwards?
            // Standard behavior: swap to make it valid chronological task on the day or wrap.
            // But for the specific request "11am -> 2pm", t=11, e=14. Correct.
            // If user dragged 2pm -> 11am (CCW), t=14, e=11.
            [t, e] = [e, t];
          }

          if ("12h" === clockMode && "pm" === ampm) {
            t += 12;
            e += 12;
          }

          // If e > 24, it means we crossed into next day.
          // The modal input[type=time] only supports 00:00-23:59.
          // If end > 24, we might need to clamp or mark as 'Next Day' in UI?
          // For now, let's keep the raw values. The logic in saveTask might need to handle e > 24.
          // Actually, getHourFromMouseEvent returns local clock hour.
          // If dragging 11am -> 1pm (13), diff is +2. End is 13.
          // 12h Mode: start=11. end=13.
          // If PM mode: start=23, end=25 (1am next day).

          showModal(null, selectedDate, { startHour: t, endHour: e });
        };
        function updateDragLabels(t) {
          if (!isDragging) return;
          const rect = svg.getBoundingClientRect();
          const n = ((t.clientX - rect.left) / rect.width) * 400;
          const o = ((t.clientY - rect.top) / rect.height) * 400;

          // Determine display times
          let startDisplay = dragStartHour;
          let endDisplay = dragEndHour;

          // Normalize for display (e.g., 13 -> 1, 25 -> 1)
          // Simple modulo logic for the text buffer
          const formatForLabel = (h) => {
            // Add offset for PM mode if needed for the display text logic
            // But dragStartHour is 0-12 in 12h mode.
            let absoluteH = h;
            if ("12h" === clockMode && "pm" === ampm) absoluteH += 12;
            return formatHourToAMPM(absoluteH);
          };

          if (startDisplay > endDisplay) {
            [startDisplay, endDisplay] = [endDisplay, startDisplay];
          }

          dragTimeLabel.textContent = `${formatForLabel(
            startDisplay
          )} - ${formatForLabel(endDisplay)}`;
          dragTimeLabel.setAttribute("x", n);
          dragTimeLabel.setAttribute("y", o + 30);
        }

        // --- Blocks Drag Handlers ---
        const getHourFromBlockEvent = (e, block) => {
          const rect = block.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const hour = Math.max(0, Math.min(24, (x / rect.width) * 24));
          return Math.round(hour * 4) / 4;
        };
        const handleBlockDragStart = (e, date, blockElement) => {
          e.preventDefault();
          isBlockDragging = true;
          activeDragDate = date;
          activeDragBlock = blockElement;
          blockDragStartHour = getHourFromBlockEvent(e, activeDragBlock);

          const previewBlock = activeDragBlock.querySelector(
            ".task-preview-block"
          );
          if (previewBlock) {
            previewBlock.style.display = "block";
          }

          updateBlockPreview(e);
          window.addEventListener("mousemove", handleBlockDragMove);
          window.addEventListener("mouseup", handleBlockDragEnd);
        };
        const handleBlockDragMove = (e) => {
          if (!isBlockDragging) return;
          updateBlockPreview(e);
        };
        const handleBlockDragEnd = (e) => {
          if (!isBlockDragging) return;

          const endHour = getHourFromBlockEvent(e, activeDragBlock);
          const previewBlock = activeDragBlock.querySelector(
            ".task-preview-block"
          );
          if (previewBlock) {
            previewBlock.style.display = "none";
          }

          window.removeEventListener("mousemove", handleBlockDragMove);
          window.removeEventListener("mouseup", handleBlockDragEnd);
          isBlockDragging = false;

          if (Math.abs(endHour - blockDragStartHour) < 0.25) return;
          const startH = Math.min(blockDragStartHour, endHour);
          const endH = Math.max(blockDragStartHour, endHour);
          showModal(null, activeDragDate, { startHour: startH, endHour: endH });
        };
        function updateBlockPreview(e) {
          const previewBlock = activeDragBlock.querySelector(
            ".task-preview-block"
          );
          if (!previewBlock) return;
          const currentHour = getHourFromBlockEvent(e, activeDragBlock);
          const startPercent =
            (Math.min(blockDragStartHour, currentHour) / 24) * 100;
          const widthPercent =
            (Math.abs(currentHour - blockDragStartHour) / 24) * 100;
          previewBlock.style.left = `${startPercent}%`;
          previewBlock.style.width = `${widthPercent}%`;
        }

        // --- Confirmation Modal Logic ---
        const confirmationModal = document.getElementById("confirmation-modal");
        const confirmationTitle = document.getElementById("confirmation-title");
        const confirmationDesc = document.getElementById("confirmation-desc");
        const confirmationBtnConfirm = document.getElementById(
          "confirmation-btn-confirm"
        );
        const confirmationBtnCancel = document.getElementById(
          "confirmation-btn-cancel"
        );

        function showConfirmation(title, desc, onConfirm) {
          confirmationTitle.textContent = title;
          confirmationDesc.textContent = desc;

          const close = () => {
            confirmationModal.classList.remove("visible");
            confirmationBtnConfirm.onclick = null;
            confirmationBtnCancel.onclick = null;
          };

          confirmationBtnConfirm.onclick = () => {
            close();
            onConfirm(true);
          };
          confirmationBtnCancel.onclick = () => {
            close();
            onConfirm(false);
          };

          confirmationModal.classList.add("visible");
        }

        // --- Recurrence Modal Logic ---
        function showRecurrenceOptions(title, desc, callback) {
          recurrenceTitle.textContent = title;
          recurrenceDesc.textContent = desc;

          const close = () => {
            recurrenceModal.classList.remove("visible");
            // Cleanup listeners to avoid dupes
            recurrenceBtnThis.onclick = null;
            recurrenceBtnFuture.onclick = null;
            recurrenceBtnCancel.onclick = null;
          };

          recurrenceBtnThis.onclick = () => {
            close();
            callback("this");
          };
          recurrenceBtnFuture.onclick = () => {
            close();
            callback("future");
          };
          recurrenceBtnCancel.onclick = () => {
            close();
            callback("cancel");
          };

          recurrenceModal.classList.add("visible");
        }

        // --- Modal Logic ---
        let modalTaskDate = null;
        function showModal(t = null, e, n = null) {
          (modalTaskDate = e || selectedDate),
            t
              ? ((modalTitle.textContent = "Edit Task"),
                (taskIdInput.value = t.id),
                (taskNameInput.value = t.name),
                deleteTaskBtn.classList.remove("hidden"),
                (taskStartTimeInput.value = formatHourToTimeInput(t.startHour)),
                (taskEndTimeInput.value = formatHourToTimeInput(t.endHour)),
                (taskCompletedCheckbox.checked = t.completed),
                document
                  .querySelectorAll(".color-option")
                  .forEach((e) =>
                    e.classList.toggle("selected", e.dataset.color === t.color)
                  ),
                (taskRecursiveToggle.checked = !!t.isRecurringInstance))
              : ((modalTitle.textContent = "New Task"),
                (taskIdInput.value = ""),
                (taskNameInput.value = ""),
                taskNameInput.focus(),
                deleteTaskBtn.classList.add("hidden"),
                (taskStartTimeInput.value = formatHourToTimeInput(n.startHour)),
                (taskEndTimeInput.value = formatHourToTimeInput(n.endHour)),
                (taskCompletedCheckbox.checked = !1),
                (taskRecursiveToggle.checked = !1),
                document
                  .querySelector(".color-option.selected")
                  ?.classList.remove("selected"),
                document
                  .querySelector(".color-option")
                  ?.classList.add("selected")),
            modal.classList.add("visible");
        }
        const hideModal = () => {
          modal.classList.remove("visible"),
            (dragLabelsContainer.style.visibility = "hidden");
        };
        async function saveTask() {
          const taskName = taskNameInput.value.trim();
          const color = document.querySelector(".color-option.selected")
            ?.dataset.color;
          const taskIdRaw = taskIdInput.value;
          const isInstance = taskIdRaw && taskIdRaw.includes("_");

          let startHour = parseTimeInputToHour(taskStartTimeInput.value);
          let endHour = parseTimeInputToHour(taskEndTimeInput.value);
          const completed = taskCompletedCheckbox.checked;
          const isRecurring = taskRecursiveToggle.checked;

          if (!taskName || !color) {
            return alert("Please provide a task name and select a color.");
          }

          if (endHour === 0) {
            endHour = 24;
          }

          if (endHour <= startHour) {
            // Handle overnight tasks automatically by adding 24 hours
            endHour += 24;
          }

          const dateKey = getDateKey(modalTaskDate);

          // 1. EDITING AN EXISTING TASK
          if (taskIdRaw) {
            if (isInstance) {
              // Editing a Recurring Instance
              const originalId = Number(taskIdRaw.split("_")[0]);

              if (isRecurring) {
                // User KEPT it recurring.
                showRecurrenceOptions(
                  "Edit Recurring Task",
                  "How would you like to apply your changes?",
                  (choice) => {
                    if (choice === "cancel") return;

                    if (choice === "future") {
                      // Update SERIES
                      const rIndex = recurringTasks.findIndex(
                        (rt) => rt.id === originalId
                      );
                      if (rIndex > -1) {
                        recurringTasks[rIndex] = {
                          ...recurringTasks[rIndex],
                          name: taskName,
                          color,
                          startHour,
                          endHour,
                        };
                        localStorage.setItem(
                          "clockRecurringTasks",
                          JSON.stringify(recurringTasks)
                        );
                      }
                    } else {
                      // Update INSTANCE (Exception)
                      // 1. Blacklist date in recurringTasks
                      const rIndex = recurringTasks.findIndex(
                        (rt) => rt.id === originalId
                      );
                      if (rIndex > -1) {
                        if (!recurringTasks[rIndex].exceptions)
                          recurringTasks[rIndex].exceptions = {};
                        recurringTasks[rIndex].exceptions[dateKey] = true;
                        localStorage.setItem(
                          "clockRecurringTasks",
                          JSON.stringify(recurringTasks)
                        );
                      }
                      // 2. Create One-Off
                      if (!tasksByDate[dateKey]) tasksByDate[dateKey] = [];
                      tasksByDate[dateKey].push({
                        id: Date.now(),
                        name: taskName,
                        color,
                        startHour,
                        endHour,
                        completed,
                        subtasks: [],
                      });
                      localStorage.setItem(
                        "clockTasksPro",
                        JSON.stringify(tasksByDate)
                      );
                    }
                    renderAppView();
                    hideModal();
                  }
                );
                return; // Stop here, wait for callback
              } else {
                // User turned OFF Recurring
                // Show confirmation to stop recurrence future
                showRecurrenceOptions(
                  "Stop Recurrence?",
                  "You unchecked 'Recurring'. Do you want to stop this task from recurring in the future?",
                  (choice) => {
                    if (choice === "cancel") return;

                    const rIndex = recurringTasks.findIndex(
                      (rt) => rt.id === originalId
                    );

                    if (choice === "future") {
                      // "All Future Events" context here means "Stop Recurrence for Future"
                      // End the recurrence yesterday
                      if (rIndex > -1) {
                        const yesterday = new Date(modalTaskDate);
                        yesterday.setDate(yesterday.getDate() - 1);
                        recurringTasks[rIndex].recurrenceEnd =
                          getDateKey(yesterday);
                        localStorage.setItem(
                          "clockRecurringTasks",
                          JSON.stringify(recurringTasks)
                        );
                      }
                    } else {
                      // "This Event Only" -> Detach only this instance (Standard Exception)
                      if (rIndex > -1) {
                        if (!recurringTasks[rIndex].exceptions)
                          recurringTasks[rIndex].exceptions = {};
                        recurringTasks[rIndex].exceptions[dateKey] = true;
                        localStorage.setItem(
                          "clockRecurringTasks",
                          JSON.stringify(recurringTasks)
                        );
                      }
                    }

                    // In both cases, we create a one-off for TODAY (the current edit)
                    if (!tasksByDate[dateKey]) tasksByDate[dateKey] = [];
                    tasksByDate[dateKey].push({
                      id: Date.now(),
                      name: taskName,
                      color,
                      startHour,
                      endHour,
                      completed,
                      subtasks: [],
                    });
                    localStorage.setItem(
                      "clockTasksPro",
                      JSON.stringify(tasksByDate)
                    );

                    renderAppView();
                    hideModal();
                  }
                );
                return;
              }
            } else {
              // Editing a Regular One-Off Task
              const tId = Number(taskIdRaw);
              if (isRecurring) {
                // Converting One-Off to Recurring
                // 1. Remove One-off
                if (tasksByDate[dateKey]) {
                  tasksByDate[dateKey] = tasksByDate[dateKey].filter(
                    (t) => t.id !== tId
                  );
                  localStorage.setItem(
                    "clockTasksPro",
                    JSON.stringify(tasksByDate)
                  );
                }
                // 2. Add Recurring
                recurringTasks.push({
                  id: tId, // Keep ID
                  name: taskName,
                  color,
                  startHour,
                  endHour,
                  recurrenceStart: dateKey,
                  exceptions: {},
                });
                localStorage.setItem(
                  "clockRecurringTasks",
                  JSON.stringify(recurringTasks)
                );
              } else {
                // Just Update One-off
                if (!tasksByDate[dateKey]) tasksByDate[dateKey] = [];
                const idx = tasksByDate[dateKey].findIndex((t) => t.id === tId);
                if (idx > -1) {
                  tasksByDate[dateKey][idx] = {
                    ...tasksByDate[dateKey][idx],
                    name: taskName,
                    color,
                    startHour,
                    endHour,
                    completed,
                  };
                  localStorage.setItem(
                    "clockTasksPro",
                    JSON.stringify(tasksByDate)
                  );
                }
              }
            }
          } else {
            // 2. CREATING NEW TASK
            const newId = Date.now();
            if (isRecurring) {
              recurringTasks.push({
                id: newId,
                name: taskName,
                color,
                startHour,
                endHour,
                recurrenceStart: dateKey,
                exceptions: {},
              });
              localStorage.setItem(
                "clockRecurringTasks",
                JSON.stringify(recurringTasks)
              );
            } else {
              if (!tasksByDate[dateKey]) tasksByDate[dateKey] = [];
              tasksByDate[dateKey].push({
                id: newId,
                name: taskName,
                color,
                startHour,
                endHour,
                completed,
                subtasks: [],
              });
              localStorage.setItem(
                "clockTasksPro",
                JSON.stringify(tasksByDate)
              );
            }
          }

          renderAppView();
          hideModal();
        }
        function deleteTask() {
          const taskIdRaw = taskIdInput.value;
          if (!taskIdRaw) return;

          showConfirmation(
            "Delete Task?",
            "Are you sure you want to delete this task?",
            (confirmed) => {
              if (!confirmed) return;

              const dateKey = getDateKey(modalTaskDate);
              const isInstance = taskIdRaw.includes("_");

              if (isInstance) {
                const originalId = Number(taskIdRaw.split("_")[0]);

                showRecurrenceOptions(
                  "Delete Recurring Task",
                  "Do you want to delete this specific event or all future events?",
                  (choice) => {
                    if (choice === "cancel") return;

                    if (choice === "future") {
                      // Delete Series (or Stop Recurrence)
                      const rIndex = recurringTasks.findIndex(
                        (rt) => rt.id === originalId
                      );
                      if (rIndex > -1) {
                        // If start date is in future OR today is the start date, just delete completely
                        if (recurringTasks[rIndex].recurrenceStart >= dateKey) {
                          recurringTasks.splice(rIndex, 1);
                        } else {
                          // End the recurrence yesterday
                          const yesterday = new Date(modalTaskDate);
                          yesterday.setDate(yesterday.getDate() - 1);
                          recurringTasks[rIndex].recurrenceEnd =
                            getDateKey(yesterday);
                        }
                        localStorage.setItem(
                          "clockRecurringTasks",
                          JSON.stringify(recurringTasks)
                        );
                      }
                    } else {
                      // Delete Instance (Exception)
                      const rIndex = recurringTasks.findIndex(
                        (rt) => rt.id === originalId
                      );
                      if (rIndex > -1) {
                        if (!recurringTasks[rIndex].exceptions)
                          recurringTasks[rIndex].exceptions = {};
                        recurringTasks[rIndex].exceptions[dateKey] = true;
                        localStorage.setItem(
                          "clockRecurringTasks",
                          JSON.stringify(recurringTasks)
                        );
                      }
                    }
                    renderAppView();
                    hideModal();
                  }
                );
                return;
              } else {
                // Regular delete
                const tId = Number(taskIdRaw);
                if (tasksByDate[dateKey]) {
                  tasksByDate[dateKey] = tasksByDate[dateKey].filter(
                    (t) => t.id !== tId
                  );
                  if (tasksByDate[dateKey].length === 0)
                    delete tasksByDate[dateKey];
                  localStorage.setItem(
                    "clockTasksPro",
                    JSON.stringify(tasksByDate)
                  );
                }
              }
              renderAppView();
              hideModal();
            }
          );
        }
        function toggleTaskCompletion(taskId) {
          const dateKey = getDateKey(selectedDate);

          // Check if it's a virtual ID (recurring instance not yet materialized)
          const isVirtual = typeof taskId === "string" && taskId.includes("_");

          if (isVirtual) {
            // Materialize Recurring Instance
            const originalId = Number(taskId.split("_")[0]);
            const rTask = recurringTasks.find((rt) => rt.id === originalId);

            if (rTask) {
              // 1. Add exception
              if (!rTask.exceptions) rTask.exceptions = {};
              rTask.exceptions[dateKey] = true;
              localStorage.setItem(
                "clockRecurringTasks",
                JSON.stringify(recurringTasks)
              );

              // 2. Materialize as Completed One-Off
              const newTask = {
                id: Date.now(),
                name: rTask.name,
                color: rTask.color,
                startHour: rTask.startHour,
                endHour: rTask.endHour,
                completed: !rTask.completed, // Toggle the base state (usually false->true)
                subtasks: [],
              };

              // Base recurring tasks don't usually track 'completed' property for the template,
              // but let's assume it's incomplete by default.
              // Actually, if I created it as completed, it stays completed?
              // The template `completed` property is probably ignored for instances usually.
              // Let's explicitly set to TRUE because user clicked it.
              // Wait, what if they click it to UNCOMPLETE?
              // A virtual instance is by definition NOT in `tasksByDate`, meaning it's "clean".
              // So it is uncompleted. Clicking it means "Complete it".
              newTask.completed = true;

              if (!tasksByDate[dateKey]) tasksByDate[dateKey] = [];
              tasksByDate[dateKey].push(newTask);
              localStorage.setItem(
                "clockTasksPro",
                JSON.stringify(tasksByDate)
              );
              renderAppView();
            }
          } else {
            // Regular Task (or materialized)
            const tId = Number(taskId);
            if (tasksByDate[dateKey]) {
              const task = tasksByDate[dateKey].find((t) => t.id === tId);
              if (task) {
                task.completed = !task.completed;
                localStorage.setItem(
                  "clockTasksPro",
                  JSON.stringify(tasksByDate)
                );
                renderAppView();
              }
            }
          }
        }

        // ============================================
        // ==     NOTION-LIKE NOTES WIDGET LOGIC     ==
        // ============================================

        const notesWidgetEl = document.getElementById("notes-widget");
        const slashMenuEl = document.getElementById("slash-menu");
        const addElementBtn = document.getElementById("add-element-btn");

        let slashMenuIndex = 0;
        let slashMenuFilter = "";
        let activeEditorBlock = null; // The specific block element being edited
        let activeEditorInstance = null; // The editor container

        // --- Slash Menu Configuration ---
        const SLASH_ITEMS = [
          {
            id: "text",
            label: "Text",
            desc: "Just start writing with plain text.",
            icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>',
          },
          {
            id: "h1",
            label: "Heading 1",
            desc: "Big section heading.",
            icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 12h12"></path><path d="M6 20V4"></path><path d="M18 20V4"></path></svg>',
          },
          {
            id: "h2",
            label: "Heading 2",
            desc: "Medium section heading.",
            icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 12h12"></path><path d="M6 20V4"></path><path d="M18 20V4"></path></svg>',
          },
          {
            id: "h3",
            label: "Heading 3",
            desc: "Small section heading.",
            icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 12h12"></path><path d="M6 20V4"></path><path d="M18 20V4"></path></svg>',
          },
          {
            id: "bullet",
            label: "Bulleted List",
            desc: "Create a simple bulleted list.",
            icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg>',
          },
          {
            id: "todo",
            label: "To-do List",
            desc: "Track tasks with a to-do list.",
            icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 11 12 14 22 4"></polyline><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path></svg>',
          },
          {
            id: "quote",
            label: "Quote",
            desc: "Capture a quote.",
            icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 21c3 0 7-1 7-8V5c0-1.25-.75-2-2-2H4c-1.25 0-2 .75-2 2v6c0 7 4 8 8 8Z"></path><path d="M14 21c3 0 7-1 7-8V5c0-1.25-.75-2-2-2h-4c-1.25 0-2 .75-2 2v6c0 7 4 8 8 8Z"></path></svg>',
          },
          {
            id: "divider",
            label: "Divider",
            desc: "Visually separate content.",
            icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="12" x2="20" y2="12"></line></svg>',
          },
          {
            id: "code",
            label: "Code",
            desc: "Capture a code snippet.",
            icon: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>',
          },
        ];

        // --- Initialization ---

        document.addEventListener("click", (e) => {
          // Close slash menu if clicked outside
          if (
            slashMenuEl.classList.contains("visible") &&
            !slashMenuEl.contains(e.target)
          ) {
            closeSlashMenu();
          }
        });

        if (addElementBtn) {
          addElementBtn.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation(); // Stop bubbling

            // Toggle Logic
            if (slashMenuEl.classList.contains("visible")) {
              closeSlashMenu();
              return;
            }

            // Topic Mode Enhancement: Create new topic note if in Topic List View
            if (activeNotesTab === "topics" && !activeTopicNoteId) {
              createNewTopicNote();
              return;
            }

            // 1. Establish Context (find where to insert)
            // If no editor is active, try to default to today's note section
            if (!activeEditorInstance) {
              const todayKey = getDateKey(new Date());
              const todaySection = document.getElementById(
                `note-section-${todayKey}`
              );
              if (todaySection) {
                const editor = todaySection.querySelector(".note-editor");
                if (editor) {
                  activeEditorInstance = editor;
                  // If we have blocks, default to last one
                  if (editor.lastElementChild) {
                    activeEditorBlock = editor.lastElementChild;
                  } else {
                    activeEditorBlock = null;
                  }
                }
              }
            }

            // If we have an instance but no block tracked (e.g. lost focus), find last block
            if (activeEditorInstance && !activeEditorBlock) {
              if (activeEditorInstance.lastElementChild) {
                activeEditorBlock = activeEditorInstance.lastElementChild;
              }
            }

            // 2. Open Menu Positioned at Button (Dropdown style)
            const btnRect = addElementBtn.getBoundingClientRect();

            // Default: Align right edge of menu to right edge of button (approximately)
            // The menu is 260px wide.
            let leftPos = btnRect.right - 260;

            // Safety: Ensure it doesn't go off screen LEFT or RIGHT
            if (leftPos < 10) leftPos = 10;
            if (leftPos + 260 > window.innerWidth)
              leftPos = window.innerWidth - 270;

            // CRITICAL FIX: Ensure fixed positioning and z-index are applied inline or via class
            slashMenuEl.style.position = "fixed";
            slashMenuEl.style.zIndex = "10001"; // High z-index

            slashMenuEl.style.left = `${leftPos}px`;
            slashMenuEl.style.top = `${btnRect.bottom + 10}px`;

            // Reset filter
            slashMenuFilter = "";
            slashMenuIndex = 0;
            renderSlashMenu();
            slashMenuEl.classList.add("visible");
          });
        }

        // --- Core Editor Logic ---

        function getCaretCoordinates() {
          const sel = window.getSelection();
          if (!sel || !sel.rangeCount) return { x: 0, y: 0 };

          // If selection is not in a text node, we might get weird 0,0 coords.
          const range = sel.getRangeAt(0).cloneRange();
          range.collapse(true);

          let rects = range.getClientRects();
          if (rects.length > 0) {
            return { x: rects[0].left, y: rects[0].bottom };
          }

          // Fallback for empty lines
          let element = sel.anchorNode;
          if (element.nodeType === 3) element = element.parentElement;
          if (element) {
            const elRect = element.getBoundingClientRect();
            return { x: elRect.left, y: elRect.bottom };
          }
          return { x: 0, y: 0 };
        }

        function openSlashMenu(filter = "") {
          const coords = getCaretCoordinates();

          // Priority 1: Use caret coordinates if valid
          if (coords.x !== 0 || coords.y !== 0) {
            slashMenuEl.style.left = `${coords.x}px`;
            slashMenuEl.style.top = `${coords.y + 10}px`;
          }
          // Priority 2: Use active block if available (e.g. focused but caret lost)
          else if (activeEditorBlock) {
            const rect = activeEditorBlock.getBoundingClientRect();
            slashMenuEl.style.left = `${rect.left}px`;
            slashMenuEl.style.top = `${rect.bottom + 10}px`;
          }
          // Priority 3: Fallback to center/widget position (e.g. from + button with no focus)
          else if (addElementBtn) {
            // Position near the + button but inside the widget area visually
            const btnRect = addElementBtn.getBoundingClientRect();
            const widgetRect = document
              .getElementById("notes-widget")
              .getBoundingClientRect();

            // Place it top-right aligned to widget or button
            slashMenuEl.style.left = `${btnRect.left - 200}px`;
            slashMenuEl.style.top = `${btnRect.bottom + 10}px`;
          }

          // Adjust if off screen vertical
          const menuRect = slashMenuEl.getBoundingClientRect();
          if (parseInt(slashMenuEl.style.top) + 300 > window.innerHeight) {
            slashMenuEl.style.top = `${
              parseInt(slashMenuEl.style.top) - 310
            }px`; // Flip up
          }
          // Adjust if off screen horizontal
          if (parseInt(slashMenuEl.style.left) < 10) {
            slashMenuEl.style.left = "10px";
          }

          slashMenuFilter = filter;
          slashMenuIndex = 0;
          renderSlashMenu();
          slashMenuEl.classList.add("visible");
        }

        function closeSlashMenu() {
          slashMenuEl.classList.remove("visible");
          slashMenuFilter = "";
        }

        function renderSlashMenu() {
          const filtered = SLASH_ITEMS.filter((item) =>
            item.label.toLowerCase().includes(slashMenuFilter.toLowerCase())
          );

          slashMenuEl.innerHTML = "";

          if (filtered.length === 0) {
            const empty = document.createElement("div");
            empty.style.padding = "8px 12px";
            empty.style.color = "#999";
            empty.textContent = "No results";
            slashMenuEl.appendChild(empty);
            return;
          }

          filtered.forEach((item, index) => {
            const el = document.createElement("div");
            el.className = `slash-menu-item ${
              index === slashMenuIndex ? "selected" : ""
            }`;
            el.innerHTML = `
                      <div class="slash-item-icon">${item.icon}</div>
                      <div class="slash-item-text">
                          <span class="slash-item-title">${item.label}</span>
                          <span class="slash-item-desc">${item.desc}</span>
                      </div>
                  `;
            el.addEventListener("mousedown", (e) => {
              // mousedown to prevent blur
              e.preventDefault();
              executeSlashCommand(item.id);
            });
            slashMenuEl.appendChild(el);
          });

          const selected = slashMenuEl.querySelector(".selected");
          if (selected) selected.scrollIntoView({ block: "nearest" });
        }

        // Helper: Ensure the editor has at least one block if empty
        function ensureEditorContent(editor) {
          if (!editor.innerText.trim() && !editor.children.length) {
            const p = document.createElement("p");
            p.innerHTML = "<br>";
            p.setAttribute("placeholder", "Type '/' for commands");
            editor.appendChild(p);
            // setCursorToEnd(p); // Optional: might steal focus too aggressively
          }
        }

        function executeSlashCommand(type) {
          let block = activeEditorBlock;
          const sel = window.getSelection();

          // Fallback: If no active block tracked, try to find it from selection
          if (!block && sel.rangeCount > 0) {
            block = getBlockContainer(sel.anchorNode);
          }

          if (block) {
            // 1. Get Text Content to decide strategy
            const contentEl = block.querySelector(".list-content") || block;
            const text = contentEl.innerText.replace(/\n$/, "").trim();

            // 2. Decide: Replace or Insert After
            if (text === "" || text === "/") {
              // Empty block (or just the slash trigger which we want to replace)
              transformBlock(block, type);
            } else {
              // Non-empty block: Insert NEW block after
              const newP = document.createElement("p");
              newP.contentEditable = true;
              newP.innerHTML = "<br>";
              block.after(newP);

              // Now transform the NEW block
              transformBlock(newP, type);

              // Update tracker implicitly by transformBlock
            }
          } else {
            // No block found (maybe empty editor?)
            if (activeEditorInstance) {
              const newP = document.createElement("p");
              newP.contentEditable = true;
              newP.innerHTML = "<br>";
              activeEditorInstance.appendChild(newP);
              transformBlock(newP, type);
            }
          }
          closeSlashMenu();
        }

        function getBlockContainer(node) {
          if (!node) return null;
          let current = node.nodeType === 3 ? node.parentElement : node;

          // Safety valve: don't let current be the editor itself initially if possible, but if it is, handle it.
          if (current.classList.contains("note-editor")) {
            // We are on the container. Try to find the specific child selection is in,
            // or just return null to handle gracefully.
            // Actually better: return null so logic falls back to appending/handling at editor level.
            return null;
          }

          while (current) {
            // If parent is the editor, then CURRENT is the block.
            if (
              current.parentElement &&
              current.parentElement.classList.contains("note-editor")
            ) {
              return current;
            }
            // Stop if we hit root or something generic without finding editor parent
            if (current.tagName === "BODY" || current.tagName === "HTML")
              return null;

            current = current.parentElement;
          }
          return null;
        }

        function transformBlock(block, type) {
          const text = block.innerText.replace("/", "").trim(); // Clean text

          let newBlock;
          switch (type) {
            case "h1":
              newBlock = document.createElement("h1");
              newBlock.innerText = text;
              newBlock.setAttribute("placeholder", "Heading 1");
              break;
            case "h2":
              newBlock = document.createElement("h2");
              newBlock.innerText = text;
              newBlock.setAttribute("placeholder", "Heading 2");
              break;
            case "h3":
              newBlock = document.createElement("h3");
              newBlock.innerText = text;
              newBlock.setAttribute("placeholder", "Heading 3");
              break;
            case "bullet":
              newBlock = createListBlock("bullet", text);
              break;
            case "todo":
              newBlock = createTodoBlock(text);
              break;
            case "quote":
              newBlock = document.createElement("blockquote");
              newBlock.innerText = text;
              newBlock.setAttribute("placeholder", "Empty quote");
              break;
            case "code":
              newBlock = document.createElement("pre");
              newBlock.innerText = text;
              break;
            case "divider":
              const hr = document.createElement("hr");
              block.after(hr);
              // Add a new paragraph after divider so user can type
              const p = document.createElement("p");
              p.innerHTML = "<br>";
              hr.after(p);
              if (text.trim() === "") block.remove();
              setCursorToEnd(p);
              saveCurrentNote();
              return;
            case "text":
            default:
              newBlock = document.createElement("p");
              newBlock.innerText = text;
              newBlock.setAttribute("placeholder", "Type '/' for commands");
              break;
          }

          if (newBlock) {
            // If we are replacing with same tag type, it might feel weird, but OK.
            block.replaceWith(newBlock);
            setCursorToEnd(newBlock);
            activeEditorBlock = newBlock; // Update tracker
            saveCurrentNote();
          }
        }

        function createListBlock(type, content = "") {
          const div = document.createElement("div");
          div.className = "list-item-bullet";
          div.innerHTML = `<span class="bullet"></span><div class="list-content" contenteditable="true" placeholder="List item">${content}</div>`;
          return div;
        }

        function createTodoBlock(content = "") {
          const div = document.createElement("div");
          div.className = "todo-item";
          div.innerHTML = `
        <input type="checkbox" class="todo-checkbox" />
        <div class="list-content" contenteditable="true" placeholder="To-do">${content}</div>
      `;
          return div;
        }

        // CRITICAL FIX: Robust cursor setting
        function setCursorToEnd(el) {
          // 1. Identify valid editable target
          let target = el.querySelector(".list-content") || el;

          // 2. Ensure it has content to select or is focusable
          if (target.innerText === "" && !target.querySelector("br")) {
            // Browser needs something to hold the cursor in contenteditable
            target.innerHTML = "<br>";
          }

          // 3. Focus first
          target.focus();

          // 4. Create range
          const range = document.createRange();
          range.selectNodeContents(target);
          range.collapse(false); // End

          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);

          // 5. Scroll into view
          target.scrollIntoView({ block: "nearest", behavior: "smooth" });
        }

        // --- Event Handlers (KeyDown) ---

        function handleKeyDown(e) {
          const editor = e.target.closest(".note-editor");
          if (!editor) return;

          const sel = window.getSelection();
          if (!sel.rangeCount) return;

          let block = getBlockContainer(sel.anchorNode);

          activeEditorInstance = editor;
          // If block is null, we are likely in the editor root (orphaned text).
          // We will handle this case gracefully in the logic below.
          activeEditorBlock = block;

          // 1. Slash Menu Navigation
          if (slashMenuEl.classList.contains("visible")) {
            // ... existing slash menu logic ...
            // (Copying existing logic for safety to match replacement signature)
            const filtered = SLASH_ITEMS.filter((item) =>
              item.label.toLowerCase().includes(slashMenuFilter.toLowerCase())
            );

            if (e.key === "ArrowDown") {
              e.preventDefault();
              slashMenuIndex = (slashMenuIndex + 1) % filtered.length;
              renderSlashMenu();
              return;
            }
            if (e.key === "ArrowUp") {
              e.preventDefault();
              slashMenuIndex =
                (slashMenuIndex - 1 + filtered.length) % filtered.length;
              renderSlashMenu();
              return;
            }
            if (e.key === "Enter") {
              e.preventDefault();
              if (filtered[slashMenuIndex]) {
                executeSlashCommand(filtered[slashMenuIndex].id);
              }
              return;
            }
            if (e.key === "Escape") {
              e.preventDefault();
              closeSlashMenu();
              return;
            }
          }

          // 2. Handle TAB (Indentation)
          if (e.key === "Tab") {
            e.preventDefault();
            if (
              block &&
              (block.tagName === "P" ||
                block.classList.contains("list-item-bullet") ||
                block.classList.contains("todo-item"))
            ) {
              if (e.shiftKey) {
                // Outdent
                if (block.classList.contains("indent-2")) {
                  block.classList.remove("indent-2");
                  block.classList.add("indent-1");
                } else if (block.classList.contains("indent-1")) {
                  block.classList.remove("indent-1");
                }
              } else {
                // Indent
                if (block.classList.contains("indent-1")) {
                  block.classList.remove("indent-1");
                  block.classList.add("indent-2");
                } else if (!block.classList.contains("indent-2")) {
                  block.classList.add("indent-1");
                }
              }
              saveCurrentNote();
            }
            return;
          }

          // 4. Handle ENTER
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault(); // Stop creating <div>s

            // Safety check for block existence
            if (!block) {
              // Fallback: If no block, assume we are in editor but maybe on empty line or weird state
              // Create a proper P block and try to move the caret there
              const newP = document.createElement("p");
              newP.contentEditable = true;
              newP.innerHTML = "<br>";
              newP.setAttribute("placeholder", "Type '/' for commands");

              // Append to active editor if possible
              if (activeEditorInstance) {
                // Determine if we should append or insert at cursor?
                // For simplicity, append
                activeEditorInstance.appendChild(newP);
                setCursorToEnd(newP);
              }
              return;
            }

            if (block.classList.contains("list-item-bullet")) {
              const content = block.querySelector(".list-content").innerText;
              if (content.trim() === "") {
                transformBlock(block, "text"); // Exit list
              } else {
                const newItem = createListBlock("bullet");
                block.after(newItem);
                setCursorToEnd(newItem);
              }
            } else if (block.classList.contains("todo-item")) {
              const content = block.querySelector(".list-content").innerText;
              // REVERT: Back to standard behavior (Empty line = Exit list)
              if (content.trim() === "") {
                transformBlock(block, "text"); // Exit list
              } else {
                const newItem = createTodoBlock();
                block.after(newItem);
                setCursorToEnd(newItem);
              }
            } else {
              // CHANGE: In Brain Dump, hitting Enter on an empty text line (Spacer) -> New Checkbox
              const isBrainDump =
                activeEditorInstance &&
                activeEditorInstance.id === "brain-dump-editor";
              const textContent = block.innerText.replace(/\n$/, "").trim();

              if (isBrainDump && block.tagName === "P" && textContent === "") {
                const newTodo = createTodoBlock();
                block.after(newTodo);
                setCursorToEnd(newTodo);
              } else {
                // Default to a new Paragraph
                const newP = document.createElement("p");
                newP.contentEditable = true;
                newP.innerHTML = "<br>"; // Essential for focus
                newP.setAttribute("placeholder", "Type '/' for commands");
                block.after(newP);
                setCursorToEnd(newP);
              }
            }
            saveCurrentNote();
            return;
          }

          // 5. Handle BACKSPACE
          if (e.key === "Backspace") {
            // Check if block exists
            if (!block) {
              // If NO BLOCK, but we are in EDITOR, we might be deleting orphaned text.
              // Let default behavior happen, but check usage.
              return;
            }

            const range = sel.getRangeAt(0);

            // Check if caret is at start of block
            if (range.collapsed && range.startOffset === 0) {
              // NEW: Handle Un-indentation
              if (block.classList.contains("indent-2")) {
                e.preventDefault();
                block.classList.remove("indent-2");
                block.classList.add("indent-1");
                saveCurrentNote();
                return;
              }
              if (block.classList.contains("indent-1")) {
                e.preventDefault();
                block.classList.remove("indent-1");
                saveCurrentNote();
                return;
              }

              // Get text content safely
              const contentEl = block.querySelector(".list-content") || block;
              // Careful with innerText newlines
              const text = contentEl.innerText.replace(/\n$/, "");

              // Case A: Empty block -> Delete or Transform
              if (text.trim() === "") {
                e.preventDefault();

                // If it's a list item, un-list it first (to paragraph)
                if (
                  block.classList.contains("list-item-bullet") ||
                  block.classList.contains("todo-item")
                ) {
                  transformBlock(block, "text");
                  return;
                }

                // If it's a paragraph or heading, delete it if previous block exists
                const prevBlock = block.previousElementSibling;
                if (prevBlock) {
                  block.remove();
                  setCursorToEnd(prevBlock);
                } else {
                  // First block. If it's a Heading, make it a Paragraph?
                  if (block.tagName !== "P") {
                    transformBlock(block, "text");
                  }
                }
                saveCurrentNote();
                return;
              }

              // Case B: Non-empty block, at start.
              // Merge logic (omitted for safety as per original code)
            }
          }

          // 6. Space (Markdown Shortcuts)
          if (e.key === " ") {
            const range = sel.getRangeAt(0);
            if (range.collapsed && range.startContainer.nodeType === 3) {
              const textNode = range.startContainer;
              const text = textNode.textContent.substring(0, range.startOffset); // Text before caret

              let type = null;
              // Existing Shortcuts
              if (text === "#") type = "h1";
              else if (text === "##") type = "h2";
              else if (text === "###") type = "h3";
              else if (text === "-" || text === "*") type = "bullet";
              else if (text === "[]") type = "todo";
              else if (text === ">") type = "quote";
              // NEW Shortcuts
              else if (text === "---") type = "divider";
              else if (text === "|") type = "quote"; // Alternate quote shortcut
              else if (text === "<>") type = "code";

              if (type) {
                e.preventDefault();
                // Consume the space and the markdown chars
                textNode.textContent = textNode.textContent.substring(
                  range.startOffset
                );

                // If it's a valid block?
                if (block) {
                  transformBlock(block, type);
                } else if (activeEditorInstance) {
                  // Orphaned text? Wrap it
                  // This is complex, usually getBlockContainer handles it.
                  // If not found, ignore markdown trigger or wrap manually.
                }
              }
            }
          }
        }

        // --- Saving/Loading logic & Initialization ---

        // ============================================
        // ==         TOPIC NOTES LOGIC              ==
        // ============================================

        let topicNotes = [];
        let activeTopicNoteId = null;

        // ==========================================
        // ==           TASKS TAB GLOBALS          ==
        // ==========================================
        let activeNotesTab = "notes";
        let clockTaskTabs =
          JSON.parse(localStorage.getItem("clockTaskTabs")) || [];
        let activeTaskTabId = localStorage.getItem("activeTaskTabId");

        // --- TOPIC TAG HELPER FUNCTIONS ---
        function addTopicTag(tagName) {
          if (!activeTopicNoteId) return;
          const note = topicNotes.find((n) => n.id === activeTopicNoteId);
          if (!note) return;

          if (!Array.isArray(note.categories)) note.categories = [];

          if (!note.categories.includes(tagName)) {
            note.categories.push(tagName);
            if (
              note.categories.length > 1 &&
              note.categories.includes("General")
            ) {
              note.categories = note.categories.filter((c) => c !== "General");
            }
            note.updated = Date.now();
            saveTopicNotes();
            renderTopicTags(note);
          }
        }

        function removeTopicTag(tagName) {
          if (!activeTopicNoteId) return;
          const note = topicNotes.find((n) => n.id === activeTopicNoteId);
          if (!note) return;

          if (note.categories) {
            note.categories = note.categories.filter((c) => c !== tagName);
            if (note.categories.length === 0) {
              note.categories.push("General");
            }
            note.updated = Date.now();
            saveTopicNotes();
            renderTopicTags(note);
          }
        }

        function renderTopicTags(note) {
          const container = document.getElementById("topic-tags-container");
          if (!container) return;
          container.innerHTML = "";

          (note.categories || []).forEach((cat) => {
            const tag = document.createElement("div");
            tag.className = "topic-tag";
            tag.innerHTML = `<span>${cat}</span>`;

            const removeBtn = document.createElement("div");
            removeBtn.className = "topic-tag-remove";
            removeBtn.innerHTML = "&times;";
            removeBtn.title = "Remove category";
            removeBtn.onclick = (e) => {
              e.stopPropagation();
              removeTopicTag(cat);
            };

            tag.appendChild(removeBtn);
            container.appendChild(tag);
          });
        }

        function initTopicNotes() {
          loadTopicNotes();

          // Tab Click Listener
          document
            .getElementById("tab-topics")
            .addEventListener("click", (e) => {
              e.stopPropagation();
              switchNotesTab("topics");
            });

          // Detail View Listeners
          document
            .getElementById("topic-back-btn")
            .addEventListener("click", () => {
              saveCurrentNote();
              document
                .getElementById("topic-detail-view")
                .classList.add("hidden");
              document
                .getElementById("topic-list-view")
                .classList.remove("hidden");
              activeTopicNoteId = null;
              renderTopicList();
            });

          const titleInput = document.getElementById("topic-title-input");
          const categoryInput = document.getElementById("topic-category-input");
          const editor = document.getElementById("topic-note-editor");

          // Title Auto-save
          titleInput.addEventListener("input", () => {
            if (activeTopicNoteId) {
              const note = topicNotes.find((n) => n.id === activeTopicNoteId);
              if (note) {
                note.title = titleInput.value;
                note.updated = Date.now();
                saveTopicNotes();
              }
            }
          });
          titleInput.addEventListener("click", (e) => e.stopPropagation());

          // -- Tag Input Logic & Dropdown --
          // Helper: Get Unique Categories for Dropdown
          function getUniqueCategories() {
            const allCats = new Set();
            topicNotes.forEach((n) => {
              if (n.categories && Array.isArray(n.categories)) {
                n.categories.forEach((c) => allCats.add(c));
              }
            });
            // Ensure "General" is always there if desired, or exclude if purely dynamic
            // allCats.add("General");
            return Array.from(allCats).sort((a, b) =>
              a.localeCompare(b, undefined, { sensitivity: "base" })
            );
          }

          const categoryDropdown = document.getElementById(
            "category-predictions"
          );
          let currentDropdownSelectionIndex = -1;

          function renderCategoryDropdown(filterText = "") {
            const categories = getUniqueCategories();
            const note = activeTopicNoteId
              ? topicNotes.find((n) => n.id === activeTopicNoteId)
              : null;
            const existing = note ? note.categories || [] : [];

            // Filter: Match text AND exclude already selected
            const matches = categories.filter((cat) => {
              const matchesText = cat
                .toLowerCase()
                .includes(filterText.toLowerCase());
              const alreadySelected = existing.includes(cat);
              return matchesText && !alreadySelected;
            });

            categoryDropdown.innerHTML = "";
            currentDropdownSelectionIndex = -1; // Reset selection on re-render

            if (matches.length === 0) {
              categoryDropdown.classList.remove("visible");
              return;
            }

            matches.forEach((cat, index) => {
              const item = document.createElement("div");
              item.className = "category-dropdown-item";
              // Highlight match
              if (filterText) {
                const regex = new RegExp(`(${filterText})`, "gi");
                item.innerHTML = cat.replace(
                  regex,
                  '<span class="match-highlight">$1</span>'
                );
              } else {
                item.textContent = cat;
              }

              item.onmousedown = (e) => {
                e.preventDefault(); // Prevent blur
                addTopicTag(cat);
                categoryInput.value = "";
                categoryDropdown.classList.remove("visible");
              };
              categoryDropdown.appendChild(item);
            });

            categoryDropdown.classList.add("visible");
          }

          function highlightDropdownItem(index) {
            const items = categoryDropdown.querySelectorAll(
              ".category-dropdown-item"
            );
            items.forEach((item, i) => {
              if (i === index) item.classList.add("selected-nav");
              else item.classList.remove("selected-nav");
            });
            // Scroll to view
            if (index >= 0 && items[index]) {
              items[index].scrollIntoView({ block: "nearest" });
            }
          }

          categoryInput.addEventListener("focus", () => {
            renderCategoryDropdown(categoryInput.value.trim());
          });

          categoryInput.addEventListener("input", () => {
            renderCategoryDropdown(categoryInput.value.trim());
          });

          categoryInput.addEventListener("blur", () => {
            // Delay hide to allow click
            setTimeout(() => {
              categoryDropdown.classList.remove("visible");
            }, 150);
          });

          categoryInput.addEventListener("keydown", (e) => {
            if (e.key === "ArrowDown") {
              e.preventDefault();
              const items = categoryDropdown.querySelectorAll(
                ".category-dropdown-item"
              );
              if (items.length > 0) {
                currentDropdownSelectionIndex =
                  (currentDropdownSelectionIndex + 1) % items.length;
                highlightDropdownItem(currentDropdownSelectionIndex);
              }
              return;
            }
            if (e.key === "ArrowUp") {
              e.preventDefault();
              const items = categoryDropdown.querySelectorAll(
                ".category-dropdown-item"
              );
              if (items.length > 0) {
                currentDropdownSelectionIndex =
                  (currentDropdownSelectionIndex - 1 + items.length) %
                  items.length;
                highlightDropdownItem(currentDropdownSelectionIndex);
              }
              return;
            }

            if (e.key === "Enter") {
              e.preventDefault();
              // Priority 1: Select from dropdown if highlighted
              if (
                currentDropdownSelectionIndex >= 0 &&
                categoryDropdown.classList.contains("visible")
              ) {
                const items = categoryDropdown.querySelectorAll(
                  ".category-dropdown-item"
                );
                if (items[currentDropdownSelectionIndex]) {
                  // Trigger mousedown logic/select
                  items[currentDropdownSelectionIndex].onmousedown(
                    new Event("mousedown")
                  ); // Simulate
                  return; // Done
                }
              }
              // Priority 2: Standard "Add New"
              const val = categoryInput.value.trim().replace(/,/g, "");
              if (val) {
                addTopicTag(val);
                categoryInput.value = "";
                categoryDropdown.classList.remove("visible");
              }
            } else if (e.key === "," || e.key === "Tab") {
              e.preventDefault();
              const val = categoryInput.value.trim().replace(/,/g, "");
              if (val) {
                addTopicTag(val);
                categoryInput.value = "";
                categoryDropdown.classList.remove("visible");
              }
            } else if (e.key === "Backspace" && categoryInput.value === "") {
              // Remove last tag
              if (activeTopicNoteId) {
                const note = topicNotes.find((n) => n.id === activeTopicNoteId);
                if (note && note.categories && note.categories.length > 0) {
                  note.categories.pop();
                  if (note.categories.length === 0)
                    note.categories.push("General");
                  saveTopicNotes();
                  renderTopicTags(note);
                }
              }
              categoryDropdown.classList.remove("visible");
            }
          });

          // Old Blur logic removed (replaced above)

          // Editor interaction
          editor.addEventListener("focus", () => {
            activeEditorInstance = editor;
          });

          editor.addEventListener("input", () => {
            clearTimeout(window.saveTimeout);
            window.saveTimeout = setTimeout(saveCurrentNote, 500);
          });

          // ==========================================
          // ==           TASKS TAB LOGIC            ==
          // ==========================================

          let activeNotesTab = "notes";
          let clockTaskTabs =
            JSON.parse(localStorage.getItem("clockTaskTabs")) || [];
          let activeTaskTabId = localStorage.getItem("activeTaskTabId");

          function saveTaskTabs() {
            localStorage.setItem(
              "clockTaskTabs",
              JSON.stringify(clockTaskTabs)
            );
            localStorage.setItem("activeTaskTabId", activeTaskTabId);
          }

          function renderTaskTabs() {
            const tabTasksList = document.getElementById("task-tabs-list");
            if (!tabTasksList) return;
            tabTasksList.innerHTML = "";
            clockTaskTabs.forEach((tab) => {
              const tabEl = document.createElement("div");
              tabEl.className = `task-tab ${
                tab.id === activeTaskTabId ? "active" : ""
              }`;

              const nameSpan = document.createElement("span");
              nameSpan.className = "task-tab-name";
              nameSpan.textContent = tab.name;

              // NEW: Single Click Rename Logic
              nameSpan.onclick = (e) => {
                if (tab.id === activeTaskTabId) {
                  e.stopPropagation();
                  const input = document.createElement("input");
                  input.className = "task-tab-input";
                  input.value = tab.name;

                  const save = () => {
                    let newName = input.value.trim();
                    if (newName && newName !== "") {
                      tab.name = newName;
                      saveTaskTabs();
                    }
                    renderTaskTabs();
                  };

                  input.onblur = save;
                  input.onkeydown = (ev) => {
                    if (ev.key === "Enter") {
                      input.blur();
                    }
                    if (ev.key === "Escape") {
                      renderTaskTabs();
                    }
                    ev.stopPropagation();
                  };

                  tabEl.innerHTML = "";
                  tabEl.appendChild(input);
                  input.focus();
                  input.select();
                }
              };

              const closeBtn = document.createElement("span");
              closeBtn.className = "task-tab-close-btn";
              closeBtn.innerHTML = "&times;";
              closeBtn.onclick = (e) => {
                e.stopPropagation();
                deleteTaskTab(tab.id);
              };

              tabEl.onclick = (e) => {
                if (e.target.tagName === "INPUT") return;
                switchTaskTab(tab.id);
              };

              tabEl.appendChild(nameSpan);
              if (clockTaskTabs.length > 1) {
                tabEl.appendChild(closeBtn);
              }
              tabTasksList.appendChild(tabEl);

              if (tab.id === activeTaskTabId) {
                tabEl.scrollIntoView({
                  behavior: "smooth",
                  block: "nearest",
                  inline: "center",
                });
              }
            });
          }

          function addTaskTab() {
            const newTab = {
              id: "tab-" + Date.now(),
              name: "New Tab",
              content: `<div class="todo-item">
                              <input type="checkbox" class="todo-checkbox">
                              <div class="list-content" placeholder="Dump your tasks here..."></div>
                            </div>`,
            };
            clockTaskTabs.push(newTab);
            switchTaskTab(newTab.id);
          }

          function switchTaskTab(id) {
            saveTaskTabContent();
            activeTaskTabId = id;
            saveTaskTabs();
            renderTaskTabs();
            renderBrainDump();
          }

          function saveTaskTabContent() {
            const brainDumpList = document.getElementById("brain-dump-list");
            const activeTab = clockTaskTabs.find(
              (t) => t.id === activeTaskTabId
            );
            if (activeTab && brainDumpList) {
              activeTab.content = brainDumpList.innerHTML;
              saveTaskTabs();
            }
          }

          function updateTabName(id, currentName) {
            const tab = clockTaskTabs.find((t) => t.id === id);
            if (!tab) return;
            renderTaskTabs();
            const newName = prompt("Rename Tab:", currentName);
            if (newName && newName.trim() !== "") {
              tab.name = newName.trim();
              saveTaskTabs();
              renderTaskTabs();
            }
          }

          function deleteTaskTab(id) {
            const tab = clockTaskTabs.find((t) => t.id === id);
            if (!tab) return;

            const modalOverlay = document.getElementById("confirmation-modal");
            const title = document.getElementById("confirmation-title");
            const desc = document.getElementById("confirmation-desc");
            const confirmBtn = document.getElementById(
              "confirmation-btn-confirm"
            );
            const cancelBtn = document.getElementById(
              "confirmation-btn-cancel"
            );

            title.textContent = "Delete Tab?";
            desc.textContent = `Are you sure you want to delete "${tab.name}" and all its tasks?`;
            modalOverlay.classList.add("visible");

            const cleanup = () => {
              modalOverlay.classList.remove("visible");
              confirmBtn.onclick = null;
              cancelBtn.onclick = null;
            };

            confirmBtn.onclick = () => {
              performDelete(id);
              cleanup();
            };

            cancelBtn.onclick = cleanup;
          }

          function performDelete(id) {
            clockTaskTabs = clockTaskTabs.filter((t) => t.id !== id);
            if (clockTaskTabs.length === 0) {
              clockTaskTabs.push({
                id: "tab-" + Date.now(),
                name: "General",
                content: `<div class="todo-item"><input type="checkbox" class="todo-checkbox"><div class="list-content" placeholder="Dump your tasks here..."></div></div>`,
              });
            }

            if (activeTaskTabId === id) {
              activeTaskTabId = clockTaskTabs[0].id;
            }
            saveTaskTabs();
            renderTaskTabs();
            renderBrainDump();
          }

          function renderBrainDump() {
            const brainDumpList = document.getElementById("brain-dump-list");
            const activeTab = clockTaskTabs.find(
              (t) => t.id === activeTaskTabId
            );
            const content = activeTab ? activeTab.content : "";

            if (brainDumpList && brainDumpList.innerHTML !== content) {
              brainDumpList.innerHTML = content;
            }

            if (brainDumpList) {
              brainDumpList.oninput = () => {
                activeEditorInstance = brainDumpList;
                saveTaskTabContent();
              };

              brainDumpList.onfocus = () => {
                activeEditorInstance = brainDumpList;
              };
            }
          }
        }

        function switchNotesTab(tab) {
          activeNotesTab = tab;
          localStorage.setItem("notesTabState", tab);

          const tabNotes = document.getElementById("tab-notes");
          const tabTasks = document.getElementById("tab-tasks");
          const tabTopics = document.getElementById("tab-topics");
          const finalNotesContentContainer = document.getElementById(
            "notes-content-container"
          );
          const tasksContentContainer = document.getElementById(
            "tasks-content-container"
          );
          const topicListContainer = document.getElementById("topic-list-view");
          const topicDetailContainer =
            document.getElementById("topic-detail-view");
          const topicFilterContainer = document.getElementById(
            "topic-filter-container"
          );
          const clearTasksBtn = document.getElementById("clear-tasks-btn");
          const addElementBtn = document.getElementById("add-element-btn");
          const jumpToTodayBtn = document.getElementById("jump-to-today-btn");

          // Reset UI - remove active from all tabs
          if (tabNotes) tabNotes.classList.remove("active");
          if (tabTasks) tabTasks.classList.remove("active");
          if (tabTopics) tabTopics.classList.remove("active");

          // Hide all content containers
          finalNotesContentContainer.classList.add("hidden");
          tasksContentContainer.classList.add("hidden");
          topicListContainer.classList.add("hidden");
          topicDetailContainer.classList.add("hidden");
          topicDetailContainer.style.display = "none"; // Reset inline style
          if (topicFilterContainer)
            topicFilterContainer.classList.add("hidden");

          if (tab === "notes") {
            if (tabNotes) tabNotes.classList.add("active");
            finalNotesContentContainer.classList.remove("hidden");

            if (clearTasksBtn) clearTasksBtn.style.display = "none";
            if (addElementBtn) addElementBtn.style.display = "flex";
            renderNotesWidget();
            if (jumpToTodayBtn) jumpToTodayBtn.style.display = "";
          } else if (tab === "tasks") {
            if (tabTasks) tabTasks.classList.add("active");
            tasksContentContainer.classList.remove("hidden");

            if (clearTasksBtn) clearTasksBtn.style.display = "flex";
            if (addElementBtn) addElementBtn.style.display = "none";
            renderTaskTabs();
            renderBrainDump();

            if (jumpToTodayBtn) {
              jumpToTodayBtn.classList.remove("visible");
              jumpToTodayBtn.style.display = "none";
            }
          } else if (tab === "topics") {
            if (tabTopics) tabTopics.classList.add("active");

            if (activeTopicNoteId) {
              topicDetailContainer.classList.remove("hidden");
              topicDetailContainer.style.display = "flex";
            } else {
              topicListContainer.classList.remove("hidden");
              renderTopicList(); // Fix: Ensure list is rendered when showing
            }

            if (clearTasksBtn) clearTasksBtn.style.display = "none";
            if (addElementBtn) addElementBtn.style.display = "flex"; // For adding new topic

            if (jumpToTodayBtn) {
              jumpToTodayBtn.classList.remove("visible");
              jumpToTodayBtn.style.display = "none";
            }
          }
        }

        function loadTopicNotes() {
          const saved = localStorage.getItem("clockTopicNotes");
          topicNotes = saved ? JSON.parse(saved) : [];

          // MIGRATION: Single Category -> Multi-Category
          let migrated = false;
          topicNotes.forEach((note) => {
            if (!Array.isArray(note.categories)) {
              migrated = true;
              note.categories = [];
              if (note.category && note.category.trim() !== "") {
                note.categories.push(note.category.trim());
              } else {
                note.categories.push("General");
              }
              // Clean up legacy field
              delete note.category;
            }
          });

          if (migrated) {
            saveTopicNotes();
            console.log("Migrated notes to multi-category format.");
          }
        }

        // Feature: Category Filter State
        let activeTopicCategoryFilter = "All"; // Session persistence

        function saveTopicNotes() {
          localStorage.setItem("clockTopicNotes", JSON.stringify(topicNotes));
        }

        function renderTopicList() {
          const listView = document.getElementById("topic-list-view");
          listView.innerHTML = "";

          if (topicNotes.length === 0) {
            const emptyState = document.createElement("div");
            emptyState.className = "empty-state-message";
            emptyState.style.cssText =
              "padding: 2rem; text-align: center; color: var(--secondary-color); opacity: 0.6; cursor: pointer;";
            emptyState.textContent =
              'No topics yet. Click here or "+" to create one.';
            emptyState.onclick = createNewTopicNote;
            listView.appendChild(emptyState);
            return;
          }

          // Sort by updated (newest first)
          const sorted = [...topicNotes].sort((a, b) => b.updated - a.updated);

          // --- FILTER LOGIC ---
          // 1. Extract Categories
          const categories = new Set(["All"]);
          sorted.forEach((note) => {
            if (Array.isArray(note.categories)) {
              note.categories.forEach((c) => categories.add(c));
            } else {
              categories.add("General");
            }
          });

          // 2. Render Filters
          const filterContainer = document.getElementById(
            "topic-filter-container"
          );
          if (filterContainer) {
            if (topicNotes.length > 0) {
              filterContainer.classList.remove("hidden");
              filterContainer.innerHTML = "";

              let catArray = Array.from(categories)
                .filter((c) => c !== "All")
                .sort();
              catArray.unshift("All");

              catArray.forEach((cat) => {
                const chip = document.createElement("div");
                chip.className = `filter-chip ${
                  activeTopicCategoryFilter === cat ? "active" : ""
                }`;
                chip.textContent = cat;
                chip.onclick = () => setTopicCategoryFilter(cat);

                // Feature: Rename (Double Click) & Delete (Right Click)
                if (cat !== "All" && cat !== "General") {
                  chip.title = "Double-click to rename, Right-click to delete";

                  chip.ondblclick = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    const newName = prompt("Rename category:", cat);
                    if (
                      newName &&
                      newName.trim() !== "" &&
                      newName.trim() !== cat
                    ) {
                      const finalName = newName.trim();
                      // Rename in all notes
                      let changed = false;
                      topicNotes.forEach((n) => {
                        if (n.categories && n.categories.includes(cat)) {
                          const idx = n.categories.indexOf(cat);
                          n.categories[idx] = finalName;
                          // Prevent duplicates if new name already exists in note
                          // (e.g. Note had both "Work" and "Job", renamed "Job" -> "Work")
                          n.categories = [...new Set(n.categories)];
                          n.updated = Date.now();
                          changed = true;
                        }
                      });

                      if (changed) {
                        if (activeTopicCategoryFilter === cat) {
                          activeTopicCategoryFilter = finalName;
                        }
                        saveTopicNotes();
                        renderTopicList();
                      }
                    }
                  };

                  chip.oncontextmenu = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (
                      confirm(
                        `Delete category "${cat}"? This will remove it from all notes.`
                      )
                    ) {
                      let changed = false;
                      topicNotes.forEach((n) => {
                        if (n.categories && n.categories.includes(cat)) {
                          n.categories = n.categories.filter((c) => c !== cat);
                          if (n.categories.length === 0) {
                            n.categories.push("General");
                          }
                          n.updated = Date.now();
                          changed = true;
                        }
                      });

                      if (changed) {
                        if (activeTopicCategoryFilter === cat) {
                          activeTopicCategoryFilter = "All";
                        }
                        saveTopicNotes();
                        renderTopicList();
                      }
                    }
                  };
                }

                filterContainer.appendChild(chip);
              });
            } else {
              filterContainer.classList.add("hidden");
            }
          }

          // 3. Apply Filter
          const filteredNotes = sorted.filter((note) => {
            if (activeTopicCategoryFilter === "All") return true;
            return (note.categories || []).includes(activeTopicCategoryFilter);
          });

          if (filteredNotes.length === 0 && topicNotes.length > 0) {
            const noMatch = document.createElement("div");
            noMatch.style.padding = "2rem";
            noMatch.style.textAlign = "center";
            noMatch.style.opacity = "0.6";
            noMatch.textContent = "No notes found in this category.";
            listView.appendChild(noMatch);
            return;
          }

          filteredNotes.forEach((note) => {
            const card = document.createElement("div");
            card.className = "topic-card";
            card.onclick = () => openTopicNote(note.id);

            const header = document.createElement("div");
            header.className = "topic-card-header";
            header.style.display = "flex";
            header.style.justifyContent = "space-between";
            header.style.alignItems = "flex-start";
            header.style.gap = "6px";

            // Title Container
            const titleContainer = document.createElement("div");
            titleContainer.style.flex = "1";
            titleContainer.style.display = "flex";
            titleContainer.style.flexDirection = "column";
            titleContainer.style.gap = "6px";
            titleContainer.style.minWidth = "0"; // For text overflow

            // Title
            const title = document.createElement("div");
            title.className = "topic-card-title";
            title.textContent = note.title || "Untitled";
            title.style.width = "100%";

            // Tags Row
            const tagsRow = document.createElement("div");
            tagsRow.style.display = "flex";
            tagsRow.style.flexWrap = "wrap";
            tagsRow.style.gap = "4px";

            (note.categories || ["General"]).forEach((cat) => {
              const catInfo = document.createElement("div");
              catInfo.className = "topic-card-category";
              catInfo.style.margin = "0";
              catInfo.textContent = cat;

              // Colorize
              let hash = 0;
              for (let i = 0; i < cat.length; i++) {
                hash = cat.charCodeAt(i) + ((hash << 5) - hash);
              }
              const hue = Math.abs(hash % 360);
              catInfo.style.backgroundColor = `hsl(${hue}, 70%, 90%)`;
              catInfo.style.color = `hsl(${hue}, 60%, 30%)`;

              tagsRow.appendChild(catInfo);
            });

            titleContainer.appendChild(title);
            titleContainer.appendChild(tagsRow);

            // Delete Button
            const deleteBtn = document.createElement("button");
            deleteBtn.className = "topic-delete-btn"; // Add CSS if needed, or inline
            deleteBtn.innerHTML = "&times;";
            deleteBtn.title = "Delete Note";
            deleteBtn.style.background = "none";
            deleteBtn.style.border = "none";
            deleteBtn.style.fontSize = "1.2rem";
            deleteBtn.style.lineHeight = "1";
            deleteBtn.style.color = "var(--secondary-color)";
            deleteBtn.style.cursor = "pointer";
            deleteBtn.style.padding = "0 4px";
            deleteBtn.style.opacity = "0.6";
            deleteBtn.style.transition = "color 0.2s";

            deleteBtn.onmouseover = () => {
              deleteBtn.style.color = "#ff3b30";
              deleteBtn.style.opacity = "1";
            };
            deleteBtn.onmouseout = () => {
              deleteBtn.style.color = "var(--secondary-color)";
              deleteBtn.style.opacity = "0.6";
            };

            deleteBtn.onclick = (e) => {
              e.stopPropagation();
              e.preventDefault();
              // Delete Functionality
              if (
                confirm(
                  `Are you sure you want to delete "${
                    note.title || "Untitled"
                  }"?`
                )
              ) {
                topicNotes = topicNotes.filter((n) => n.id !== note.id);
                saveTopicNotes();
                renderTopicList();
              }
            };

            header.appendChild(titleContainer);
            header.appendChild(deleteBtn);

            const preview = document.createElement("div");
            preview.className = "topic-card-preview";
            const tempDiv = document.createElement("div");
            tempDiv.innerHTML = note.content;
            preview.textContent =
              tempDiv.innerText.substring(0, 100) || "No content...";

            card.appendChild(header);
            card.appendChild(preview);
            listView.appendChild(card);
          });
        }

        function setTopicCategoryFilter(category) {
          activeTopicCategoryFilter = category;
          renderTopicList();
        }

        function openTopicNote(id) {
          const note = topicNotes.find((n) => n.id === id);
          if (!note) return;

          activeTopicNoteId = id;
          document.getElementById("topic-list-view").classList.add("hidden");
          const detailView = document.getElementById("topic-detail-view");
          detailView.classList.remove("hidden");
          detailView.style.display = "flex";

          document.getElementById("topic-title-input").value = note.title || "";
          document.getElementById("topic-category-input").value = "";
          renderTopicTags(note);

          const editor = document.getElementById("topic-note-editor");
          editor.innerHTML = note.content || "<p><br></p>";

          activeEditorInstance = editor;
        }

        function createNewTopicNote() {
          const newNote = {
            id: "topic-" + Date.now(),
            title: "",
            categories: ["General"],
            content: "<p><br></p>",
            created: Date.now(),
            updated: Date.now(),
          };
          topicNotes.push(newNote);
          saveTopicNotes();
          renderTopicList(); // Update list state even though hidden
          openTopicNote(newNote.id);
          // Focus title
          setTimeout(
            () => document.getElementById("topic-title-input").focus(),
            100
          );
        }

        function saveCurrentNote() {
          if (!activeEditorInstance) return;

          // Handle Topic Notes Save
          if (activeEditorInstance.id === "topic-note-editor") {
            if (activeTopicNoteId) {
              const note = topicNotes.find((n) => n.id === activeTopicNoteId);
              if (note) {
                note.content = activeEditorInstance.innerHTML;
                note.updated = Date.now();
                saveTopicNotes();
              }
            }
            return;
          }

          // Handle Brain Dump Save
          if (activeEditorInstance.id === "brain-dump-editor") {
            localStorage.setItem(
              "clockBrainDumpHTML",
              activeEditorInstance.innerHTML
            );
            return;
          }

          // Handle Daily Notes Save
          const dateKey = activeEditorInstance.dataset.datekey;
          if (dateKey) {
            notesByDate[dateKey] = activeEditorInstance.innerHTML;
            saveNotes();
          }
        }

        // Attach global keydown listener (delegated)
        document.addEventListener("keydown", (e) => {
          if (e.target.closest(".note-editor")) {
            handleKeyDown(e);
          }
        });

        // Sanitize paste (simple version)
        document.addEventListener("paste", (e) => {
          if (e.target.closest(".note-editor")) {
            // ideally strip styling
            // e.preventDefault();
            // const text = e.clipboardData.getData('text/plain');
            // document.execCommand('insertText', false, text);
          }
        });

        // ============================================
        // ==  END NOTION-LIKE NOTES WIDGET LOGIC    ==
        // ============================================

        /**
         * [REPLACEMENT] Loads and saves notes from/to local storage.
         */
        function loadNotes() {
          const savedNotes = localStorage.getItem("clockTasksProNotes");
          notesByDate = savedNotes ? JSON.parse(savedNotes) : {};
        }
        function saveNotes() {
          localStorage.setItem(
            "clockTasksProNotes",
            JSON.stringify(notesByDate)
          );
        }

        /**
         * [REPLACEMENT] Formats the date for display in the note section header.
         */
        function formatNoteDateHeader(date) {
          // ... (Same as before)
          const today = new Date();
          const yesterday = new Date();
          yesterday.setDate(today.getDate() - 1);
          const options = { day: "numeric", month: "long", year: "numeric" };
          if (getDateKey(date) === getDateKey(today))
            return `Today  ${today.toLocaleDateString("en-US", options)}`;
          if (getDateKey(date) === getDateKey(yesterday))
            return `Yesterday  ${yesterday.toLocaleDateString(
              "en-US",
              options
            )}`;
          return date.toLocaleDateString("en-US", options);
        }

        /**
         * [REPLACEMENT] Creates the DOM elements for a single day's note section.
         */
        function createNoteSection(date, isFocused) {
          const dateKey = getDateKey(date);
          const section = document.createElement("div");
          section.className = "note-section";
          section.id = `note-section-${dateKey}`;
          if (isFocused) section.classList.add("focused");
          if (getDateKey(date) === getDateKey(new Date()))
            section.classList.add("is-today");

          // Header Container
          const headerContainer = document.createElement("div");
          Object.assign(headerContainer.style, {
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            marginBottom: "1.5rem",
          });

          const header = document.createElement("h3");
          header.className = "note-section-header";
          header.textContent = formatNoteDateHeader(date);
          header.style.marginBottom = "0";

          // Delete Button
          const deleteBtn = document.createElement("button");
          deleteBtn.title = "Delete Note";
          deleteBtn.innerHTML =
            '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>';

          Object.assign(deleteBtn.style, {
            background: "transparent",
            border: "none",
            cursor: "pointer",
            color: "var(--secondary-color)",
            opacity: "0.4",
            padding: "4px",
            borderRadius: "4px",
            transition: "all 0.2s ease",
          });

          deleteBtn.addEventListener("mouseenter", () => {
            deleteBtn.style.opacity = "1";
            deleteBtn.style.color = "#ff3b30";
            deleteBtn.style.backgroundColor = "rgba(255, 59, 48, 0.1)";
          });
          deleteBtn.addEventListener("mouseleave", () => {
            deleteBtn.style.opacity = "0.4";
            deleteBtn.style.color = "var(--secondary-color)";
            deleteBtn.style.backgroundColor = "transparent";
          });

          deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            if (
              confirm(
                "Are you sure you want to delete all notes for this date?"
              )
            ) {
              delete notesByDate[dateKey];
              saveNotes();
              renderNotesWidget();
            }
          });

          headerContainer.appendChild(header);
          headerContainer.appendChild(deleteBtn);

          const editor = document.createElement("div");
          editor.className = "note-editor";
          editor.contentEditable = true;
          editor.dataset.datekey = dateKey;
          editor.setAttribute("spellcheck", "false");

          // Initial content check
          let content = notesByDate[dateKey] || "";
          if (!content.trim()) {
            content = `<p placeholder="Type '/' for commands"><br></p>`;
          }
          editor.innerHTML = content;

          // Attach listener to save on input
          editor.addEventListener("input", () => {
            activeEditorInstance = editor;
            saveCurrentNote();
          });

          editor.addEventListener("focus", () => {
            activeEditorInstance = editor;
            currentNotesDate = date; // Update current date context
          });

          section.appendChild(headerContainer);
          section.appendChild(editor);

          return section;
        }

        /**
         * [REPLACEMENT] Renders the entire content of the notes widget.
         */
        function renderNotesWidget() {
          // ... (Same as before)
          const focusedDateKey = getDateKey(currentNotesDate);
          const todayKey = getDateKey(new Date());
          notesContainer.innerHTML = "";

          const datesToRender = new Set(
            Object.keys(notesByDate).filter((key) =>
              notesByDate[key]?.replace(/<[^>]*>?/gm, "").trim()
            )
          );
          datesToRender.add(focusedDateKey);

          const sortedDateKeys = Array.from(datesToRender).sort();

          sortedDateKeys.forEach((dateKey) => {
            const date = new Date(dateKey + "T00:00:00");
            const isFocused = dateKey === focusedDateKey;
            const section = createNoteSection(date, isFocused);
            notesContainer.appendChild(section);
          });

          // ... (Intersection observer logic same as before, see snippet below)
          const focusedElement = document.querySelector(
            ".note-section.focused"
          );
          if (focusedElement) {
            // Check if widget is visible (not collapsed) before scrolling
            const widget = document.getElementById("notes-widget");
            const isHidden = widget.classList.contains("collapsed");

            if (!isHidden && !hasInitialNotesScrollHappened) {
              setTimeout(() => {
                focusedElement.scrollIntoView({
                  behavior: "auto",
                  block: "start",
                });
                hasInitialNotesScrollHappened = true;
              }, 50);
            }
          }

          if (todayObserver) todayObserver.disconnect();
          const todayElement = document.getElementById(
            `note-section-${todayKey}`
          );
          if (todayElement) {
            todayObserver = new IntersectionObserver(
              (entries) =>
                jumpToTodayBtn.classList.toggle(
                  "visible",
                  !entries[0].isIntersecting
                ),
              { root: notesContainer, threshold: 0.1 }
            );
            todayObserver.observe(todayElement);
          } else {
            jumpToTodayBtn.classList.toggle(
              "visible",
              focusedDateKey !== todayKey
            );
          }
        }

        // --- Subtask Management Logic (New Feature - V2 with Bug Fixes) ---

        function saveTasks() {
          localStorage.setItem("clockTasksPro", JSON.stringify(tasksByDate));
        }

        function formatSecondsToMMSS(totalSeconds) {
          if (isNaN(totalSeconds) || totalSeconds < 0) totalSeconds = 0;
          const minutes = Math.floor(totalSeconds / 60);
          const seconds = Math.floor(totalSeconds % 60);
          return `${String(minutes).padStart(2, "0")}:${String(
            seconds
          ).padStart(2, "0")}`;
        }

        function getCurrentWidgetTask() {
          if (!currentWidgetTaskId) return null;
          const dateKey = getDateKey(selectedDate);
          return (tasksByDate[dateKey] || []).find(
            (t) => t.id === currentWidgetTaskId
          );
        }

        // --- Event Handlers for Subtasks ---

        function handleAddSubtask() {
          const task = getCurrentWidgetTask();
          if (!task) return;
          if (!task.subtasks) task.subtasks = [];

          // Create the new subtask data object
          const newSubtask = {
            id: Date.now(),
            name: "New Subtask",
            completed: false,
            setDurationSeconds: null,
            elapsedSeconds: 0,
            timerStartTime: null,
            isPaused: true,
            isEditingTime: false,
          };
          task.subtasks.push(newSubtask);
          saveTasks();

          // Render the entire subtask UI, which creates the new element in the DOM
          renderSubtasksUI(task);

          // --- NEW LOGIC: Focus and select the new subtask name ---
          // Find the newly created card element using its unique data attribute
          const newCardEl = document.querySelector(
            `[data-subtask-id="${newSubtask.id}"]`
          );
          if (newCardEl) {
            const nameEl = newCardEl.querySelector(".subtask-name");
            if (nameEl) {
              // 1. Set focus to the element
              nameEl.focus();

              // 2. Use the Range and Selection APIs to select all text within it
              const selection = window.getSelection();
              const range = document.createRange();
              range.selectNodeContents(nameEl);
              selection.removeAllRanges(); // Clear any previous selections
              selection.addRange(range); // Apply the new selection
            }
          }
        }

        function handleDeleteSubtask(subtaskId) {
          if (!confirm("Are you sure you want to delete this subtask?")) return;
          const task = getCurrentWidgetTask();
          if (!task || !task.subtasks) return;
          task.subtasks = task.subtasks.filter((st) => st.id !== subtaskId);
          saveTasks();
          renderSubtasksUI(task);
        }

        function handleSubtaskNameChange(subtask, newName) {
          subtask.name = newName.trim() || "Untitled Subtask";
          saveTasks();
        }

        function handleSubtaskCompletionToggle(subtask) {
          subtask.completed = !subtask.completed;
          if (subtask.completed && !subtask.isPaused) {
            subtask.isPaused = true;
            const elapsed = (Date.now() - subtask.timerStartTime) / 1000;
            subtask.elapsedSeconds += elapsed;
            subtask.timerStartTime = null;
          }
          saveTasks();
          renderSubtasksUI(getCurrentWidgetTask());
        }

        function handleSetSubtaskTime(subtask, minutes) {
          if (isNaN(minutes) || minutes <= 0) return;
          subtask.setDurationSeconds = minutes * 60;
          subtask.isEditingTime = false; // <<< Turn off editing mode
          // If the timer was not running, start it. If it was, it remains paused.
          if (subtask.isPaused && subtask.elapsedSeconds === 0) {
            subtask.isPaused = false;
            subtask.timerStartTime = Date.now();
          }
          saveTasks();
          renderSubtasksUI(getCurrentWidgetTask());
        }

        function handleSetRemainingTime(subtask) {
          const task = getCurrentWidgetTask();
          if (!task) return;
          const now = new Date();
          const currentHour24 = now.getHours() + now.getMinutes() / 60;
          const remainingHours = task.endHour - currentHour24;

          if (remainingHours > 0) {
            subtask.setDurationSeconds = remainingHours * 3600;
            subtask.isEditingTime = false;
            subtask.isPaused = false;
            subtask.timerStartTime = Date.now();
            saveTasks();
            renderSubtasksUI(getCurrentWidgetTask());
          }
        }

        function handleSubtaskTimerToggle(subtask) {
          if (subtask.isPaused) {
            subtask.isPaused = false;
            subtask.timerStartTime = Date.now();
          } else {
            subtask.isPaused = true;
            const elapsed = (Date.now() - subtask.timerStartTime) / 1000;
            subtask.elapsedSeconds += elapsed;
            subtask.timerStartTime = null;
          }
          saveTasks();
          // Don't re-render the whole UI, just update timers, which happens in the interval
          // This prevents UI jumps. The icon will update on the next render pass.
          updateSubtaskTimersUI();
        }

        function handleEditSubtaskTime(subtask) {
          // Pause the timer if it's running before entering edit mode
          if (!subtask.isPaused) {
            subtask.isPaused = true;
            const elapsed = (Date.now() - subtask.timerStartTime) / 1000;
            subtask.elapsedSeconds += elapsed;
            subtask.timerStartTime = null;
          }
          subtask.isEditingTime = true;
          saveTasks();
          renderSubtasksUI(getCurrentWidgetTask());
        }

        // --- UI Rendering for Subtasks ---

        function renderSubtasksUI(task) {
          const subtasksSection = document.getElementById("subtasks-section");
          if (!task || task.completed) {
            subtasksSection.classList.add("hidden");
            return;
          }
          subtasksSection.classList.remove("hidden");

          const container = document.getElementById("subtasks-container");
          const controlsContainer = document.getElementById(
            "subtask-controls-container"
          );
          container.innerHTML = "";
          controlsContainer.innerHTML = "";

          const subtasks = task.subtasks || [];
          subtasks.forEach((subtask) => {
            const card = document.createElement("div");
            card.className = "subtask-card";
            card.dataset.subtaskId = subtask.id;
            if (subtask.completed) card.classList.add("completed");

            const checkmarkSVG = `<svg viewBox="0 0 24 24" fill="none"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
            const deleteBtnSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>`;

            let timeSectionHtml = "";
            // Show input if time is not set OR if we are explicitly editing it
            if (subtask.setDurationSeconds === null || subtask.isEditingTime) {
              const currentMinutes = subtask.setDurationSeconds
                ? Math.round(subtask.setDurationSeconds / 60)
                : "";
              timeSectionHtml = `
          <div class="subtask-time-controls">
            <input type="number" class="subtask-time-input" placeholder="min" min="1" value="${currentMinutes}">
            <button class="subtask-time-btn time-up-btn" title="Use remaining time in main task">
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z"></path><path d="M12 6v6l4 2"></path></svg>
            </button>
            <button class="subtask-time-btn set-time-btn hidden" title="Set custom time">
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>
            </button>
          </div>`;
            } else {
              const isPaused = subtask.isPaused || subtask.completed;
              const playPauseIcon = isPaused
                ? `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg>`
                : `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>`;
              timeSectionHtml = `
          <div class="subtask-time-controls">
            <div class="subtask-timer-display" id="timer-display-${
              subtask.id
            }" title="Click to edit time"></div>

            <button class="subtask-time-btn pip-btn" title="Picture in Picture" style="margin-right: 4px;">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="4" width="20" height="16" rx="2"/><rect x="12" y="10" width="8" height="6" rx="1"/></svg>
            </button>

            <button class="subtask-time-btn play-pause-btn" title="${
              isPaused ? "Resume" : "Pause"
            }">${playPauseIcon}</button>
          </div>`;
            }

            card.innerHTML = `
        <div class="subtask-main">
          <div class="subtask-checkbox">${checkmarkSVG}</div>
          <span class="subtask-name" contenteditable="true" spellcheck="false">${
            subtask.name
          }</span>
          ${timeSectionHtml}
          <button class="subtask-delete-btn" title="Delete subtask">${deleteBtnSVG}</button>
        </div>
        <div class="subtask-progress-container ${
          subtask.setDurationSeconds === null ? "hidden" : ""
        }">
          <div class="subtask-progress-bar" id="progress-${
            subtask.id
          }" style="background-color: ${task.color};"></div>
        </div>`;

            container.appendChild(card);

            // --- Attach Event Listeners ---
            const nameEl = card.querySelector(".subtask-name");
            nameEl.addEventListener("keydown", (e) => {
              if (e.key === "Enter") {
                e.preventDefault();
                nameEl.blur();
              }
            });
            nameEl.addEventListener("blur", () =>
              handleSubtaskNameChange(subtask, nameEl.textContent)
            );
            card
              .querySelector(".subtask-checkbox")
              .addEventListener("click", () =>
                handleSubtaskCompletionToggle(subtask)
              );
            card
              .querySelector(".subtask-delete-btn")
              .addEventListener("click", () => handleDeleteSubtask(subtask.id));

            if (subtask.setDurationSeconds === null || subtask.isEditingTime) {
              const timeInput = card.querySelector(".subtask-time-input");
              const timeUpBtn = card.querySelector(".time-up-btn");
              const setTimeBtn = card.querySelector(".set-time-btn");

              // Show/hide set button based on input
              const toggleSetButton = () => {
                const hasValue =
                  !!timeInput.value && parseInt(timeInput.value, 10) > 0;
                timeUpBtn.classList.toggle("hidden", hasValue);
                setTimeBtn.classList.toggle("hidden", !hasValue);
              };
              timeInput.addEventListener("input", toggleSetButton);
              timeUpBtn.addEventListener("click", () =>
                handleSetRemainingTime(subtask)
              );
              setTimeBtn.addEventListener("click", () =>
                handleSetSubtaskTime(subtask, parseInt(timeInput.value, 10))
              );
              toggleSetButton(); // Initial check
            } else {
              if (!subtask.completed) {
                card
                  .querySelector(".play-pause-btn")
                  .addEventListener("click", () =>
                    handleSubtaskTimerToggle(subtask)
                  );
                card
                  .querySelector(".subtask-timer-display")
                  .addEventListener("click", () =>
                    handleEditSubtaskTime(subtask)
                  );

                // NEW: PiP Listener
                const pipBtn = card.querySelector(".pip-btn");
                if (pipBtn) {
                  pipBtn.addEventListener("click", () =>
                    toggleSubtaskPiP(subtask.id)
                  );
                }
              } else {
                card.querySelector(".play-pause-btn").style.display = "none";
                const pipBtn = card.querySelector(".pip-btn");
                if (pipBtn) pipBtn.style.display = "none";
              }
            }
          });

          const mainTaskDurationMinutes = (task.endHour - task.startHour) * 60;
          const totalAllocatedSubtaskMinutes = subtasks.reduce(
            (total, st) => total + (st.setDurationSeconds || 0) / 60,
            0
          );
          const maxAllowedMinutes = mainTaskDurationMinutes + 20;

          if (totalAllocatedSubtaskMinutes < maxAllowedMinutes) {
            const addBtn = document.createElement("button");
            addBtn.className = "add-subtask-btn";
            addBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg> Add Subtask`;
            addBtn.addEventListener("click", handleAddSubtask);
            controlsContainer.appendChild(addBtn);
          } else {
            const notice = document.createElement("div");
            notice.className = "subtask-limit-notice";
            notice.textContent =
              "All available time has been allocated to subtasks.";
            controlsContainer.appendChild(notice);
          }
          updateSubtaskTimersUI();
        }

        function updateSubtaskTimersUI() {
          const task = getCurrentWidgetTask();
          if (!task || !task.subtasks) return;

          task.subtasks.forEach((subtask) => {
            if (subtask.setDurationSeconds === null) return;
            // NEW: Update PiP if active for this subtask
            if (activePiPSubtaskId === subtask.id) {
              drawSubtaskPiPCanvas(subtask, task.name);
            }

            const timerDisplay = document.getElementById(
              `timer-display-${subtask.id}`
            );
            const progressBar = document.getElementById(
              `progress-${subtask.id}`
            );
            const playPauseBtn = document.querySelector(
              `[data-subtask-id="${subtask.id}"] .play-pause-btn`
            );

            if (!timerDisplay || !progressBar) return;

            let currentElapsed = subtask.elapsedSeconds;
            if (!subtask.isPaused) {
              currentElapsed += (Date.now() - subtask.timerStartTime) / 1000;
            }

            const remainingSeconds =
              subtask.setDurationSeconds - currentElapsed;
            const setTimeFormatted = formatSecondsToMMSS(
              subtask.setDurationSeconds
            );
            let progressPercent =
              (currentElapsed / subtask.setDurationSeconds) * 100;

            if (remainingSeconds >= 0) {
              timerDisplay.textContent = `${formatSecondsToMMSS(
                remainingSeconds
              )} / ${setTimeFormatted}`;
              timerDisplay.classList.remove("overtime");
              progressBar.classList.remove("overtime");
            } else {
              const overtimeSeconds = Math.abs(remainingSeconds);
              timerDisplay.textContent = `+${formatSecondsToMMSS(
                overtimeSeconds
              )} / ${setTimeFormatted}`;
              timerDisplay.classList.add("overtime");
              progressBar.classList.add("overtime");
              progressPercent = 100;
            }
            progressBar.style.width = `${Math.min(100, progressPercent)}%`;

            // Update play/pause icon dynamically
            if (playPauseBtn) {
              const isPaused = subtask.isPaused || subtask.completed;
              const currentIconPath = playPauseBtn
                .querySelector("svg path")
                ?.getAttribute("d");
              const playIconPath = "M8 5v14l11-7z";
              const pauseIconPath = "M6 19h4V5H6v14zm8-14v14h4V5h-4z";
              if (isPaused && currentIconPath !== playIconPath) {
                playPauseBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="${playIconPath}"></path></svg>`;
              } else if (!isPaused && currentIconPath !== pauseIconPath) {
                playPauseBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="${pauseIconPath}"></path></svg>`;
              }
            }
          });
        }
        // --- Subtask PiP Logic ---
        const subtaskPipCanvas = document.getElementById("subtask-pip-canvas");
        const subtaskPipVideo = document.getElementById("subtask-pip-video");

        function drawSubtaskPiPCanvas(subtask, mainTaskName) {
          if (!subtaskPipCanvas) return;
          const ctx = subtaskPipCanvas.getContext("2d");
          if (!ctx) return;

          // Background
          ctx.fillStyle = "#1c1c1e";
          ctx.fillRect(0, 0, 320, 180);

          // Time Text
          const remaining = Math.max(
            0,
            subtask.setDurationSeconds -
              subtask.elapsedSeconds -
              (subtask.isPaused
                ? 0
                : (Date.now() - subtask.timerStartTime) / 1000)
          );

          const minutes = Math.floor(remaining / 60);
          const seconds = Math.floor(remaining % 60);
          const timeString = `${String(minutes).padStart(2, "0")}:${String(
            seconds
          ).padStart(2, "0")}`;

          ctx.font =
            'bold 80px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
          ctx.fillStyle = subtask.isPaused ? "#8e8e93" : "#ffffff";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(timeString, 160, 90);

          // Task Name Label
          ctx.font = "bold 16px sans-serif";
          ctx.fillStyle = "#ff3b30";
          ctx.fillText(
            mainTaskName.length > 25
              ? mainTaskName.substring(0, 25) + "..."
              : mainTaskName,
            160,
            145
          );

          // Subtask Label
          ctx.font = "14px sans-serif";
          ctx.fillStyle = "#8e8e93";
          ctx.fillText(
            subtask.name.length > 30
              ? subtask.name.substring(0, 30) + "..."
              : subtask.name,
            160,
            165
          );
        }

        async function toggleSubtaskPiP(subtaskId) {
          const task = getCurrentWidgetTask();
          if (!task) return;
          const subtask = task.subtasks.find((s) => s.id === subtaskId);
          if (!subtask) return;

          try {
            if (document.pictureInPictureElement) {
              // If it's THIS video, exit. If it's another (e.g. Pomodoro), it will auto-close when we request new one.
              // But strictly, let's just request.
              if (document.pictureInPictureElement === subtaskPipVideo) {
                await document.exitPictureInPicture();
                activePiPSubtaskId = null;
                return;
              }
            }

            if (subtaskPipVideo && subtaskPipCanvas) {
              activePiPSubtaskId = subtaskId;
              drawSubtaskPiPCanvas(subtask, task.name); // Initial Draw

              const stream = subtaskPipCanvas.captureStream();
              subtaskPipVideo.srcObject = stream;
              await subtaskPipVideo.play();
              await subtaskPipVideo.requestPictureInPicture();

              subtaskPipVideo.addEventListener(
                "leavepictureinpicture",
                () => {
                  if (activePiPSubtaskId === subtaskId) {
                    activePiPSubtaskId = null;
                  }
                },
                { once: true }
              );
            }
          } catch (err) {
            console.error("Subtask PiP Error:", err);
            activePiPSubtaskId = null;
          }
        }

        function updateProgressWidget() {
          const subtasksSection = document.getElementById("subtasks-section");

          // CHANGE: Remove the "isToday" restriction to allow persistence across all dates
          // if (!isToday(selectedDate)) { ... }

          const now = new Date();
          const currentHour24 =
            now.getHours() + now.getMinutes() / 60 + now.getSeconds() / 3600;
          const dateKey = getDateKey(selectedDate);
          const tasksForDay = (tasksByDate[dateKey] || [])
            .slice()
            .sort((a, b) => a.startHour - b.startHour);

          // Priority: Forced Task -> Current Time Task
          let currentTask = null;

          if (forcedFocusTaskId) {
            currentTask = tasksForDay.find((t) => t.id === forcedFocusTaskId);
            if (!currentTask) {
              forcedFocusTaskId = null;
            }
          }

          if (!currentTask) {
            // Only auto-select by time if it's TODAY. For other days, maybe select the first task?
            // Or just leave it empty until clicked.
            // User said: "be completely working like it does for the current date".
            // If I look at a past date, "Current Time" matches nothing relative to "Now" usually.
            // So for non-today, default to nothing or the first upcoming task relative to 00:00?
            // Let's stick to "Current Time" logic for Today, and for others, maybe nothing unless clicked.

            if (isToday(selectedDate)) {
              currentTask = tasksForDay.find(
                (task) =>
                  currentHour24 >= task.startHour &&
                  currentHour24 < task.endHour
              );
            }
          }

          // CRITICAL FIX: Only re-render subtasks when the main task changes
          if (currentTask?.id !== currentWidgetTaskId) {
            currentWidgetTaskId = currentTask ? currentTask.id : null;
            if (currentTask) {
              renderSubtasksUI(currentTask);
            } else {
              if (subtasksSection) subtasksSection.classList.add("hidden");
            }
          }

          // --- EMPTY STATE HANDLING ---
          if (tasksForDay.length === 0) {
            progressWidget.classList.remove("hidden");
            progressWidgetTaskName.textContent = "No tasks scheduled";
            progressWidgetTaskName.style.cursor = "default";
            progressWidgetTaskName.onclick = null;

            progressWidgetTaskTime.textContent = "Add a task to begin!";

            progressBarElapsed.style.width = "0%";
            progressBarPercentage.textContent = "";

            // FIX 1 & 2: Use display:none to remove whitespace
            progressWidgetCompleteBtn.style.display = "none";
            progressWidgetCounter.style.display = "none";

            return; // Exit early
          }

          if (currentTask) {
            const taskIndex = tasksForDay.findIndex(
              (t) => t.id === currentTask.id
            );
            const taskDuration = currentTask.endHour - currentTask.startHour;

            // Calculate progress based on actual time, limited to 0-100%
            let timeElapsed = 0;
            if (isToday(selectedDate)) {
              timeElapsed = currentHour24 - currentTask.startHour;
            } else if (isPast(selectedDate)) {
              timeElapsed = taskDuration; // Fully complete visually if past day?
              // Actually, logic said "uncompleted past color" takes over.
              // But for the BAR, maybe full?
              // Let's keep it 0 unless it's today, to avoid confusion, or full?
              // If it's a past day, valid logic is it's "over".
              // Let's defaulting to 0 for non-today to avoid "fake" progress,
              // UNLESS completed.
            }

            let progressPercentage = (timeElapsed / taskDuration) * 100;
            progressPercentage = Math.max(0, Math.min(100, progressPercentage));

            progressWidget.classList.remove("hidden");
            progressWidgetTaskName.textContent = currentTask.name;
            progressWidgetTaskName.style.cursor = "pointer";
            progressWidgetTaskName.title = "Click to edit task details";

            progressWidgetTaskTime.textContent = `${formatHourToAMPM(
              currentTask.startHour
            )} - ${formatHourToAMPM(currentTask.endHour)}`;

            // FIX: Restore display
            progressWidgetCounter.style.display = "inline-block"; // or block/initial
            progressWidgetCounter.textContent = `${taskIndex + 1}/${
              tasksForDay.length
            }`;

            progressBarElapsed.style.backgroundColor = currentTask.completed
              ? COMPLETED_COLOR
              : currentTask.color;
            progressBarElapsed.style.width = currentTask.completed
              ? "100%"
              : `${progressPercentage}%`;

            progressBarPercentage.textContent =
              progressPercentage > 0 || currentTask.completed
                ? `${Math.floor(
                    currentTask.completed ? 100 : progressPercentage
                  )}%`
                : "";

            // FIX: Restore display
            progressWidgetCompleteBtn.style.display = "grid"; // It was grid in CSS
            progressWidgetCompleteBtn.style.visibility = "visible"; // Ensure visibility too just in case

            progressWidgetCompleteBtn.onclick = () => {
              if (currentWidgetTaskId)
                toggleTaskCompletion(currentWidgetTaskId);
            };

            progressWidgetTaskName.onclick = (e) => {
              e.stopPropagation();
              showModal(currentTask, selectedDate);
            };
          } else {
            // Handle "Free Time" or "All Tasks Done" state
            // If forcedFocusTaskId was null, we fall here.

            subtasksSection.classList.add("hidden");

            // Logic for "Next Up" applies mainly to Today.
            // For other days, if no task selected, maybe show "Select a task"?
            // Or "First task"?
            let nextTask = null;
            if (isToday(selectedDate)) {
              nextTask = tasksForDay.find(
                (t) => !t.completed && t.startHour > currentHour24
              );
            } else if (isPast(selectedDate)) {
              // No "Next Up" for past days
              nextTask = null;
            } else {
              // Future: The first uncompleted task is effectively "Next Up"
              nextTask = tasksForDay.find((t) => !t.completed);
            }

            const allTasksDone =
              tasksForDay.every((t) => t.completed) ||
              (!nextTask && tasksForDay.length > 0);

            if (nextTask) {
              progressWidget.classList.remove("hidden");
              progressWidgetTaskName.textContent = isToday(selectedDate)
                ? "Next Up: " + nextTask.name
                : "First Task: " + nextTask.name;
              progressWidgetTaskName.style.cursor = "default";
              progressWidgetTaskName.onclick = null;

              progressWidgetTaskTime.textContent = `Starts at ${formatHourToAMPM(
                nextTask.startHour
              )}`;
              progressBarElapsed.style.width = "0%";
              progressBarPercentage.textContent = "";

              progressWidgetCompleteBtn.style.display = "none";

              const nextTaskIndex = tasksForDay.findIndex(
                (t) => t.id === nextTask.id
              );
              progressWidgetCounter.style.display = "inline-block";
              progressWidgetCounter.textContent = `${nextTaskIndex + 1}/${
                tasksForDay.length
              }`;
            } else if (allTasksDone) {
              progressWidget.classList.remove("hidden");

              // Distinguish text for Past vs Today/Complete
              const reallyComplete = tasksForDay.every((t) => t.completed);
              if (reallyComplete) {
                progressWidgetTaskName.textContent = "All tasks complete!";
                progressWidgetTaskTime.textContent = "Great job.";
                progressBarPercentage.textContent = "";
              } else {
                // Past incomplete
                progressWidgetTaskName.textContent = "No more tasks";
                progressWidgetTaskTime.textContent = "End of day schedule.";
                progressBarPercentage.textContent = "";
              }

              progressWidgetTaskName.style.cursor = "default";
              progressWidgetTaskName.onclick = null;

              progressBarElapsed.style.width = "100%";

              progressWidgetCompleteBtn.style.display = "none";

              // FIX: Show counter here too so user can access list
              progressWidgetCounter.style.display = "inline-block";
              progressWidgetCounter.textContent = `${tasksForDay.length}/${tasksForDay.length}`;
            } else {
              progressWidget.classList.add("hidden");
              progressWidgetCounter.style.display = "none";
            }
          }
        }

        // --- Integrated Task List View Logic (New Feature) ---

        /**
         * Renders the list of tasks for the selected day. This function remains
         * powerful and unchanged in its core logic, populating the card container.
         */
        function renderTaskListView() {
          taskListCards.innerHTML = ""; // Clear previous content

          const dateKey = getDateKey(selectedDate);
          const tasksForDay = (tasksByDate[dateKey] || [])
            .slice()
            .sort((a, b) => a.startHour - b.startHour);

          if (tasksForDay.length === 0) {
            taskListCards.innerHTML =
              '<div class="task-list-empty">No tasks scheduled for this day.</div>';
            return;
          }

          tasksForDay.forEach((task) => {
            const card = document.createElement("div");
            card.className = "task-list-card";
            // Using a CSS variable for the color dot is a robust, clean technique
            card.style.setProperty("--task-color", task.color);

            card.innerHTML = `
        <div class="task-list-card-info">
          <span class="task-list-card-name">${task.name}</span>
          <span class="task-list-card-time">${formatHourToAMPM(
            task.startHour
          )} - ${formatHourToAMPM(task.endHour)}</span>
        </div>
        <div class="task-list-card-status ${task.completed ? "completed" : ""}">
          ${
            task.completed
              ? '<svg viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"></polyline></svg>'
              : ""
          }
        </div>
      `;

            card.addEventListener("click", () => {
              // CHANGE: Instead of opening modal, set this as the forced focus task
              forcedFocusTaskId = task.id;
              updateProgressWidget(); // Update UI immediately

              // Hide the list
              progressWidget.classList.remove("expanded-view");
            });

            taskListCards.appendChild(card);
          });
        }

        /**
         * Toggles the expanded view of the progress widget. It's a simple,
         * elegant state change managed by a single CSS class.
         */
        function toggleTaskListView() {
          const isExpanding =
            !progressWidget.classList.contains("expanded-view");

          if (isExpanding) {
            // Always populate with fresh data right before showing
            renderTaskListView();
          }

          progressWidget.classList.toggle("expanded-view");
        }

        // --- Calendar Logic ---
        function renderCalendar() {
          calendarDatesEl.innerHTML = "";

          if (isCalendarCollapsed) {
            // Let's determine the target date to show week for.
            // If we are navigating by weeks (collapsed), displayedDate IS the anchor.
            // If we just collapsed, displayedDate might be the 1st of the month.
            // But we want to show the week of the Selected Date initially if we haven't navigated?
            // Actually, best user experience:
            // 1. On init/toggle to collapse: Snap displayedDate to selectedDate.
            // 2. On navigation: displayedDate moves by weeks.

            // However, displayedDate is shared with Month view.
            // If I change displayedDate to "Dec 15" for week view, and toggle back, Month view shows Dec. Fine.

            // Calculate Start of Week (Monday Start) based on displayedDate
            const day = displayedDate.getDay(); // 0 is Sun, 1 is Mon
            const diff = day === 0 ? 6 : day - 1; // Mon=0, Tue=1... Sun=6
            const startOfWeek = new Date(displayedDate);
            startOfWeek.setDate(displayedDate.getDate() - diff);
            // End of week
            const endOfWeek = new Date(startOfWeek);
            endOfWeek.setDate(startOfWeek.getDate() + 6);

            // Dynamic Header Logic for Week View
            // "if the week dates are in future and surpasses the current month ... month title should change"
            // "if the week is only inside the current month or the same month then the month title shouldn't be updated"

            // We use the month of the MAJORITY of the week or simply the start/end to decide.
            // User request: "let's say... 28 Dec... next week 29 Dec - 4 Jan... month title should change"
            // This implies: If the week *starts* in Dec but *ends* in Jan, show Jan? Or Dec?
            // "month title should change respectively"
            // Usually, if a week spans months, showing "Dec - Jan" is best.
            // But limited space?
            // Let's define it by the End Date's month if it crossed over?
            // User says: "surpasses the current month".
            // So if endOfWeek.month != startOfWeek.month?
            // If we are mostly in Jan, show Jan.
            // Let's us the month of the END of the week (Sun).
            // Example: Dec 29 (Mon) - Jan 4 (Sun). 4th is Jan. Show Jan?
            // Example: Nov 25 (Mon) - Dec 1 (Sun). 1st is Dec. Show Dec?
            // Or maybe simply use the `displayedDate`?
            // If `displayedDate` was 28 Dec. +7 days -> 4 Jan. 4 Jan is in Jan.
            // So relying on `displayedDate` is correct IF we move `displayedDate` by 7 days.

            const headerDate = displayedDate;
            // In case displayedDate is "Dec 29" (which we might have set manually or via navigation key logic)
            // But wait, if I use my Listener logic: `displayedDate` updates.
            // If I was at Dec 28. Next -> Jan 4. Header is Jan. Correct.
            // If I was at Dec 21. Next -> Dec 28. Header is Dec. Correct.
            // If I was at Dec 29?
            // Week Dec 29 - Jan 4.
            // If I am navigating, `displayedDate` jumps.
            // If I start at `selectedDate` (e.g. Dec 25).

            calendarMonthEl.textContent = headerDate.toLocaleDateString(
              "en-US",
              { month: "long" }
            );
            calendarYearEl.textContent = headerDate.getFullYear();

            // Render 7 Days
            for (let i = 0; i < 7; i++) {
              const current = new Date(startOfWeek);
              current.setDate(startOfWeek.getDate() + i);
              const d = current.getDate();
              // In Week view, we don't grey out "other month" days usually, we just show them.
              // BUT, if we want to be fancy, we can check if they differ from the header month.
              const isOtherMonth = current.getMonth() !== headerDate.getMonth();
              calendarDatesEl.appendChild(
                createDateCell(d, current, isOtherMonth)
              );
            }
          } else {
            // --- MONTH VIEW (Original Logic) ---
            const t = displayedDate.getMonth(),
              e = displayedDate.getFullYear();
            (calendarMonthEl.textContent = displayedDate.toLocaleDateString(
              "en-US",
              { month: "long" }
            )),
              (calendarYearEl.textContent = e);
            const n = new Date(e, t, 1).getDay(),
              o = new Date(e, t + 1, 0).getDate(),
              r = 0 === n ? 6 : n - 1, // Padding count (Mon start)
              s = new Date(e, t, 0), // Last day of prev month
              a = s.getDate(); // Last Date number

            // RENDER PREVIOUS MONTH PADDING
            for (let i = r; i > 0; i--) {
              const l = a - i + 1;
              const c = new Date(e, t - 1, l); // Use t-1 for prev month safely?
              // Note: new Date(2023, 0 - 1, ...) handles wrap to Dec 2022 automatically.
              calendarDatesEl.appendChild(createDateCell(l, c, !0));
            }

            // RENDER CURRENT MONTH DAYS
            for (let d = 1; d <= o; d++) {
              const h = new Date(e, t, d);
              calendarDatesEl.appendChild(createDateCell(d, h, !1));
            }

            // RENDER NEXT MONTH PADDING
            const p = new Date(e, t + 1, 1);
            let u = 1;
            while (calendarDatesEl.children.length < 42) {
              // Safe recursive filling
              const m = new Date(p.getFullYear(), p.getMonth(), u);
              calendarDatesEl.appendChild(createDateCell(u, m, !0));
              u++;
            }
          }
        }
        function createDateCell(t, e, n) {
          const o = document.createElement("div");
          o.className = "date-cell";
          if (n) o.classList.add("other-month");
          o.textContent = t;
          if (isToday(e)) o.classList.add("today");

          const key = getDateKey(e);
          if (key === getDateKey(selectedDate)) {
            o.classList.add("selected");
          }

          // --- EVENTS INDICATORS ---
          if (events[key] && events[key].length > 0) {
            const indicators = document.createElement("div");
            indicators.className = "date-event-indicators";
            const dayEvents = events[key];
            // Show up to 4 bars
            const limit = 4;
            for (let i = 0; i < Math.min(dayEvents.length, limit); i++) {
              const bar = document.createElement("div");
              bar.className = "event-indicator-bar";
              bar.style.backgroundColor = dayEvents[i].color;
              indicators.appendChild(bar);
            }
            o.appendChild(indicators);
          }
          // ------------------------

          o.addEventListener("click", () => {
            selectedDate = e;
            currentNotesDate = e;
            if (
              e.getMonth() !== displayedDate.getMonth() ||
              e.getFullYear() !== displayedDate.getFullYear()
            ) {
              displayedDate = new Date(e.getFullYear(), e.getMonth(), 1);
            }
            progressWidget.classList.remove("expanded-view");
            renderCalendar();
            renderAppView();
            renderNotesWidget();
            renderEventsWidget(); // Update Events Widget Context
          });
          return o;
        }

        // --- Habit Tracker Logic ---

        // --- Events Widget Logic ---
        let events = JSON.parse(localStorage.getItem("events") || "{}");
        let isEventsWidgetCollapsed =
          localStorage.getItem("eventsWidgetCollapsed") === "true";
        let selectedEventColor = "#007aff";

        function initEventsWidget() {
          const widget = document.getElementById("events-widget");
          const toggleBtn = document.getElementById("toggle-events-widget-btn");
          const addBtn = document.getElementById("btn-add-event");
          const colorPickerContainer =
            document.getElementById("event-color-picker");

          if (isEventsWidgetCollapsed) {
            widget.classList.add("collapsed");
          } else {
            widget.classList.remove("collapsed");
          }

          toggleBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            toggleEventsWidget();
          });

          widget.addEventListener("click", (e) => {
            if (widget.classList.contains("collapsed")) {
              toggleEventsWidget();
            }
          });

          // Prevent internal clicks from toggling
          document
            .querySelector(".events-widget-header")
            .addEventListener("click", (e) => e.stopPropagation());
          document
            .querySelector(".events-content")
            .addEventListener("click", (e) => e.stopPropagation());

          // Add Event
          addBtn.addEventListener("click", () => {
            const title = document
              .getElementById("event-title-input")
              .value.trim();
            if (title) {
              addEvent(selectedDate, title, selectedEventColor);
              document.getElementById("event-title-input").value = "";
            }
          });

          // Colors
          COLORS.forEach((color, index) => {
            const option = document.createElement("div");
            option.className = "event-color-option";
            option.style.backgroundColor = color;
            if (index === 0) {
              option.classList.add("selected");
              selectedEventColor = color;
            }
            option.addEventListener("click", () => {
              document
                .querySelectorAll(".event-color-option")
                .forEach((el) => el.classList.remove("selected"));
              option.classList.add("selected");
              selectedEventColor = color;
            });
            colorPickerContainer.appendChild(option);
          });

          renderEventsWidget();
        }

        function toggleEventsWidget() {
          const widget = document.getElementById("events-widget");
          isEventsWidgetCollapsed = !isEventsWidgetCollapsed;
          widget.classList.toggle("collapsed", isEventsWidgetCollapsed);
          localStorage.setItem(
            "eventsWidgetCollapsed",
            isEventsWidgetCollapsed
          );
          renderEventsWidget();
        }

        function renderEventsWidget() {
          const listContainer = document.getElementById(
            "events-list-container"
          );
          listContainer.innerHTML = "";

          const today = new Date();
          today.setHours(0, 0, 0, 0);

          const allDates = Object.keys(events).sort();
          const past = [];
          const todayEvents = [];
          const upcoming = [];

          const renderGroup = (title, items) => {
            if (items.length === 0) return;
            const header = document.createElement("div");
            header.className = "events-group-header";
            header.textContent = title;
            listContainer.appendChild(header);

            items.forEach((ev) => {
              const el = document.createElement("div");
              el.className = `event-item ${ev.completed ? "completed" : ""}`;
              el.dataset.id = ev.id;
              el.dataset.date = ev.date;

              const dateParts = ev.date.split("-");
              const dateObj = new Date(
                dateParts[0],
                dateParts[1] - 1,
                dateParts[2]
              );
              const dayNum = dateObj.getDate();
              const monthShort = dateObj.toLocaleDateString("en-US", {
                month: "short",
              });

              // --- Checkbox/Tick ---
              const checkbox = document.createElement("div");
              checkbox.className = `event-checkbox ${
                ev.completed ? "checked" : ""
              }`;
              checkbox.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
              checkbox.addEventListener("click", (e) => {
                e.stopPropagation();
                toggleEventCompletion(ev.date, ev.id);
              });

              // --- Content ---
              const info = document.createElement("div");
              info.className = "event-info";
              info.innerHTML = `<div class="event-title">${ev.title}</div>`;

              const actions = document.createElement("div");
              actions.className = "event-actions";

              // --- Edit Button ---
              const editBtn = document.createElement("button");
              editBtn.className = "edit-event-btn";
              editBtn.title = "Edit";
              editBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>`;
              editBtn.addEventListener("click", (e) => {
                e.stopPropagation();
                startEditingEvent(el, ev);
              });

              // --- Delete Button ---
              const deleteBtn = document.createElement("button");
              deleteBtn.className = "delete-event-btn";
              deleteBtn.title = "Delete";
              deleteBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>`;
              deleteBtn.addEventListener("click", (e) => {
                e.stopPropagation();
                deleteEvent(ev.date, ev.id);
              });

              actions.appendChild(editBtn);
              actions.appendChild(deleteBtn);

              el.appendChild(checkbox);
              el.appendChild(document.createElement("div")).className =
                "event-date-badge";
              el.lastChild.innerHTML = `<span class="event-date-month">${monthShort}</span><span class="event-date-day">${dayNum}</span>`;

              el.appendChild(info);
              const indicator = document.createElement("div");
              indicator.className = "event-color-indicator";
              indicator.style.backgroundColor = ev.color;
              el.appendChild(indicator);
              el.appendChild(actions);

              listContainer.appendChild(el);
            });
          };

          // Focused View Logic
          let focusedEvents = [];
          const todayStr = getDateKey(today);
          const focusedDateStr = getDateKey(selectedDate); // uses global selectedDate
          const isFocusedView = focusedDateStr !== todayStr;

          for (const dateStr of allDates) {
            const dayEvents = events[dateStr];

            // If strictly equal to selected date AND it's a focused view (not today)
            if (isFocusedView && dateStr === focusedDateStr) {
              focusedEvents.push(
                ...dayEvents.map((e) => ({ ...e, date: dateStr }))
              );
              continue; // Don't add to other groups
            }

            if (dateStr === todayStr) {
              todayEvents.push(
                ...dayEvents.map((e) => ({ ...e, date: dateStr }))
              );
            } else if (dateStr > todayStr) {
              upcoming.push(...dayEvents.map((e) => ({ ...e, date: dateStr })));
            } else {
              past.push(...dayEvents.map((e) => ({ ...e, date: dateStr })));
            }
          }

          // 1. Render Focused Group if active
          if (isFocusedView && focusedEvents.length > 0) {
            const focusedTitle = selectedDate.toLocaleDateString("en-US", {
              weekday: "long",
              month: "long",
              day: "numeric",
            });
            renderGroup(focusedTitle, focusedEvents);
          }
          // Also render an empty state/header if focused view but no events?
          // User said "show all the tasks scheduled... is a seperate compartment".
          // If 0 tasks, maybe we shouldn't show the header to keep it clean,
          // OR show "No events for [Date]".
          // For now, let's stick to showing it only if there are events, or maybe show a placeholder?
          // The current `renderGroup` returns if items.length === 0.
          // Let's modify logic: if focused view has 0 items, we might want to show that explicitly?
          // But `renderGroup` acts as the display mechanism.
          // Let's just pass it through. If users want empty states, they'll ask.

          if (isFocusedView && focusedEvents.length === 0) {
            // Optional: Render an empty message for the selected date?
            const header = document.createElement("div");
            header.className = "events-group-header";
            header.textContent = selectedDate.toLocaleDateString("en-US", {
              weekday: "long",
              month: "long",
              day: "numeric",
            });
            listContainer.appendChild(header);

            const emptyMsg = document.createElement("div");
            emptyMsg.style.padding = "0.75rem";
            emptyMsg.style.fontSize = "0.9rem";
            emptyMsg.style.color = "var(--secondary-color)";
            emptyMsg.style.fontStyle = "italic";
            emptyMsg.textContent = "No events scheduled";
            listContainer.appendChild(emptyMsg);
          }

          renderGroup("Today", todayEvents);
          renderGroup("Upcoming", upcoming);
          if (past.length > 0) renderGroup("Past", past.reverse());

          const displayDateEl = document.getElementById(
            "selected-event-date-text"
          );
          if (displayDateEl) {
            displayDateEl.textContent = selectedDate.toLocaleDateString(
              "en-US",
              { weekday: "long", month: "long", day: "numeric" }
            );
          }

          // Badge/Icon Update for Collapsed State
          const selectedStr = getDateKey(selectedDate);
          // Count only UNCOMPLETED events for the badge
          const count = (events[selectedStr] || []).filter(
            (e) => !e.completed
          ).length;

          const collapsedSvg = document.querySelector(".event-collapsed-svg");
          const collapsedCount = document.getElementById(
            "event-collapsed-count"
          );

          if (collapsedSvg && collapsedCount) {
            if (count > 0) {
              collapsedSvg.style.display = "none";
              collapsedCount.style.display = "block";
              collapsedCount.textContent = count;
            } else {
              collapsedSvg.style.display = "block";
              collapsedCount.style.display = "none";
            }
          }
        }

        function addEvent(date, title, color) {
          const key = getDateKey(date);
          if (!events[key]) events[key] = [];
          events[key].push({
            id: Date.now().toString(),
            title,
            color,
            completed: false,
          });
          localStorage.setItem("events", JSON.stringify(events));
          renderEventsWidget();
          renderCalendar();
        }

        function toggleEventCompletion(dateKey, id) {
          if (events[dateKey]) {
            const ev = events[dateKey].find((e) => e.id === id);
            if (ev) {
              ev.completed = !ev.completed;
              localStorage.setItem("events", JSON.stringify(events));
              renderEventsWidget();
            }
          }
        }

        function startEditingEvent(el, ev) {
          const infoDiv = el.querySelector(".event-info");
          const actionsDiv = el.querySelector(".event-actions");

          // Swap Title for Input
          const currentTitle = ev.title;
          infoDiv.innerHTML = `<input type="text" class="event-title-edit-input" value="${currentTitle}">`;
          const input = infoDiv.querySelector("input");

          // Focus and select all
          input.focus();
          input.select();

          // Swap Edit Button for Save Button
          const editBtn = actionsDiv.querySelector(".edit-event-btn");
          if (editBtn) {
            // Create Save Button
            const saveBtn = document.createElement("button");
            saveBtn.className = "save-event-btn";
            saveBtn.title = "Save";
            saveBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`;

            saveBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              saveEventTitle(ev.date, ev.id, input.value.trim());
            });

            actionsDiv.replaceChild(saveBtn, editBtn);
          }

          // Handle Enter Key in Input
          input.addEventListener("keydown", (e) => {
            e.stopPropagation();
            if (e.key === "Enter") {
              saveEventTitle(ev.date, ev.id, input.value.trim());
            }
            if (e.key === "Escape") {
              renderEventsWidget(); // Cancel
            }
          });
          input.addEventListener("click", (e) => e.stopPropagation());
        }

        function saveEventTitle(dateKey, id, newTitle) {
          if (!newTitle) {
            renderEventsWidget();
            return;
          }
          if (events[dateKey]) {
            const ev = events[dateKey].find((e) => e.id === id);
            if (ev) {
              ev.title = newTitle;
              localStorage.setItem("events", JSON.stringify(events));
              renderEventsWidget();
            }
          }
        }

        function deleteEvent(dateKey, id) {
          if (events[dateKey]) {
            events[dateKey] = events[dateKey].filter((e) => e.id !== id);
            if (events[dateKey].length === 0) delete events[dateKey];
            localStorage.setItem("events", JSON.stringify(events));
            renderEventsWidget();
            renderCalendar();
          }
        }

        // --- Habit Tracker Logic ---

        // NEW: Collapse State Management
        let isHabitWidgetCollapsed =
          localStorage.getItem("habitWidgetCollapsed") === "true";

        // Initialize state on load
        function initHabitWidgetState() {
          const widget = document.getElementById("habit-widget");
          if (isHabitWidgetCollapsed) {
            widget.classList.add("collapsed");
          } else {
            widget.classList.remove("collapsed");
          }

          // Toggle Button Listener
          document
            .getElementById("toggle-habit-widget-btn")
            .addEventListener("click", (e) => {
              e.stopPropagation();
              toggleHabitWidget();
            });

          // Also allow expanding by clicking the collapsed icon (or widget body when collapsed)
          widget.addEventListener("click", (e) => {
            if (widget.classList.contains("collapsed")) {
              toggleHabitWidget();
            }
          });

          // Prevent clicks inside header/list from toggling when expanded (except the toggle btn)
          document
            .querySelector(".habit-widget-header")
            .addEventListener("click", (e) => e.stopPropagation());
          document
            .querySelector("#habit-list")
            .addEventListener("click", (e) => e.stopPropagation());
        }

        function toggleHabitWidget() {
          const widget = document.getElementById("habit-widget");
          isHabitWidgetCollapsed = !isHabitWidgetCollapsed;
          widget.classList.toggle("collapsed", isHabitWidgetCollapsed);
          localStorage.setItem("habitWidgetCollapsed", isHabitWidgetCollapsed);
        }

        // Global tooltip cleanup
        const existingTooltip = document.getElementById("task-tooltip");
        if (existingTooltip) {
          existingTooltip.classList.remove("visible");
        }

        function renderHabits() {
          const habitList = document.getElementById("habit-list");
          habitList.innerHTML = "";

          if (habits.length === 0) {
            habitList.innerHTML = `<div style="text-align:center; padding: 2rem; color: var(--secondary-color); font-size: 0.9rem;">No habits tracked.<br>Click + to start.</div>`;
            return;
          }

          habits.forEach((habit) => {
            const habitItem = document.createElement("div");
            habitItem.className = "habit-item";

            // --- NEW LOGIC: Monthly Frequency & Longest Streak ---
            // Base calculations on the currently displayed month in the calendar (displayedDate)
            const year = displayedDate.getFullYear();
            const month = displayedDate.getMonth();
            const daysInMonth = new Date(year, month + 1, 0).getDate();

            let monthlyCount = 0;
            let currentSequence = 0;
            let maxMonthlyStreak = 0;

            for (let d = 1; d <= daysInMonth; d++) {
              const date = new Date(year, month, d);
              const key = getDateKey(date);

              if (habit.history[key]) {
                monthlyCount++;
                currentSequence++;
              } else {
                if (currentSequence > maxMonthlyStreak) {
                  maxMonthlyStreak = currentSequence;
                }
                currentSequence = 0;
              }
            }
            // Final check in case the streak ends on the last day of the month
            if (currentSequence > maxMonthlyStreak) {
              maxMonthlyStreak = currentSequence;
            }

            habitItem.innerHTML = `
              <div class="habit-item-header">
                <div class="habit-name">
                  <div style="width: 8px; height: 8px; border-radius: 50%; background-color: ${
                    habit.color
                  };"></div>
                  ${habit.name}
                </div>

                <div class="habit-stats">
                    <div class="habit-stat-item" title="Monthly Frequency">
                        <span></span> ${monthlyCount}/${daysInMonth}
                    </div>
                    <div class="habit-stat-item ${
                      maxMonthlyStreak >= 3 ? "highlight" : ""
                    }" title="Longest Streak this Month">
                        <span></span> ${maxMonthlyStreak}
                    </div>
                </div>

                <div class="habit-controls">
                   <button class="habit-btn-mini habit-expand-btn ${
                     habit.expanded ? "expanded" : ""
                   }" aria-label="Toggle View">
                      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                   </button>
                   <button class="habit-btn-mini delete" aria-label="Delete Habit">
                      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
                   </button>
                </div>
              </div>
              <div class="habit-grid ${
                habit.expanded ? "" : "collapsed"
              }" id="habit-grid-${habit.id}"></div>
            `;

            // Delete button logic
            habitItem
              .querySelector(".delete")
              .addEventListener("click", (e) => {
                e.stopPropagation();
                if (confirm(`Delete habit "${habit.name}"?`)) {
                  deleteHabit(habit.id);
                }
              });

            // Expand/Collapse logic
            habitItem
              .querySelector(".habit-expand-btn")
              .addEventListener("click", (e) => {
                e.stopPropagation();
                toggleHabitExpand(habit.id);
              });

            habitList.appendChild(habitItem);
            renderMiniMonth(
              habit,
              habitItem.querySelector(`#habit-grid-${habit.id}`)
            );
          });
        }

        function toggleHabitExpand(habitId) {
          const habit = habits.find((h) => h.id === habitId);
          if (habit) {
            habit.expanded = !habit.expanded;
            saveHabits();
            renderHabits();
          }
        }

        function renderMiniMonth(habit, container) {
          // Render the *displayedDate* month (from main calendar)
          const year = displayedDate.getFullYear();
          const month = displayedDate.getMonth();
          const daysInMonth = new Date(year, month + 1, 0).getDate();
          const today = new Date();
          const todayKey = getDateKey(today);

          // Calculate which week contains "today" (or the relevant target date)
          let currentWeekIndex = 0;
          const firstDay = new Date(year, month, 1).getDay();
          const startOffset = firstDay === 0 ? 6 : firstDay - 1; // Mon start

          if (today.getMonth() === month && today.getFullYear() === year) {
            const dayOfMonth = today.getDate();
            currentWeekIndex = Math.floor((startOffset + dayOfMonth - 1) / 7);
          }

          container.innerHTML = "";
          let dayCounter = 0;

          // Render blanks
          for (let i = 0; i < startOffset; i++) {
            const empty = document.createElement("div");
            empty.className = "habit-day empty";
            const weekIndex = Math.floor(dayCounter / 7);
            if (weekIndex === currentWeekIndex)
              empty.classList.add("current-week");
            container.appendChild(empty);
            dayCounter++;
          }

          // Render days
          for (let d = 1; d <= daysInMonth; d++) {
            const date = new Date(year, month, d);
            const dateKey = getDateKey(date);
            const dayEl = document.createElement("div");
            dayEl.className = "habit-day";
            dayEl.textContent = d; // FIX: Show Date Number

            const weekIndex = Math.floor(dayCounter / 7);
            if (weekIndex === currentWeekIndex)
              dayEl.classList.add("current-week");

            // --- FIX: Logic for Past / Future / Present styling ---
            // Compare timestamps to be safe, ignoring time portion
            const dateTs = new Date(date.toDateString()).getTime();
            const todayTs = new Date(today.toDateString()).getTime();

            if (dateTs < todayTs) {
              dayEl.classList.add("past");
            } else if (dateTs > todayTs) {
              dayEl.classList.add("future");
            } // "today" handled by isToday check below

            if (habit.history[dateKey]) {
              dayEl.classList.add("active");
            }

            if (isToday(date)) dayEl.classList.add("today");

            dayEl.title = date.toDateString();
            dayEl.addEventListener("click", () =>
              toggleHabitDate(habit.id, dateKey)
            );

            container.appendChild(dayEl);
            dayCounter++;
          }
        }

        function toggleHabitDate(habitId, dateStr) {
          const habit = habits.find((h) => h.id === habitId);

          if (habit) {
            if (habit.history[dateStr]) {
              delete habit.history[dateStr];
            } else {
              habit.history[dateStr] = true;
            }
            saveHabits();
            const container = document.querySelector(`#habit-grid-${habit.id}`);
            if (container) renderMiniMonth(habit, container);
            // Re-render full habits to update streak if needed (optional optimization: only update specific element)
            renderHabits();
          }
        }

        function saveHabits() {
          localStorage.setItem("clockHabits", JSON.stringify(habits));
        }

        function addHabit(name, color) {
          const newHabit = {
            id: "habit-" + Date.now(),
            name: name,
            color: color,
            history: {},
          };
          habits.push(newHabit);
          saveHabits();
          renderHabits();
        }

        function deleteHabit(habitId) {
          habits = habits.filter((h) => h.id !== habitId);
          saveHabits();
          renderHabits();
        }

        // Modal Logic for Habits
        const habitModalOverlay = document.getElementById(
          "habit-modal-overlay"
        );
        const addHabitBtn = document.getElementById("add-habit-btn");
        const saveHabitBtn = document.getElementById("save-habit-btn");
        const cancelHabitBtn = document.getElementById("cancel-habit-btn");
        const habitNameInput = document.getElementById("habit-name");
        const habitColorSelector = document.getElementById(
          "habit-color-selector"
        );
        let selectedHabitColor = COLORS[0];

        function initHabitColorSelector() {
          habitColorSelector.innerHTML = "";
          COLORS.forEach((color, index) => {
            const option = document.createElement("div");
            option.className = "color-option";
            option.style.backgroundColor = color;
            if (index === 0) option.classList.add("selected");

            option.addEventListener("click", () => {
              habitColorSelector
                .querySelector(".selected")
                ?.classList.remove("selected");
              option.classList.add("selected");
              selectedHabitColor = color;
            });
            habitColorSelector.appendChild(option);
          });
        }

        // ============================================
        // ==      POMODORO TIMTER WIDGET LOGIC      ==
        // ============================================

        // Local Storage Key
        const TIMER_STATE_KEY = "pomodoroTimerState";
        const savedTimerState = JSON.parse(
          localStorage.getItem(TIMER_STATE_KEY) || "{}"
        );

        let pomodoroState = {
          timeLeft: savedTimerState.timeLeft || 25 * 60,
          totalTime: savedTimerState.totalTime || 25 * 60,
          isRunning: false, // Start paused
          intervalId: null,
          isCollapsed:
            localStorage.getItem("pomodoroWidgetCollapsed") === "true",
          presets: JSON.parse(localStorage.getItem("pomodoroPresets") || "[5]"),
          isEditMode: false,
          isAddingPreset: false,
        };

        const pomodoroTimerDisplay = document.getElementById(
          "pomodoro-timer-display"
        );
        const pomodoroStartBtn = document.getElementById("pomodoro-start-btn");
        const pomodoroPauseBtn = document.getElementById("pomodoro-pause-btn");
        const pomodoroResetBtn = document.getElementById("pomodoro-reset-btn");
        const pomodoroCustomInput = document.getElementById(
          "pomodoro-custom-input"
        );
        const pomodoroSetCustomBtn = document.getElementById(
          "pomodoro-set-custom-btn"
        );
        const pomodoroWidget = document.getElementById("pomodoro-widget");
        const pomodoroPresetsContainer =
          document.getElementById("pomodoro-presets");
        const pomodoroEditPresetsBtn = document.getElementById(
          "pomodoro-edit-presets-btn"
        );

        // PiP Elements
        const pomodoroPipBtn = document.getElementById("pomodoro-pip-btn");
        const pomodoroPipCanvas = document.getElementById(
          "pomodoro-pip-canvas"
        );
        const pomodoroPipVideo = document.getElementById("pomodoro-pip-video");

        let activePomodoroPiPAnimation = null;

        function initPomodoroWidget() {
          // Collapse State
          if (pomodoroState.isCollapsed) {
            pomodoroWidget.classList.add("collapsed");
          } else {
            pomodoroWidget.classList.remove("collapsed");
          }

          document
            .getElementById("toggle-pomodoro-widget-btn")
            .addEventListener("click", (e) => {
              e.stopPropagation();
              togglePomodoroWidget();
            });

          pomodoroWidget.addEventListener("click", (e) => {
            if (pomodoroWidget.classList.contains("collapsed")) {
              togglePomodoroWidget();
            }
          });

          // Prevent propagation
          document
            .querySelector(".pomodoro-widget-header")
            .addEventListener("click", (e) => e.stopPropagation());
          document
            .querySelector(".pomodoro-content")
            .addEventListener("click", (e) => e.stopPropagation());

          // Timer Controls
          pomodoroStartBtn.addEventListener("click", startPomodoro);
          pomodoroPauseBtn.addEventListener("click", pausePomodoro);
          pomodoroResetBtn.addEventListener("click", resetPomodoro);

          // Edit Presets Toggle
          pomodoroEditPresetsBtn.addEventListener(
            "click",
            togglePresetEditMode
          );

          // Custom Input Button (Set Time OR Add Preset)
          pomodoroSetCustomBtn.addEventListener("click", () => {
            const val = parseInt(pomodoroCustomInput.value);

            if (val && val > 0) {
              if (pomodoroState.isAddingPreset) {
                // ADD PRESET LOGIC
                if (!pomodoroState.presets.includes(val)) {
                  pomodoroState.presets.push(val);
                  pomodoroState.presets.sort((a, b) => a - b);
                  savePresets();
                }
                // Reset Mode
                toggleAddPresetMode();
                pomodoroCustomInput.value = "";
              } else {
                // SET TIME LOGIC
                setPomodoroTime(val);
                pomodoroCustomInput.value = "";
                // Deselect presets
                document
                  .querySelectorAll(".preset-chip")
                  .forEach((c) => c.classList.remove("active"));
              }
            }
          });

          if (pomodoroPipBtn) {
            pomodoroPipBtn.addEventListener("click", togglePomodoroPiP);
          }

          renderPresets();
          updatePomodoroUI();
        }

        function togglePresetEditMode() {
          // If in Add Mode, turn it off first
          if (pomodoroState.isAddingPreset) toggleAddPresetMode();

          pomodoroState.isEditMode = !pomodoroState.isEditMode;
          pomodoroPresetsContainer.classList.toggle(
            "edit-mode",
            pomodoroState.isEditMode
          );
          pomodoroEditPresetsBtn.classList.toggle(
            "active",
            pomodoroState.isEditMode
          );
        }

        function toggleAddPresetMode() {
          // If in Edit Mode, turn it off first
          if (pomodoroState.isEditMode) togglePresetEditMode();

          pomodoroState.isAddingPreset = !pomodoroState.isAddingPreset;

          if (pomodoroState.isAddingPreset) {
            pomodoroSetCustomBtn.textContent = "Add";
            pomodoroSetCustomBtn.classList.add("btn-add-mode");
            pomodoroCustomInput.focus();
            pomodoroCustomInput.placeholder = "Enter preset min";
          } else {
            pomodoroSetCustomBtn.textContent = "Set";
            pomodoroSetCustomBtn.classList.remove("btn-add-mode");
            pomodoroCustomInput.placeholder = "Min";
          }
        }

        function savePresets() {
          localStorage.setItem(
            "pomodoroPresets",
            JSON.stringify(pomodoroState.presets)
          );
          renderPresets();
        }

        function deletePreset(minutes) {
          pomodoroState.presets = pomodoroState.presets.filter(
            (m) => m !== minutes
          );
          savePresets();
        }

        function renderPresets() {
          pomodoroPresetsContainer.innerHTML = "";

          pomodoroState.presets.forEach((minutes) => {
            const chip = document.createElement("div");
            chip.className = "preset-chip";
            if (
              !pomodoroState.isAddingPreset &&
              pomodoroState.totalTime === minutes * 60
            ) {
              chip.classList.add("active");
            }
            chip.textContent = `${minutes}m`;

            // Delete Badge
            const badge = document.createElement("div");
            badge.className = "delete-badge";
            badge.textContent = "";
            badge.addEventListener("click", (e) => {
              e.stopPropagation();
              deletePreset(minutes);
            });
            chip.appendChild(badge);

            chip.addEventListener("click", () => {
              if (pomodoroState.isEditMode || pomodoroState.isAddingPreset)
                return;

              setPomodoroTime(minutes);
              document
                .querySelectorAll(".preset-chip")
                .forEach((c) => c.classList.remove("active"));
              chip.classList.add("active");
            });

            pomodoroPresetsContainer.appendChild(chip);
          });

          // Add "+" Button
          const addBtn = document.createElement("button");
          addBtn.className = "add-preset-btn";
          if (pomodoroState.isAddingPreset) addBtn.style.color = "#34c759"; // active color

          addBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M5 12h14"/></svg>`;
          addBtn.title = "Add New Preset";
          addBtn.addEventListener("click", toggleAddPresetMode);
          pomodoroPresetsContainer.appendChild(addBtn);
        }

        function togglePomodoroWidget() {
          pomodoroState.isCollapsed = !pomodoroState.isCollapsed;
          pomodoroWidget.classList.toggle(
            "collapsed",
            pomodoroState.isCollapsed
          );
          localStorage.setItem(
            "pomodoroWidgetCollapsed",
            pomodoroState.isCollapsed
          );
        }

        function saveTimerState() {
          localStorage.setItem(
            TIMER_STATE_KEY,
            JSON.stringify({
              timeLeft: pomodoroState.timeLeft,
              totalTime: pomodoroState.totalTime,
            })
          );
        }

        function setPomodoroTime(minutes) {
          pausePomodoro();
          pomodoroState.totalTime = minutes * 60;
          pomodoroState.timeLeft = minutes * 60;
          saveTimerState();
          updatePomodoroUI();
        }

        function startPomodoro() {
          if (pomodoroState.isRunning) return;
          pomodoroState.isRunning = true;
          pomodoroState.intervalId = setInterval(() => {
            if (pomodoroState.timeLeft > 0) {
              pomodoroState.timeLeft--;
              saveTimerState(); // Auto-save on tick
              updatePomodoroUI();
            } else {
              // Timer Finished
              finishPomodoro();
            }
          }, 1000);
          updatePomodoroUI();
        }

        function pausePomodoro() {
          if (!pomodoroState.isRunning) return;
          pomodoroState.isRunning = false;
          clearInterval(pomodoroState.intervalId);
          pomodoroState.intervalId = null;
          saveTimerState();
          updatePomodoroUI();
        }

        function resetPomodoro() {
          pausePomodoro();
          pomodoroState.timeLeft = pomodoroState.totalTime;
          saveTimerState();
          updatePomodoroUI();
        }

        function finishPomodoro() {
          pausePomodoro();
          analyticsManager.logPomodoro(pomodoroState.totalTime);
          pomodoroTimerDisplay.style.color = "#34c759"; // Green

          // Reset logic
          setTimeout(() => {
            pomodoroTimerDisplay.style.color = ""; // Reset color
            alert("Pomodoro Timer Finished!");
            resetPomodoro(); // This will trigger updatePomodoroUI which resets the icon
          }, 100);
        }

        function updatePomodoroUI() {
          const minutes = Math.floor(pomodoroState.timeLeft / 60);
          const seconds = pomodoroState.timeLeft % 60;
          const timeString = `${String(minutes).padStart(2, "0")}:${String(
            seconds
          ).padStart(2, "0")}`;

          pomodoroTimerDisplay.textContent = timeString;
          document.title = pomodoroState.isRunning
            ? `${timeString} - Focus`
            : "Clock App";

          if (pomodoroState.isRunning) {
            pomodoroStartBtn.classList.add("hidden");
            pomodoroPauseBtn.classList.remove("hidden");

            // Show dynamic progress when running
            if (document.getElementById("pomodoro-collapsed-default-icon")) {
              document.getElementById(
                "pomodoro-collapsed-default-icon"
              ).style.display = "none";
              document.getElementById(
                "pomodoro-collapsed-progress-container"
              ).style.display = "flex";
            }
          } else {
            pomodoroStartBtn.classList.remove("hidden");
            pomodoroPauseBtn.classList.add("hidden");

            // Revert to default icon if reset (full time left)
            if (
              pomodoroState.timeLeft === pomodoroState.totalTime &&
              document.getElementById("pomodoro-collapsed-default-icon")
            ) {
              document.getElementById(
                "pomodoro-collapsed-default-icon"
              ).style.display = "block";
              document.getElementById(
                "pomodoro-collapsed-progress-container"
              ).style.display = "none";
            } else if (
              document.getElementById("pomodoro-collapsed-default-icon")
            ) {
              // Paused mid-way -> still show progress
              document.getElementById(
                "pomodoro-collapsed-default-icon"
              ).style.display = "none";
              document.getElementById(
                "pomodoro-collapsed-progress-container"
              ).style.display = "flex";
            }
          }

          // Update Collapsed Content
          const collapsedTimeText = document.getElementById(
            "pomodoro-collapsed-time-text"
          );
          const progressCircle = document.getElementById(
            "pomodoro-progress-circle"
          );

          if (
            pomodoroState.totalTime > 0 &&
            collapsedTimeText &&
            progressCircle
          ) {
            collapsedTimeText.textContent = minutes;

            // Paused Visualization
            if (!pomodoroState.isRunning) {
              collapsedTimeText.classList.add("paused-blink"); // Use class for opacity/color if needed
              // Remove manual color ref, rely on CSS (or let paused-blink handle it)
              // If we want grey when paused, we can set it via class or keep this line if it doesn't conflict
              collapsedTimeText.style.color = "#8e8e93";
            } else {
              // REMOVED explicit darker color setting
              collapsedTimeText.style.color = ""; // Reset to inherit from CSS
              collapsedTimeText.classList.remove("paused-blink");
            }

            const elapsed = pomodoroState.totalTime - pomodoroState.timeLeft;
            const percent = elapsed / pomodoroState.totalTime;
            const roundedPercent = Math.min(Math.max(percent, 0), 1);
            const CIRCUMFERENCE = 113.1;
            const offset = CIRCUMFERENCE - roundedPercent * CIRCUMFERENCE;
            progressCircle.style.strokeDashoffset = offset;
          }

          // Update PiP if active
          if (
            document.pictureInPictureElement &&
            document.pictureInPictureElement === pomodoroPipVideo
          ) {
            drawPomodoroPiPCanvas();
          }
        }

        function drawPomodoroPiPCanvas() {
          if (!pomodoroPipCanvas) return;
          const ctx = pomodoroPipCanvas.getContext("2d");
          if (!ctx) return;

          // Background
          ctx.fillStyle = "#1c1c1e";
          ctx.fillRect(0, 0, 320, 180);

          // Time Text
          const minutes = Math.floor(pomodoroState.timeLeft / 60);
          const seconds = pomodoroState.timeLeft % 60;
          const timeString = `${String(minutes).padStart(2, "0")}:${String(
            seconds
          ).padStart(2, "0")}`;

          ctx.font =
            'bold 80px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
          ctx.fillStyle = pomodoroState.isRunning ? "#ffffff" : "#8e8e93";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(timeString, 160, 90);

          // Label
          ctx.font = "20px sans-serif";
          ctx.fillStyle = "#ff3b30"; // Pomodoro Red
          ctx.fillText("Focus", 160, 140);
        }

        async function togglePomodoroPiP() {
          try {
            if (document.pictureInPictureElement) {
              await document.exitPictureInPicture();
            } else {
              if (pomodoroPipVideo && pomodoroPipCanvas) {
                drawPomodoroPiPCanvas(); // Initial Frame
                const stream = pomodoroPipCanvas.captureStream();
                pomodoroPipVideo.srcObject = stream;
                await pomodoroPipVideo.play();
                await pomodoroPipVideo.requestPictureInPicture();
              }
            }
          } catch (err) {
            console.error("PiP Error:", err);
          }
        }

        // --- Notes Search Logic ---
        function initNotesSearch() {
          const searchBtn = document.getElementById("search-notes-btn");
          const searchBar = document.getElementById("notes-search-bar");
          const searchInput = document.getElementById("notes-search-input");
          const closeBtn = document.getElementById("search-close-btn");
          const prevBtn = document.getElementById("search-prev-btn");
          const nextBtn = document.getElementById("search-next-btn");
          const countSpan = document.getElementById("search-count");
          const notesContainer = document.getElementById(
            "notes-content-container"
          );

          let searchMatches = [];
          let currentMatchIndex = -1;

          function toggleSearch() {
            const isHidden = searchBar.classList.contains("hidden");
            if (isHidden) {
              searchBar.classList.remove("hidden");
              searchInput.focus();
              if (searchInput.value) {
                performSearch(searchInput.value);
              }
            } else {
              searchBar.classList.add("hidden");
              clearHighlights();
              searchInput.value = "";
            }
          }

          function clearHighlights() {
            const highlights =
              notesContainer.querySelectorAll(".search-highlight");
            highlights.forEach((span) => {
              const parent = span.parentNode;
              while (span.firstChild) {
                parent.insertBefore(span.firstChild, span);
              }
              parent.removeChild(span);
            });
            // Normalize text nodes to merge broken text chunks
            notesContainer.normalize();
            searchMatches = [];
            currentMatchIndex = -1;
            countSpan.classList.add("hidden");
          }

          function performSearch(query) {
            clearHighlights();
            if (!query.trim()) return;

            // Escape regex characters
            const safeQuery = query.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            const regex = new RegExp(safeQuery, "gi");

            // TreeWalker to find text nodes
            const walker = document.createTreeWalker(
              notesContainer,
              NodeFilter.SHOW_TEXT,
              {
                acceptNode: function (node) {
                  // Skip if inside existing highlight (though we cleared them)
                  // or if empty/whitespace only? No, whitespace is fine but we want content.
                  if (node.parentElement.closest(".search-highlight"))
                    return NodeFilter.FILTER_REJECT;
                  if (!node.textContent.trim()) return NodeFilter.FILTER_SKIP;
                  return NodeFilter.FILTER_ACCEPT;
                },
              },
              false
            );

            let node;
            const nodesToProcess = [];

            while ((node = walker.nextNode())) {
              if (node.textContent.match(regex)) {
                nodesToProcess.push(node);
              }
            }

            nodesToProcess.forEach((textNode) => {
              const text = textNode.textContent;
              const matches = [...text.matchAll(regex)];
              if (!matches.length) return;

              const fragment = document.createDocumentFragment();
              let lastIndex = 0;

              matches.forEach((match) => {
                const matchIndex = match.index;
                // Add text before match
                if (matchIndex > lastIndex) {
                  fragment.appendChild(
                    document.createTextNode(
                      text.substring(lastIndex, matchIndex)
                    )
                  );
                }
                // Add highlight span
                const span = document.createElement("span");
                span.className = "search-highlight";
                span.textContent = match[0];
                fragment.appendChild(span);
                searchMatches.push(span);

                lastIndex = matchIndex + match[0].length;
              });

              // Add text after last match
              if (lastIndex < text.length) {
                fragment.appendChild(
                  document.createTextNode(text.substring(lastIndex))
                );
              }

              textNode.parentNode.replaceChild(fragment, textNode);
            });

            updateSearchCount();
            if (searchMatches.length > 0) {
              scrollToMatch(0);
            } else {
              countSpan.textContent = "0/0";
              countSpan.classList.remove("hidden");
            }
          }

          function updateSearchCount() {
            if (searchMatches.length === 0) {
              countSpan.classList.add("hidden");
              return;
            }
            countSpan.classList.remove("hidden");
            countSpan.textContent = `${currentMatchIndex + 1}/${
              searchMatches.length
            }`;
          }

          function scrollToMatch(index) {
            if (index < 0 || index >= searchMatches.length) return;

            // Remove 'current' from old match
            if (currentMatchIndex >= 0 && searchMatches[currentMatchIndex]) {
              searchMatches[currentMatchIndex].classList.remove("current");
            }

            currentMatchIndex = index;
            const match = searchMatches[index];
            match.classList.add("current");
            match.scrollIntoView({ behavior: "smooth", block: "center" });
            updateSearchCount();
          }

          // Event Listeners
          if (searchBtn) {
            searchBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              toggleSearch();
            });
          }

          if (closeBtn) {
            closeBtn.addEventListener("click", (e) => {
              e.preventDefault();
              toggleSearch();
            });
          }

          if (searchInput) {
            searchInput.addEventListener("input", (e) => {
              performSearch(e.target.value);
            });

            searchInput.addEventListener("keydown", (e) => {
              e.stopPropagation(); // Prevent clock shortcuts
              if (e.key === "Enter") {
                if (searchMatches.length > 0) {
                  const direction = e.shiftKey ? -1 : 1;
                  let nextIndex = currentMatchIndex + direction;
                  if (nextIndex >= searchMatches.length) nextIndex = 0;
                  if (nextIndex < 0) nextIndex = searchMatches.length - 1;
                  scrollToMatch(nextIndex);
                }
              } else if (e.key === "Escape") {
                toggleSearch();
              }
            });

            // Prevent clicks from bubbling
            searchInput.addEventListener("click", (e) => e.stopPropagation());
          }

          if (nextBtn) {
            nextBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              if (searchMatches.length > 0) {
                let nextIndex = currentMatchIndex + 1;
                if (nextIndex >= searchMatches.length) nextIndex = 0;
                scrollToMatch(nextIndex);
              }
            });
          }

          if (prevBtn) {
            prevBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              if (searchMatches.length > 0) {
                let prevIndex = currentMatchIndex - 1;
                if (prevIndex < 0) prevIndex = searchMatches.length - 1;
                scrollToMatch(prevIndex);
              }
            });
          }

          // Prevent search bar clicks from closing things?
          if (searchBar) {
            searchBar.addEventListener("click", (e) => e.stopPropagation());
          }
        }

        // --- Analytics Manager ---
        // --- Analytics Manager ---
        class AnalyticsManager {
          constructor() {
            this.history = JSON.parse(
              localStorage.getItem("clockPomodoroHistory") || "[]"
            );
          }

          getDateKey(date) {
            const d = new Date(date);
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, "0");
            const day = String(d.getDate()).padStart(2, "0");
            return `${year}-${month}-${day}`;
          }

          logPomodoro(duration) {
            const entry = {
              date: this.getDateKey(new Date()),
              timestamp: Date.now(),
              duration: duration,
            };
            this.history.push(entry);
            this.saveHistory();
          }

          saveHistory() {
            localStorage.setItem(
              "clockPomodoroHistory",
              JSON.stringify(this.history)
            );
          }

          getPomodoroStats(startDate, endDate) {
            const startStr = this.getDateKey(startDate);
            const endStr = this.getDateKey(endDate);

            const filtered = this.history.filter(
              (h) => h.date >= startStr && h.date <= endStr
            );

            const totalDuration = filtered.reduce(
              (sum, h) => sum + h.duration,
              0
            );
            return {
              count: filtered.length,
              totalMinutes: Math.floor(totalDuration / 60),
              sessions: filtered,
            };
          }

          getTaskStats(startDate, endDate) {
            let totalTasks = 0;
            let completedTasks = 0;
            let totalDuration = 0;
            let categoryBreakdown = {};

            // Iterate dates
            const current = new Date(startDate);
            while (current <= endDate) {
              const key = this.getDateKey(current);
              const tasks = tasksByDate[key] || [];

              tasks.forEach((t) => {
                totalTasks++;
                if (t.completed) {
                  completedTasks++;
                  let duration = t.endHour - t.startHour;
                  if (duration < 0) duration += 24;
                  totalDuration += duration;

                  // Category
                  if (!categoryBreakdown[t.color])
                    categoryBreakdown[t.color] = 0;
                  categoryBreakdown[t.color] += duration;
                }
              });
              current.setDate(current.getDate() + 1);
            }

            return {
              completionRate:
                totalTasks > 0
                  ? Math.round((completedTasks / totalTasks) * 100)
                  : 0,
              totalTasks,
              completedTasks,
              totalHours: totalDuration.toFixed(1),
              categoryBreakdown,
            };
          }

          getHabitStats(startDate, endDate) {
            const dayCount = (endDate - startDate) / (1000 * 60 * 60 * 24) + 1;
            const totalHabits = habits.length;
            if (totalHabits === 0) return { consistency: 0, topHabits: [] };

            let totalOpportunities = totalHabits * dayCount;
            let totalCompletions = 0;
            const habitScores = habits.map((h) => ({
              ...h,
              periodCompletions: 0,
            }));

            const current = new Date(startDate);
            while (current <= endDate) {
              const key = this.getDateKey(current);
              habitScores.forEach((h) => {
                if (h.history[key]) {
                  totalCompletions++;
                  h.periodCompletions++;
                }
              });
              current.setDate(current.getDate() + 1);
            }

            habitScores.sort(
              (a, b) => b.periodCompletions - a.periodCompletions
            );

            return {
              consistency:
                totalOpportunities > 0
                  ? Math.round((totalCompletions / totalOpportunities) * 100)
                  : 0,
              topHabits: habitScores.slice(0, 3),
            };
          }
        }

        const analyticsManager = new AnalyticsManager();

        // --- Analytics Widget Logic ---
        function initAnalyticsWidget() {
          const widget = document.getElementById("analytics-widget");
          const toggleBtn = document.getElementById("toggle-analytics-btn");
          const closeBtn = document.getElementById("close-analytics-btn");
          const rangeSelector = document.getElementById(
            "analytics-range-selector"
          );

          if (!widget || !toggleBtn) return;

          function openAnalytics() {
            widget.classList.remove("hidden");
            updateAnalytics();
          }

          function closeAnalytics() {
            widget.classList.add("hidden");
          }

          toggleBtn.addEventListener("click", openAnalytics);
          if (closeBtn) closeBtn.addEventListener("click", closeAnalytics);

          // Close on Esc
          document.addEventListener("keydown", (e) => {
            if (e.key === "Escape" && !widget.classList.contains("hidden")) {
              closeAnalytics();
            }
          });

          // Range Selector
          if (rangeSelector) {
            rangeSelector.addEventListener("change", updateAnalytics);
          }

          function updateAnalytics() {
            const range = rangeSelector ? rangeSelector.value : "7";
            const endDate = new Date();
            let startDate = new Date();
            startDate.setHours(0, 0, 0, 0);

            if (range === "7") {
              startDate.setDate(endDate.getDate() - 6);
            } else if (range === "30") {
              startDate.setDate(endDate.getDate() - 29);
            } else if (range === "thisMonth") {
              startDate = new Date(
                endDate.getFullYear(),
                endDate.getMonth(),
                1
              );
            }

            // 1. Get Stats from Manager
            const taskStats = analyticsManager.getTaskStats(startDate, endDate);
            const habitStats = analyticsManager.getHabitStats(
              startDate,
              endDate
            );
            const pomodoroStats = analyticsManager.getPomodoroStats(
              startDate,
              endDate
            );

            // 2. Update Overview Cards
            document.getElementById(
              "metric-productivity"
            ).textContent = `${taskStats.completionRate}%`;
            document.getElementById(
              "metric-focus"
            ).textContent = `${pomodoroStats.totalMinutes}m`; // Changed to minutes for precision or use h/m logic
            if (pomodoroStats.totalMinutes > 60) {
              document.getElementById("metric-focus").textContent = `${(
                pomodoroStats.totalMinutes / 60
              ).toFixed(1)}h`;
            }
            document.getElementById(
              "metric-focus-count"
            ).textContent = `${pomodoroStats.count} sessions`;

            document.getElementById(
              "metric-habits"
            ).textContent = `${habitStats.consistency}%`;

            // 3. Render Top Habits
            const topHabitsList = document.getElementById("top-habits-list");
            topHabitsList.innerHTML = "";
            habitStats.topHabits.forEach((h) => {
              const li = document.createElement("li");
              li.innerHTML = `
                <div style="display:flex;align-items:center;gap:8px;">
                   <div style="width:10px;height:10px;border-radius:2px;background:${h.color}"></div>
                   ${h.name}
                </div>
                <span>${h.periodCompletions} times</span>
              `;
              topHabitsList.appendChild(li);
            });
            if (habitStats.topHabits.length === 0) {
              topHabitsList.innerHTML = `<li style="justify-content:center;color:var(--secondary-color);">No habits tracked yet</li>`;
            }

            // 4. Render Charts
            renderActivityChart(startDate, endDate);
            renderCategoryChart(taskStats.categoryBreakdown);
          }

          function renderActivityChart(startDate, endDate) {
            const container = document.getElementById("activity-chart");
            container.innerHTML = "";
            const width = container.clientWidth;
            const height = 250;
            const margin = { top: 20, right: 20, bottom: 30, left: 40 };

            // Generate daily data
            const data = [];
            const current = new Date(startDate);
            while (current <= endDate) {
              const dateKey = analyticsManager.getDateKey(current);
              const dayTasks = tasksByDate[dateKey] || [];
              let mins = 0;
              dayTasks.forEach((t) => {
                // Count both completed & uncompleted for "Activity Load"? Or just completed?
                // Let's do Completed time for "Productivity"
                if (t.completed) {
                  let d = t.endHour - t.startHour;
                  if (d < 0) d += 24;
                  mins += d * 60;
                }
              });

              // Add pomodoro time?
              const pomodoroDaily = analyticsManager.history
                .filter((h) => h.date === dateKey)
                .reduce((s, h) => s + h.duration / 60, 0); // stored in seconds? Wait, logPomodoro uses pomodoroState.totalTime which is SECONDS.
              // pomodoroState.totalTime is in seconds usually. let's check.
              // Yes, default 25*60.
              // So stored duration is seconds.
              // Convert to minutes.
              const pomodoroMins = pomodoroDaily; // actually logic above used duration.

              // Let's assume logPomodoro receives SECONDS.
              // Total Mins = Task Mins + Pomodoro Mins (overlap might exist but simplfy for now)

              data.push({
                date: new Date(current),
                label: new Date(current).toLocaleDateString("en-US", {
                  weekday: "short",
                }),
                value: mins + pomodoroMins,
              });
              current.setDate(current.getDate() + 1);
            }

            const maxVal = Math.max(...data.map((d) => d.value), 60); // Min scale 1h

            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            svg.setAttribute("width", "100%");
            svg.setAttribute("height", "100%");
            svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
            svg.classList.add("bar-chart-svg");

            const chartW = width - margin.left - margin.right;
            const chartH = height - margin.top - margin.bottom;

            // Axis Lines
            const axisColor = "var(--border-color)";
            const baseLine = document.createElementNS(svgNS, "line");
            baseLine.setAttribute("x1", margin.left);
            baseLine.setAttribute("y1", height - margin.bottom);
            baseLine.setAttribute("x2", width - margin.right);
            baseLine.setAttribute("y2", height - margin.bottom);
            baseLine.setAttribute("stroke", axisColor);
            svg.appendChild(baseLine);

            // Bars
            const barWidth = (chartW / data.length) * 0.6;
            const spacing = chartW / data.length;

            data.forEach((d, i) => {
              const x = margin.left + i * spacing + (spacing - barWidth) / 2;
              const barH = (d.value / maxVal) * chartH;
              const y = height - margin.bottom - barH;

              const rect = document.createElementNS(svgNS, "rect");
              rect.setAttribute("x", x);
              rect.setAttribute("y", y);
              rect.setAttribute("width", barWidth);
              rect.setAttribute("height", barH);
              rect.setAttribute("fill", "var(--primary-color)");
              rect.setAttribute("rx", 4);
              rect.classList.add("bar-rect");

              // Tooltip title
              const title = document.createElementNS(svgNS, "title");
              title.textContent = `${d.date.toDateString()}: ${Math.round(
                d.value
              )} mins`;
              rect.appendChild(title);

              const label = document.createElementNS(svgNS, "text");
              label.setAttribute("x", x + barWidth / 2);
              label.setAttribute("y", height - margin.bottom + 15);
              label.textContent = d.label;
              label.classList.add("bar-label");

              svg.appendChild(rect);
              svg.appendChild(label);
            });

            container.appendChild(svg);
          }

          function renderCategoryChart(breakdown) {
            const container = document.getElementById("category-chart");
            const legendContainer = document.getElementById("category-legend");
            container.innerHTML = "";
            legendContainer.innerHTML = "";

            const entries = Object.entries(breakdown);
            // Sort by value
            entries.sort((a, b) => b[1] - a[1]);

            const total = entries.reduce((s, [_, v]) => s + v, 0);
            if (total === 0) {
              container.innerHTML = `<span style="color:var(--secondary-color)">No data</span>`;
              return;
            }

            const svgNS = "http://www.w3.org/2000/svg";
            const size = 200;
            const center = size / 2;
            const radius = 80;
            const strokeWidth = 40;

            const svg = document.createElementNS(svgNS, "svg");
            svg.setAttribute("width", size);
            svg.setAttribute("height", size);
            svg.setAttribute("viewBox", `0 0 ${size} ${size}`);
            svg.classList.add("donut-svg");

            let startAngle = 0;
            entries.forEach(([color, value]) => {
              const portion = value / total;
              const endAngle = startAngle + portion * 360;

              // Describe arc
              const x1 =
                center + radius * Math.cos((Math.PI * startAngle) / 180);
              const y1 =
                center + radius * Math.sin((Math.PI * startAngle) / 180);
              const x2 = center + radius * Math.cos((Math.PI * endAngle) / 180);
              const y2 = center + radius * Math.sin((Math.PI * endAngle) / 180);

              const largeArc = portion > 0.5 ? 1 : 0;

              // Donut path? Or simple circle strokes?
              // Stroke method is easier for donuts
              // Circumference = 2 * PI * r
              // dasharray = portion * C, spaced by C

              // Let's use the stroke-dasharray method on a circle
              // We need multiple circles or one circle with segments?
              // SVG segments are standard.

              const path = document.createElementNS(svgNS, "path");
              const d = [
                `M ${center} ${center}`,
                `L ${x1} ${y1}`,
                `A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2}`,
                `Z`,
              ].join(" ");

              // Actually proper Donut logic:
              // Move to start of outer arc
              // Arc to end of outer arc
              // Line to end of inner arc
              // Arc to start of inner arc
              // Close

              // Easier: just stroke circle segments
              const r = 70;
              const c = 2 * Math.PI * r;
              const dash = portion * c;

              const circle = document.createElementNS(svgNS, "circle");
              circle.setAttribute("cx", center);
              circle.setAttribute("cy", center);
              circle.setAttribute("r", r);
              circle.setAttribute("fill", "transparent");
              circle.setAttribute("stroke", color);
              circle.setAttribute("stroke-width", 25);
              circle.setAttribute("stroke-dasharray", `${dash} ${c}`);
              circle.setAttribute(
                "stroke-dashoffset",
                -1 * (startAngle / 360) * c
              ); // Rotate check
              // SVG rotation start is 3 o'clock.
              // We want to accumulate offsets.

              // Actually, rotational transform is cleaner.
              circle.setAttribute(
                "transform",
                `rotate(${startAngle} ${center} ${center})`
              );
              circle.setAttribute("stroke-dashoffset", 0);
              // But dasharray gap needs to be handled?
              // If we rotate each circle by startAngle, the dash will start at 3 o'clock relative to rotation.
              // So yes.

              svg.appendChild(circle);

              startAngle += portion * 360;

              // Legend
              const legItem = document.createElement("div");
              legItem.className = "legend-item";
              legItem.innerHTML = `<div class="legend-color" style="background:${color}"></div><span>${Math.round(
                portion * 100
              )}%</span>`;
              legendContainer.appendChild(legItem);
            });

            container.appendChild(svg);
          }
        }

        // --- Initialization ---
        function init() {
          initAnalyticsWidget(); // ADD THIS
          initTopicNotes();
          initPomodoroWidget();
          // Event Listeners for Toggles
          document.querySelectorAll('input[name="clockMode"]').forEach((r) =>
            r.addEventListener("change", (e) => {
              clockMode = e.target.value;
              localStorage.setItem("clockMode", clockMode);

              if (clockMode === "12h") {
                const nowHour = new Date().getHours();
                const isPm = nowHour >= 12;
                ampm = isPm ? "pm" : "am";

                // Update UI controls to match
                document.getElementById("mode-am").checked = !isPm;
                document.getElementById("mode-pm").checked = isPm;
              }

              ampmControls.classList.toggle("hidden", clockMode === "24h");
              viewModeControls.classList.toggle("hidden", clockMode !== "24h");
              renderAppView();
            })
          );
          document.querySelectorAll('input[name="ampm"]').forEach((r) =>
            r.addEventListener("change", (e) => {
              ampm = e.target.value;
              renderAppView();
            })
          );
          document.querySelectorAll('input[name="viewMode"]').forEach((r) =>
            r.addEventListener("change", (e) => {
              viewMode = e.target.value;
              renderAppView();
            })
          );

          // Event Listeners for Dragging
          svg.addEventListener("mousedown", handleDragStart);
          todayBlock.addEventListener("mousedown", (e) => {
            handleBlockDragStart(e, selectedDate, todayBlock);
          });
          yesterdayBlock.addEventListener("mousedown", (e) => {
            const yesterday = new Date(selectedDate);
            yesterday.setDate(selectedDate.getDate() - 1);
            handleBlockDragStart(e, yesterday, yesterdayBlock);
          });
          tomorrowBlock.addEventListener("mousedown", (e) => {
            const tomorrow = new Date(selectedDate);
            tomorrow.setDate(selectedDate.getDate() + 1);
            handleBlockDragStart(e, tomorrow, tomorrowBlock);
          });

          // Event Listeners for Modal
          // Event listener to EXPAND the widget
          progressWidgetCounter.addEventListener("click", toggleTaskListView);

          // Event listener for the new CLOSE button to COLLAPSE the widget
          taskListCloseBtn.addEventListener("click", toggleTaskListView);
          saveTaskBtn.addEventListener("click", saveTask);
          cancelTaskBtn.addEventListener("click", hideModal);
          deleteTaskBtn.addEventListener("click", deleteTask);
          modal.parentElement.addEventListener("click", (e) => {
            if (e.target === modal.parentElement) hideModal();
          });
          modal.addEventListener("click", (e) => e.stopPropagation());

          // Event Listeners for Calendar
          // Event Listeners for Calendar
          prevMonthBtn.addEventListener("click", () => {
            if (isCalendarCollapsed) {
              displayedDate.setDate(displayedDate.getDate() - 7);
            } else {
              displayedDate.setMonth(displayedDate.getMonth() - 1);
            }
            progressWidget.classList.remove("expanded-view");
            renderCalendar();
            renderHabits(); // Sync habits
          });
          nextMonthBtn.addEventListener("click", () => {
            if (isCalendarCollapsed) {
              displayedDate.setDate(displayedDate.getDate() + 7);
            } else {
              displayedDate.setMonth(displayedDate.getMonth() + 1);
            }
            progressWidget.classList.remove("expanded-view");
            renderCalendar();
            renderHabits(); // Sync habits
          });
          document
            .getElementById("month-year-header")
            .addEventListener("click", () => {
              const newYear = prompt(
                "Enter year:",
                displayedDate.getFullYear()
              );
              if (!newYear || isNaN(newYear)) return;
              const newMonth = prompt(
                "Enter month (1-12):",
                displayedDate.getMonth() + 1
              );
              if (!newMonth || isNaN(newMonth) || newMonth < 1 || newMonth > 12)
                return;
              displayedDate = new Date(newYear, newMonth - 1, 1);
              renderCalendar();
              renderHabits(); // Sync habits
            });

          // Initialize Color Selector
          COLORS.forEach((color, index) => {
            const option = document.createElement("div");
            option.className = "color-option";
            option.style.backgroundColor = color;
            option.dataset.color = color;
            if (index === 0) option.classList.add("selected");
            option.addEventListener("click", () => {
              document
                .querySelector(".color-option.selected")
                ?.classList.remove("selected");
              option.classList.add("selected");
            });
            colorSelector.appendChild(option);
          });
          calendarWeekdaysEl.innerHTML = [
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat",
            "Sun",
          ]
            .map((day) => `<div class="weekday">${day}</div>`)
            .join("");

          // --- Calendar Collapse State (Added functionality) ---
          // isCalendarCollapsed is defined in State
          const toggleCalendarBtn = document.getElementById(
            "toggle-calendar-btn"
          );

          function initCalendarState() {
            const widget = document.querySelector(".calendar-widget");

            function updateState() {
              widget.classList.toggle("collapsed", isCalendarCollapsed);

              // Sync displayedDate to selectedDate when entering collapse mode, if not aligned?
              // Or keep user context?
              // User likely expects "Current Week" on initial collapse.
              if (isCalendarCollapsed) {
                // Check if displayedDate is far from selectedDate?
                // Actually, better: if switching TO collapsed, center on selectedDate.
                // But we don't know if we just switched or if we are initing.
                // We can rely on renderCalendar() using displayedDate.
                // Only logic: ensure displayedDate is synced to selectedDate on Toggle?
                // Or just leave it. Leaving it is safer for persistence if user navigated.

                toggleCalendarBtn.innerHTML = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line></svg>`;
                toggleCalendarBtn.title = "Expand";
              } else {
                toggleCalendarBtn.innerHTML = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 14 10 14 10 20"></polyline><polyline points="20 10 14 10 14 4"></polyline></svg>`;
                toggleCalendarBtn.title = "Collapse";
              }
              renderCalendar();
            }

            updateState(); // Initial

            toggleCalendarBtn.addEventListener("click", () => {
              isCalendarCollapsed = !isCalendarCollapsed;
              localStorage.setItem(
                "calendarWidgetCollapsed",
                isCalendarCollapsed
              );
              // On toggle, if collapsing, jump to selected date context
              if (isCalendarCollapsed) {
                displayedDate = new Date(selectedDate);
              } else {
                // If expanding, keep the month we were looking at in week view
                // displayedDate is already set to the week's anchor.
                displayedDate.setDate(1); // Snap to 1st to be clean for Month logic?
                // Actually Month logic handles any date, but uses 1st for calculations.
              }
              updateState();
            });
          }
          initCalendarState();

          // --- CODE TO ADD: Inside init(), before the "// Initial render" comment ---

          // --- Notes Widget Logic ---
          // NEW: Collapse State Management for Notes
          let isNotesWidgetCollapsed =
            localStorage.getItem("notesWidgetCollapsed") === "true";

          function initNotesWidgetState() {
            const widget = document.getElementById("notes-widget");
            if (isNotesWidgetCollapsed) {
              widget.classList.add("collapsed");
            } else {
              widget.classList.remove("collapsed");
            }

            // Toggle Button Listener
            document
              .getElementById("toggle-notes-widget-btn")
              .addEventListener("click", (e) => {
                e.stopPropagation();
                toggleNotesWidget();
              });

            // Also allow expanding by clicking the collapsed icon (or widget body when collapsed)
            widget.addEventListener("click", (e) => {
              if (widget.classList.contains("collapsed")) {
                toggleNotesWidget();
              }
            });

            // Prevent clicks inside header/content from toggling when expanded (except the toggle btn)
            document
              .querySelector(".notes-widget-header")
              .addEventListener("click", (e) => e.stopPropagation());
            document
              .querySelector("#notes-content-container")
              .addEventListener("click", (e) => e.stopPropagation());
          }

          function toggleNotesWidget() {
            const widget = document.getElementById("notes-widget");
            isNotesWidgetCollapsed = !isNotesWidgetCollapsed;
            widget.classList.toggle("collapsed", isNotesWidgetCollapsed);
            localStorage.setItem(
              "notesWidgetCollapsed",
              isNotesWidgetCollapsed
            );

            // NEW: If expanding, scroll to today ONLY if it hasn't happened yet
            if (!isNotesWidgetCollapsed && !hasInitialNotesScrollHappened) {
              setTimeout(() => {
                const todayKey = getDateKey(new Date());
                const todayElement = document.getElementById(
                  `note-section-${todayKey}`
                );
                if (todayElement) {
                  todayElement.scrollIntoView({
                    behavior: "smooth",
                    block: "start",
                  });
                  hasInitialNotesScrollHappened = true;
                }
              }, 300);
            }
          }

          // Initialize Widgets
          initEventsWidget();
          initHabitWidgetState();
          initHabitColorSelector();
          initNotesWidgetState();
          initNotesSearch();

          // --- Sync Clock Mode UI from State ---
          if (clockMode === "12h") {
            document.getElementById("mode-12h").checked = true;
            document.getElementById("mode-24h").checked = false;

            // Set correct AM/PM
            const nowHour = new Date().getHours();
            const isPm = nowHour >= 12;
            ampm = isPm ? "pm" : "am";
            document.getElementById("mode-am").checked = !isPm;
            document.getElementById("mode-pm").checked = isPm;

            ampmControls.classList.remove("hidden");
            viewModeControls.classList.add("hidden");
          } else {
            // 24h default check
            document.getElementById("mode-24h").checked = true;
            document.getElementById("mode-12h").checked = false;
            ampmControls.classList.add("hidden");
            viewModeControls.classList.remove("hidden");
          }

          initTheme(); // <--- ADDED THIS CALL for Dark Mode

          function initTheme() {
            const toggleBtn = document.getElementById("dark-mode-toggle");
            const body = document.body;

            // Check LocalStorage
            const savedTheme = localStorage.getItem("theme");
            if (savedTheme === "dark") {
              body.classList.add("dark-mode");
            }

            // Update Icon
            function updateIcon() {
              const isDark = body.classList.contains("dark-mode");
              // Sun icon for dark mode (to switch to light), Moon for light mode
              // Currently using Moon icon generic in HTML.
              // Let's swap the SVG content based on mode if we want,
              // or just keep it simple. The user requested "revert back to light mode colors".
              // Let's toggle the inner SVG to a Sun if dark.
              if (isDark) {
                toggleBtn.innerHTML = `
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="5"></circle>
                    <line x1="12" y1="1" x2="12" y2="3"></line>
                    <line x1="12" y1="21" x2="12" y2="23"></line>
                    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                    <line x1="1" y1="12" x2="3" y2="12"></line>
                    <line x1="21" y1="12" x2="23" y2="12"></line>
                    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                  </svg>`; // Sun Icon
              } else {
                toggleBtn.innerHTML = `
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                  </svg>`; // Moon Icon
              }
            }

            // Run once on init
            updateIcon();

            toggleBtn.addEventListener("click", () => {
              body.classList.toggle("dark-mode");
              const isDark = body.classList.contains("dark-mode");
              localStorage.setItem("theme", isDark ? "dark" : "light");
              updateIcon();

              // Force re-render of canvas elements if needed (ticks, etc rely on CSS variables?
              // No, they are drawn once. We might need to re-render clock face to pick up new colors if they are read from JS)
              // Checking renderClockFace usage...
              // renderClockFace(); // This might be needed if colors are hardcoded/computed in JS.
              // Let's assume CSS variables handle DOM elements, but Canvas/SVG generated by JS might need update.
              // The clock uses SVG elements changed via class?
              // Looking at CSS: .clock-tick { stroke: var(--secondary-color); }
              // So CSS variables Update automatically! Great.
              // What about the preview-arc? It uses fill: var(--primary-color).
              // So most things should update automatically.
            });
          }

          // Habit Tracker Events
          addHabitBtn.addEventListener("click", () => {
            habitNameInput.value = "";
            habitModalOverlay.classList.add("visible");
            habitNameInput.focus();
          });
          cancelHabitBtn.addEventListener("click", () =>
            habitModalOverlay.classList.remove("visible")
          );
          saveHabitBtn.addEventListener("click", () => {
            const name = habitNameInput.value.trim();
            if (name) {
              addHabit(name, selectedHabitColor);
              habitModalOverlay.classList.remove("visible");
            }
          });
          habitModalOverlay.addEventListener("click", (e) => {
            if (e.target === habitModalOverlay)
              habitModalOverlay.classList.remove("visible");
          });

          // Event Listeners for Notes Widget
          loadNotes();
          loadTopicNotes(); // Fix: Load topic notes on initialization

          notesContainer.addEventListener("focusin", (e) => {
            const editor = e.target.closest(".note-editor");
            if (editor) {
              activeEditorInstance = editor;
            }
          });

          notesContainer.addEventListener("input", (e) => {
            // Debounce saving
            clearTimeout(window.saveTimeout);
            window.saveTimeout = setTimeout(saveCurrentNote, 500);
          });

          // NEW: Delegated Change Listener for Todo Checkboxes (Fixes persistence issue)
          notesContainer.addEventListener("change", (e) => {
            if (e.target.classList.contains("todo-checkbox")) {
              const checkbox = e.target;
              const div = checkbox.closest(".todo-item");
              const editor = checkbox.closest(".note-editor");

              if (div && editor) {
                // Toggle visual class
                if (checkbox.checked) {
                  div.classList.add("checked");
                  checkbox.setAttribute("checked", "true"); // Update attribute for innerHTML persistence
                } else {
                  div.classList.remove("checked");
                  checkbox.removeAttribute("checked");
                }

                // Save
                activeEditorInstance = editor;
                saveCurrentNote();
              }
            }
          });

          // Note: Specific event listeners for the editor (input, keydown) are now delegated
          // or attached in createNoteSection.

          notesContainer.addEventListener("click", (e) => {
            // Notion-like "click below to add new line" feature
            if (e.target === notesContainer) {
              // Focus the last visible note section's editor
              const lastSection = notesContainer.lastElementChild;
              if (lastSection) {
                const editor = lastSection.querySelector(".note-editor");
                if (editor) {
                  editor.focus();
                  // Move cursor to end
                  const range = document.createRange();
                  range.selectNodeContents(editor);
                  range.collapse(false);
                  const sel = window.getSelection();
                  sel.removeAllRanges();
                  sel.addRange(range);

                  // If explicit click below, maybe add a new paragraph?
                  // For now, focusing is enough.
                }
              }
            }
          });

          jumpToTodayBtn.addEventListener("click", () => {
            const todayKey = getDateKey(new Date());
            const todayElement = document.getElementById(
              `note-section-${todayKey}`
            );
            if (todayElement) {
              todayElement.scrollIntoView({
                behavior: "smooth",
                block: "start",
              });
            } else {
              // If today's note doesn't exist, create it by focusing
              currentNotesDate = new Date();
              renderNotesWidget();
            }
          });

          // NEW: Toggle Click
          if (formatToggleGroup) {
            formatToggleGroup.addEventListener("click", (e) => {
              e.stopPropagation();
              use12HourLabels = !use12HourLabels;
              updateFormatToggleVisibility();
              renderClockFace();
            });
          }

          // ==========================================
          // ==           TASKS TAB EXTENSION        ==
          // ==========================================

          // ==========================================
          // ==           TASKS TAB EXTENSION        ==
          // ==========================================

          // Declarations moved to global scope

          // Data Migration & Initialization
          if (clockTaskTabs.length === 0) {
            const oldTasks = JSON.parse(
              localStorage.getItem("clockBrainDump") || "[]"
            );
            let initialContent = "";

            if (oldTasks.length > 0) {
              initialContent = oldTasks
                .map((t) => {
                  let indentClass =
                    t.indent === 1
                      ? "indent-1"
                      : t.indent === 2
                      ? "indent-2"
                      : "";
                  if (t.isSpacer) return "<p><br></p>";
                  const checkedAttr = t.completed ? "checked" : "";
                  return `<div class="todo-item ${indentClass}">
                             <input type="checkbox" class="todo-checkbox" ${checkedAttr}>
                             <div class="list-content">${t.text || ""}</div>
                           </div>`;
                })
                .join("");
            } else {
              const oldHTML = localStorage.getItem("clockBrainDumpHTML");
              if (oldHTML) {
                initialContent = oldHTML;
              } else {
                initialContent = `<div class="todo-item">
                                         <input type="checkbox" class="todo-checkbox">
                                         <div class="list-content" placeholder="Dump your tasks here..."></div>
                                       </div>`;
              }
            }

            const generalTab = {
              id: "tab-" + Date.now(),
              name: "General",
              content: initialContent,
            };
            clockTaskTabs = [generalTab];
            activeTaskTabId = generalTab.id;
            saveTaskTabs();
          }

          if (!clockTaskTabs.find((t) => t.id === activeTaskTabId)) {
            if (clockTaskTabs.length > 0) {
              activeTaskTabId = clockTaskTabs[0].id;
              localStorage.setItem("activeTaskTabId", activeTaskTabId);
            }
          }

          const tabNotes = document.getElementById("tab-notes");
          const tabTasks = document.getElementById("tab-tasks");
          const tasksContentContainer = document.getElementById(
            "tasks-content-container"
          );
          const finalNotesContentContainer = document.getElementById(
            "notes-content-container"
          );
          const clearTasksBtn = document.getElementById("clear-tasks-btn");
          const brainDumpList = document.getElementById("brain-dump-list");
          brainDumpList.classList.add("note-editor", "brain-dump-editor");
          brainDumpList.contentEditable = true;
          brainDumpList.id = "brain-dump-editor";
          brainDumpList.setAttribute("spellcheck", "false");

          // Multi-Tab Elements
          const tabTasksRow = document.getElementById("task-tabs-row");
          const tabTasksList = document.getElementById("task-tabs-list");
          const addTaskTabBtn = document.getElementById("add-task-tab-btn");

          function saveTaskTabs() {
            localStorage.setItem(
              "clockTaskTabs",
              JSON.stringify(clockTaskTabs)
            );
            localStorage.setItem("activeTaskTabId", activeTaskTabId);
          }

          function renderTaskTabs() {
            if (!tabTasksList) return;
            tabTasksList.innerHTML = "";
            clockTaskTabs.forEach((tab) => {
              const tabEl = document.createElement("div");
              tabEl.className = `task-tab ${
                tab.id === activeTaskTabId ? "active" : ""
              }`;

              const nameSpan = document.createElement("span");
              nameSpan.className = "task-tab-name";
              nameSpan.textContent = tab.name;

              // NEW: Single Click Rename Logic (UX: Click to switch, Click again to rename)
              nameSpan.onclick = (e) => {
                // If tab is already active, clicking the name triggers rename
                if (tab.id === activeTaskTabId) {
                  e.stopPropagation();

                  // Replace span with input
                  const input = document.createElement("input");
                  input.className = "task-tab-input";
                  input.value = tab.name;

                  const save = () => {
                    let newName = input.value.trim();
                    if (newName && newName !== "") {
                      tab.name = newName;
                      saveTaskTabs();
                    }
                    renderTaskTabs();
                  };

                  input.onblur = save;
                  input.onkeydown = (ev) => {
                    if (ev.key === "Enter") {
                      input.blur(); // Triggers save via onblur
                    }
                    if (ev.key === "Escape") {
                      renderTaskTabs(); // Cancel
                    }
                    ev.stopPropagation();
                  };

                  tabEl.innerHTML = ""; // Clear tab content
                  tabEl.appendChild(input);
                  // Re-append close button if needed, but usually input takes full width
                  // But for consistency:
                  /*
                   if (clockTaskTabs.length > 1) {
                      const closeBtn = document.createElement("span");
                      // ... re-creation logic if we wanted close btn during edit ...
                      // simplicity: hide close button during edit
                   }
                   */

                  input.focus();
                  input.select();
                }
                // If not active, let it bubble to tabEl.onclick to switch tabs
              };

              const closeBtn = document.createElement("span");
              closeBtn.className = "task-tab-close-btn";
              closeBtn.innerHTML = "&times;";
              closeBtn.onclick = (e) => {
                e.stopPropagation();
                deleteTaskTab(tab.id);
              };

              // Main Tab Click (Switching)
              tabEl.onclick = (e) => {
                if (e.target.tagName === "INPUT") return;
                switchTaskTab(tab.id);
              };

              tabEl.appendChild(nameSpan);
              if (clockTaskTabs.length > 1) {
                tabEl.appendChild(closeBtn);
              }
              tabTasksList.appendChild(tabEl);

              if (tab.id === activeTaskTabId) {
                tabEl.scrollIntoView({
                  behavior: "smooth",
                  block: "nearest",
                  inline: "center",
                });
              }
            });
          }

          function addTaskTab() {
            const newTab = {
              id: "tab-" + Date.now(),
              name: "New Tab",
              content: `<div class="todo-item">
                              <input type="checkbox" class="todo-checkbox">
                              <div class="list-content" placeholder="Dump your tasks here..."></div>
                            </div>`,
            };
            clockTaskTabs.push(newTab);
            switchTaskTab(newTab.id);
          }

          function switchTaskTab(id) {
            // Save current tab content first
            saveTaskTabContent();

            activeTaskTabId = id;
            saveTaskTabs();
            renderTaskTabs();
            renderBrainDump();
          }

          function saveTaskTabContent() {
            const activeTab = clockTaskTabs.find(
              (t) => t.id === activeTaskTabId
            );
            if (activeTab && brainDumpList) {
              activeTab.content = brainDumpList.innerHTML;
              saveTaskTabs();
            }
          }

          function updateTabName(id, currentName) {
            const tab = clockTaskTabs.find((t) => t.id === id);
            if (!tab) return;

            // Inline edit for better UX
            // Find just matching element to prevent re-render flash during edit if desired,
            // but prompt is safer for now as requested or implied "double click to rename".
            // Implementation of inline input swap:

            // Re-render to ensure we have the element ref
            renderTaskTabs();

            // Find the element text node
            // For now, using prompt as it's robust and simple for this phase
            const newName = prompt("Rename Tab:", currentName);
            if (newName && newName.trim() !== "") {
              tab.name = newName.trim();
              saveTaskTabs();
              renderTaskTabs();
            }
          }

          function deleteTaskTab(id) {
            const tab = clockTaskTabs.find((t) => t.id === id);
            if (!tab) return;

            const modalOverlay = document.getElementById("confirmation-modal");
            const title = document.getElementById("confirmation-title");
            const desc = document.getElementById("confirmation-desc");
            const confirmBtn = document.getElementById(
              "confirmation-btn-confirm"
            );
            const cancelBtn = document.getElementById(
              "confirmation-btn-cancel"
            );

            title.textContent = "Delete Tab?";
            desc.textContent = `Are you sure you want to delete "${tab.name}" and all its tasks?`;
            modalOverlay.classList.add("visible"); // FIX: Add class directly to overlay

            const cleanup = () => {
              modalOverlay.classList.remove("visible");
              confirmBtn.onclick = null;
              cancelBtn.onclick = null;
            };

            confirmBtn.onclick = () => {
              performDelete(id);
              cleanup();
            };

            cancelBtn.onclick = cleanup;
          }

          function performDelete(id) {
            clockTaskTabs = clockTaskTabs.filter((t) => t.id !== id);
            if (clockTaskTabs.length === 0) {
              clockTaskTabs.push({
                id: "tab-" + Date.now(),
                name: "General",
                content: `<div class="todo-item"><input type="checkbox" class="todo-checkbox"><div class="list-content" placeholder="Dump your tasks here..."></div></div>`,
              });
            }

            if (activeTaskTabId === id) {
              activeTaskTabId = clockTaskTabs[0].id;
            }
            saveTaskTabs();
            renderTaskTabs();
            renderBrainDump();
          }

          function switchNotesTab(tab) {
            activeNotesTab = tab;
            localStorage.setItem("notesTabState", tab);

            const topicListContainer =
              document.getElementById("topic-list-view");
            const topicDetailContainer =
              document.getElementById("topic-detail-view");
            const topicFilterContainer = document.getElementById(
              "topic-filter-container"
            );
            const tabTopics = document.getElementById("tab-topics");
            const addElementBtn = document.getElementById("add-element-btn");
            const jumpToTodayBtn = document.getElementById("jump-to-today-btn");

            // Reset UI - remove active from all tabs
            tabNotes.classList.remove("active");
            tabTasks.classList.remove("active");
            if (tabTopics) tabTopics.classList.remove("active");

            // Hide all content containers
            finalNotesContentContainer.classList.add("hidden");
            tasksContentContainer.classList.add("hidden");
            if (topicListContainer) topicListContainer.classList.add("hidden");
            if (topicDetailContainer) {
              topicDetailContainer.classList.add("hidden");
              topicDetailContainer.style.display = "none";
            }
            if (topicFilterContainer)
              topicFilterContainer.classList.add("hidden");

            if (tab === "notes") {
              tabNotes.classList.add("active");
              finalNotesContentContainer.classList.remove("hidden");
              clearTasksBtn.style.display = "none";
              addElementBtn.style.display = "flex";
              renderNotesWidget();
              jumpToTodayBtn.style.display = "";
            } else if (tab === "tasks") {
              tabTasks.classList.add("active");
              tasksContentContainer.classList.remove("hidden");
              clearTasksBtn.style.display = "flex";
              addElementBtn.style.display = "none";
              jumpToTodayBtn.classList.remove("visible");
              jumpToTodayBtn.style.display = "none";
              renderTaskTabs();
              renderBrainDump();
            } else if (tab === "topics") {
              if (tabTopics) tabTopics.classList.add("active");

              if (activeTopicNoteId && topicDetailContainer) {
                topicDetailContainer.classList.remove("hidden");
                topicDetailContainer.style.display = "flex";
              } else if (topicListContainer) {
                topicListContainer.classList.remove("hidden");
                renderTopicList();
              }

              clearTasksBtn.style.display = "none";
              addElementBtn.style.display = "flex";
              jumpToTodayBtn.classList.remove("visible");
              jumpToTodayBtn.style.display = "none";
            }
          }

          function renderBrainDump() {
            // Load from Active Tab
            const activeTab = clockTaskTabs.find(
              (t) => t.id === activeTaskTabId
            );
            const content = activeTab ? activeTab.content : "";

            if (brainDumpList.innerHTML !== content) {
              brainDumpList.innerHTML = content;
            }

            brainDumpList.oninput = () => {
              activeEditorInstance = brainDumpList;
              saveTaskTabContent();
            };

            brainDumpList.onfocus = () => {
              activeEditorInstance = brainDumpList;
            };
          }

          clearTasksBtn.addEventListener("click", () => {
            if (confirm("Clear all tasks in this tab?")) {
              brainDumpList.innerHTML = `<div class="todo-item">
                                           <input type="checkbox" class="todo-checkbox">
                                           <div class="list-content" placeholder="Dump your tasks here..."></div>
                                         </div>`;
              saveTaskTabContent();
            }
          });

          // GLOBAL CHECKBOX DELEGATION
          document.addEventListener("change", (e) => {
            if (e.target.classList.contains("todo-checkbox")) {
              if (e.target.checked) {
                e.target.setAttribute("checked", "true");
                e.target.closest(".todo-item")?.classList.add("checked");
              } else {
                e.target.removeAttribute("checked");
                e.target.closest(".todo-item")?.classList.remove("checked");
              }

              const editor = e.target.closest(".note-editor");
              if (editor) {
                activeEditorInstance = editor;
                if (editor.id === "brain-dump-editor") {
                  saveTaskTabContent();
                } else {
                  saveCurrentNote();
                }
              }
            }
          });

          if (addTaskTabBtn) {
            addTaskTabBtn.addEventListener("click", addTaskTab);
          }

          if (tabNotes)
            tabNotes.addEventListener("click", (e) => {
              e.stopPropagation();
              switchNotesTab("notes");
            });
          if (tabTasks)
            tabTasks.addEventListener("click", (e) => {
              e.stopPropagation();
              switchNotesTab("tasks");
            });

          // Initialize Tab State
          const savedTabState = localStorage.getItem("notesTabState");
          if (savedTabState) {
            switchNotesTab(savedTabState);
          } else {
            // Default behavior
            renderBrainDump(); // Ensure tasks are ready even if hidden
          }

          // Digital Clock Toggle Listener
          if (digitalFormatToggle) {
            digitalFormatToggle.addEventListener("click", () => {
              digitalClockFormat = digitalClockFormat === "24h" ? "12h" : "24h";
              localStorage.setItem("digitalClockFormat", digitalClockFormat);
              updateDigitalClock();
            });
          }

          // Initial render
          renderCalendar();
          currentNotesDate = selectedDate; // Sync notes with calendar on start
          renderAppView();
          renderNotesWidget(); // Add this line to perform initial render of notes
          renderHabits(); // Initial render of habits
          updateDigitalClock(); // NEW: Immediate render of digital clock to prevent "00:00" delay

          // Intervals for real-time updates
          let lastRenderMinute = -1;
          setInterval(() => {
            updateClockHands();
            updateDigitalClock(); // NEW: Digital clock update
            updateProgressWidget(); // Update progress bar every second for smoothness
            updateSubtaskTimersUI(); // <<< ADD THIS LINE

            const now = new Date();
            // Only re-render the main view every minute to save performance
            if (now.getMinutes() !== lastRenderMinute) {
              if (
                (clockMode === "24h" && viewMode === "blocks") ||
                isToday(selectedDate)
              ) {
                renderAppView(); // This will also call updateProgressWidget for state sync
              }
              lastRenderMinute = now.getMinutes();
            }
          }, 1000);
        }
        init();
      });
    </script>
  </body>
</html>
